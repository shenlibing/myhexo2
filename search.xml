<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2019%2F08%2F06%2Fmian-shi-ti%2F</url>
    <content type="text"><![CDATA[阿里巴巴面试1、开发中Java用了比较多的数据结构有哪些? 2、谈谈你对HashMap的理解，底层原理的基本实现，HashMap怎么解决碰撞问题的? 这些数据结构中是线程安全的吗?假如你回答HashMap是线程安全的，接着问你有没有线程安全的map，接下来问了conurren包。 3、对JVM熟不熟悉?简单说说类加载过程，里面执行的哪些操作?问了GC和内存管理，平时在tomect里面有没有进行过相的配置 4、然后问了http协议，get和post的基本区别，接着tcp/ip协议，三次握手，窗口滑动机制。 5、开发中用了那些数据库?回答mysql，储存引擎有哪些?然后问了我悲观锁和乐观锁问题使用场景、分布式集群实现的原理。 6然后问了我springmvc和mybatis的工作原理，有没有看过底层源码? 京东金融面试1、Dubbo超时重试;Dubbo超时时间设置 2、如何保障请求执行顺序 3、分布式事物与分布式锁(扣款不要出现负数) 4、分布式session设置 5、执行某操作，前50次成功，第51次失败a全部回滚b前50次提交第51次抛异常，ab场景分别如何设置Spring(传播性) 6、Zookeeper有哪些用 7、JVM内存模型 8、数据库垂直和水平拆分 9、MyBatis如何分页;如何设置缓存;MySQL分页 10、熟悉IO么?与NIO的区别，阻塞与非阻塞的区别 11、分布式session一致性 12、分布式接口的幂等性设计「不能重复扣款」 美团面试1、最近做的比较熟悉的项目是哪个?画一下项目技术架构图 2、JVM老年代和新生代的比例? 3、YGC和FGC发生的具体场景 4、jstack，jmap，jutil分别的意义?如何线上排查JVM的相关问题? 5、线程池的构造类的方法的5个参数的具体意义? 6、单机上一个线程池正在处理服务如果忽然断电该怎么办?(正在处理和阻塞队列里的请求怎么处理)? 7、使用无界阻塞队列会出现什么问题? 8、接口如何处理重复请求? 9、具体处理方案是什么? 10、如何保证共享变量修改时的原子性? 11、设计一个对外服务的接口实现类，在1,2,3这三个主机(对应不同IP)上实现负载均衡和顺序轮询机制(考虑并发) 滴滴面试1、自我介绍，技术特点 2、兴趣是什么，优势是什么 3、jvm，jre以及jdk三者之间的关系? 4、Dubbo的底层原理，Zookeeper是什么 5、cincurrentMap的机制;TreeMap;Volatil关键字 6、快速排序;广度优先搜索(队列实现) 7、缓存的雪崩以及穿透的理解? 8、HashMap的key可以重复吗? 9、synchronized和lock的区别? 10.开发一个大型网站你会考虑哪些问题? 本次卧底面试得到的结论 通过面试题来看，可以看出目前互联网公司面试考点为： 1.性能调优、算法数据机构 2.高并发下数据安全、接口冪等性、原子性等 3.分布式下协同、已经锁的处理 4.数据库的分库分表、项目之间的垂直拆分 出现频率高的技术点有： HashMap JVM Dubbo Mybatis Zookeeper http tcp/ip]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux性能分析]]></title>
    <url>%2F2019%2F08%2F05%2Flinux-xing-neng-fen-xi%2F</url>
    <content type="text"><![CDATA[生产环境服务器变慢，诊断思路和性能评估整机：top代码 public class JavaDemo2 { public static void main(String[] args) { while (true){ System.out.println(new java.util.Random().nextInt(77778888)); } } } top命令查看 [root@192 ~]# top top - 11:28:50 up 7 min, 2 users, load average: 0.73, 0.39, 0.18 Tasks: 230 total, 1 running, 229 sleeping, 0 stopped, 0 zombie Cpu(s): 1.0%us, 2.3%sy, 0.0%ni, 96.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 1906280k total, 649948k used, 1256332k free, 21164k buffers Swap: 2097148k total, 0k used, 2097148k free, 203820k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 3672 root 20 0 3158m 94m 11m S 15.6 5.1 0:13.67 java 3397 root 20 0 100m 5388 3396 S 9.3 0.3 0:09.00 sshd 39 root 20 0 0 0 0 S 1.7 0.0 0:00.25 events/4 37 root 20 0 0 0 0 S 1.0 0.0 0:00.39 events/2 35 root 20 0 0 0 0 S 0.3 0.0 0:01.27 events/0 36 root 20 0 0 0 0 S 0.3 0.0 0:00.34 events/1 41 root 20 0 0 0 0 S 0.3 0.0 0:00.24 events/6 [root@192 ~]# uptime 11:29:09 up 7 min, 2 users, load average: 0.52, 0.36, 0.18 CPU：vmstat[root@192 ~]# vmstat -n 2 3 procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 1313028 21228 203868 0 0 54 3 112 1620 0 1 98 0 0 0 0 0 1312732 21228 203896 0 0 0 0 2579 25940 1 3 96 0 0 0 0 0 1312856 21228 203896 0 0 0 0 2677 24290 1 3 97 0 0 id:处于空闲的CPU百分比 wa:系统等待IO的CPU时间百分比 st:来自于一个虚拟机偷取的CPU时间百分比 查看额外的CPU信息 所有CPU核信息 [root@192 ~]# mpstat -P ALL 2 Linux 2.6.32-642.el6.x86_64 (192.168.1.101) 08/05/2019 _x86_64_ (8 CPU) 11:42:40 AM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %idle 11:42:42 AM all 1.07 0.00 2.89 0.00 0.00 0.00 0.00 0.00 96.04 11:42:42 AM 0 0.00 0.00 1.52 0.00 0.00 0.00 0.00 0.00 98.48 11:42:42 AM 1 6.09 0.00 9.14 0.00 0.00 0.00 0.00 0.00 84.77 11:42:42 AM 2 0.50 0.00 4.02 0.00 0.00 0.00 0.00 0.00 95.48 11:42:42 AM 3 1.00 0.00 2.00 0.00 0.00 0.00 0.00 0.00 97.00 每个进程使用CPU的用量分解信息 [root@192 ~]# pidstat -u 1 -p 3790 Linux 2.6.32-642.el6.x86_64 (192.168.1.101) 08/05/2019 _x86_64_ (8 CPU) 11:45:00 AM PID %usr %system %guest %CPU CPU Command 11:45:01 AM 3790 6.00 10.00 0.00 16.00 7 java 11:45:02 AM 3790 4.00 11.00 0.00 15.00 7 java 11:45:03 AM 3790 9.00 15.00 0.00 24.00 7 java 11:45:04 AM 3790 7.00 14.00 0.00 21.00 7 java 内存：free应用程序可用内存数 推荐使用free -m [root@192 ~]# free -g total used free shared buffers cached Mem: 1 0 1 0 0 0 -/+ buffers/cache: 0 1 Swap: 1 0 1 [root@192 ~]# free -m total used free shared buffers cached Mem: 1861 553 1308 1 20 199 -/+ buffers/cache: 333 1528 Swap: 2047 0 2047 查看额外 [root@192 ~]# pidstat -p 3823 -r 2 Linux 2.6.32-642.el6.x86_64 (192.168.1.101) 08/05/2019 _x86_64_ (8 CPU) 11:51:16 AM PID minflt/s majflt/s VSZ RSS %MEM Command 11:51:18 AM 3823 1.00 0.00 3234728 47068 2.47 java 11:51:20 AM 3823 2.50 0.00 3234728 47068 2.47 java 11:51:22 AM 3823 0.50 0.00 3234728 47068 2.47 java 11:51:24 AM 3823 2.50 0.00 3234728 47068 2.47 java 11:51:26 AM 3823 0.50 0.00 3234728 47068 2.47 java 硬盘：df查看磁盘剩余空间 [root@192 ~]# df -h Filesystem Size Used Avail Use% Mounted on /dev/sda2 15G 5.6G 8.4G 41% / tmpfs 931M 72K 931M 1% /dev/shm /dev/sda1 190M 39M 142M 22% /boot磁盘IO：iostat[root@192 ~]# iostat -xdk 2 3 Linux 2.6.32-642.el6.x86_64 (192.168.1.101) 08/05/2019 _x86_64_ (8 CPU) Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util scd0 0.00 0.00 0.38 0.00 1.50 0.00 8.00 0.00 0.67 0.67 0.00 0.67 0.03 sda 34.33 4.94 47.36 3.18 1631.23 32.44 65.84 0.07 1.38 1.22 3.72 0.88 4.43 Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util scd0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 sda 0.00 0.00 0.50 0.00 4.00 0.00 16.00 0.00 1.00 1.00 0.00 1.00 0.05 Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util scd0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 sda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 查看额外 [root@192 ~]# pidstat -d 2 -p 3485 Linux 2.6.32-642.el6.x86_64 (192.168.1.101) 08/05/2019 _x86_64_ (8 CPU) 02:16:10 PM PID kB_rd/s kB_wr/s kB_ccwr/s Command 02:16:12 PM 3485 0.00 0.00 0.00 java 02:16:14 PM 3485 0.00 0.00 0.00 java 02:16:16 PM 3485 0.00 0.00 0.00 java 02:16:18 PM 3485 0.00 0.00 0.00 java 02:16:20 PM 3485 0.00 0.00 0.00 java 02:16:22 PM 3485 0.00 0.00 0.00 java 02:16:24 PM 3485 0.00 0.00 0.00 java 网络IO：ifstat默认本地没有，需要下载ifstat 安装ifstat [root@192 ifstat-1.1]# yum install flex byacc libpcap ncurses ncurses-devel libpcap-devel gcc-c++ wget http://gael.roualland.free.fr/ifstat/ifstat-1.1.tar.gz tar xzvf ifstat-1.1.tar.gz cd ifstat-1.1 ./configure make make install[root@192 ifstat-1.1]# ifstat 1 eth0 KB/s in KB/s out 0.06 0.13 0.06 0.12 0.06 0.12 0.06 0.12 0.06 0.12 0.06 0.12 0.12 0.17 0.06 0.12生产环境出现CPU占用过高，分析思路和定位public class JavaDemo2 { public static void main(String[] args) { while (true){ System.out.println(new java.util.Random().nextInt(77778888)); } } } 先用top命令找出CPU占比最高的 PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 4294 root 20 0 3158m 37m 11m S 16.6 2.0 0:03.28 java 3428 root 20 0 100m 5444 3396 S 14.3 0.3 0:22.85 sshd 35 root 20 0 0 0 0 S 1.0 0.0 0:03.18 events/0 41 root 20 0 0 0 0 S 0.3 0.0 0:00.52 events/6 2012 root 20 0 199m 5192 4288 S 0.3 0.3 0:00.32 ManagementAgent 1 root 20 0 19344 1544 1228 S 0.0 0.1 0:01.83 init 2 root 20 0 0 0 0 S 0.0 0.0 0:00.02 kthreadd ps -ef或者jps进一步定位[root@192 ifstat-1.1]# jps 4320 Jps 4294 JavaDemo2定位到具体线程或者代码[root@192 ifstat-1.1]# ps -mp 4294 -o THREAD,tid,time USER %CPU PRI SCNT WCHAN USER SYSTEM TID TIME root 18.6 - - - - - - 00:00:15 root 0.0 19 - futex_ - - 4294 00:00:00 root 15.6 19 - n_tty_ - - 4295 00:00:13 root 0.2 19 - futex_ - - 4296 00:00:00 root 0.2 19 - futex_ - - 4297 00:00:00 root 0.3 19 - futex_ - - 4298 00:00:00 root 0.2 19 - futex_ - - 4299 00:00:00 root 0.3 19 - futex_ - - 4300 00:00:00 root 0.3 19 - futex_ - - 4301 00:00:00 root 0.3 19 - futex_ - - 4302 00:00:00 root 0.2 19 - futex_ - - 4303 00:00:00 root 0.0 19 - futex_ - - 4304 00:00:00 root 0.0 19 - futex_ - - 4305 00:00:00 root 0.0 19 - futex_ - - 4306 00:00:00 root 0.0 19 - futex_ - - 4307 00:00:00 root 0.0 19 - futex_ - - 4308 00:00:00 root 0.1 19 - futex_ - - 4309 00:00:00 root 0.0 19 - futex_ - - 4310 00:00:00 root 0.0 19 - futex_ - - 4311 00:00:00 root 0.0 19 - futex_ - - 4312 00:00:00 root 0.0 19 - futex_ - - 4313 00:00:00-m:显示所有的线程 -p: pid进程使用CPU的时间 -o:该参数后是用户自定义格式 线程ID转换为16进制格式（英文小写格式）[root@192 ifstat-1.1]# printf &quot;%x\n&quot; 4295 10c7jstack 进程ID|grep tid(16进制线程ID小写英文) -A60[root@192 ifstat-1.1]# jstack 4294 | grep 10c7 -A60 &quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007f7f68009000 nid=0x10c7 runnable [0x00007f7f6f117000] java.lang.Thread.State: RUNNABLE at java.io.FileOutputStream.writeBytes(Native Method) at java.io.FileOutputStream.write(FileOutputStream.java:326) at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82) at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140) - locked &lt;0x00000000e2e0e6e0&gt; (a java.io.BufferedOutputStream) at java.io.PrintStream.write(PrintStream.java:482) - locked &lt;0x00000000e2e0bbd8&gt; (a java.io.PrintStream) at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221) at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291) at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104) - locked &lt;0x00000000e2e0e800&gt; (a java.io.OutputStreamWriter) at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185) at java.io.PrintStream.newLine(PrintStream.java:546) - eliminated &lt;0x00000000e2e0bbd8&gt; (a java.io.PrintStream) at java.io.PrintStream.println(PrintStream.java:737) - locked &lt;0x00000000e2e0bbd8&gt; (a java.io.PrintStream) at JavaDemo2.main(JavaDemo2.java:4) &quot;VM Thread&quot; os_prio=0 tid=0x00007f7f68080000 nid=0x10d0 runnable &quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f6801e800 nid=0x10c8 runnable &quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f68020000 nid=0x10c9 runnable &quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f68022000 nid=0x10ca runnable &quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f68024000 nid=0x10cb runnable &quot;GC task thread#4 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f68025800 nid=0x10cc runnable &quot;GC task thread#5 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f68027800 nid=0x10cd runnable &quot;GC task thread#6 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f68029800 nid=0x10ce runnable &quot;GC task thread#7 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f6802b000 nid=0x10cf runnable &quot;VM Periodic Task Thread&quot; os_prio=0 tid=0x00007f7f680e8000 nid=0x10d9 waiting on condition JNI global references: 5参考 找到最耗CPU的java线程 - - ITeye博客]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F07%2F31%2Fdan-li-mo-shi%2F</url>
    <content type="text"><![CDATA[单例模式非单例public class SingletonDemo { private static SingletonDemo instance = null; private SingletonDemo() { System.out.println(Thread.currentThread().getName() + "\t 我是构造方法SingletonDemo()"); } public static SingletonDemo getInstance() { if (instance == null) { instance = new SingletonDemo(); } return instance; } public static void main(String[] args) { for (int i = 0; i &lt;= 10; i++) { new Thread(() -> { SingletonDemo.getInstance(); }, String.valueOf(i)).start(); } } } 结果 非单例模式，构造方法被调用多次 2 我是构造方法SingletonDemo() 3 我是构造方法SingletonDemo() 0 我是构造方法SingletonDemo() 1 我是构造方法SingletonDemo()单例volatile特点：可见性、禁止指令重排、不能保证原子性 synchronized特点：原子性、可见性、不能保证禁止指令重排 原子性：是指一个操作是不可中断的，要全部执行完成，要不就都不执行。线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。 可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。 禁止指令重排：程序执行的顺序按照代码的先后顺序执行。除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在指令重排问题。 被synchronized修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。 被synchronized修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而为了保证可见性，有一条规则是这样的：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。 被synchronized修饰的代码是无法禁止指令重排和处理器优化的。如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。由于synchronized修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证禁止指令重排，但是本身不具备禁止指令重排，有点绕口。 版本一public class SingletonDemo { //加上volatile,禁止指令重排 private static volatile SingletonDemo instance = null; private SingletonDemo() { System.out.println(Thread.currentThread().getName() + "\t 我是构造方法SingletonDemo()"); } public static synchronized SingletonDemo getInstance() { if (instance == null) { instance = new SingletonDemo(); } return instance; } public static void main(String[] args) { for (int i = 0; i &lt;= 10; i++) { new Thread(() -> { SingletonDemo.getInstance(); }, String.valueOf(i)).start(); } } } 结果 单例模式，构造方法只被调用一次 0 我是构造方法SingletonDemo()版本二public class SingletonDemo { //加上volatile,禁止指令重排 private static volatile SingletonDemo instance = null; private SingletonDemo() { System.out.println(Thread.currentThread().getName() + "\t 我是构造方法SingletonDemo()"); } public static SingletonDemo getInstance() { if (instance == null) { //双端检锁机制，加锁前后进行判断 synchronized (SingletonDemo.class) { if (instance == null) { instance = new SingletonDemo(); } } } return instance; } public static void main(String[] args) { for (int i = 0; i &lt;= 10; i++) { new Thread(() -> { SingletonDemo.getInstance(); }, String.valueOf(i)).start(); } } } 结果 单例模式下，构造方法只会被调用一次 1 我是构造方法SingletonDemo()参考再有人问你synchronized是什么，就把这篇文章发给他。-HollisChuang’s Blog]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的锁]]></title>
    <url>%2F2019%2F07%2F30%2Fjava-zhong-de-suo%2F</url>
    <content type="text"><![CDATA[引言在java单线程中，并不会出现资源抢夺的现象，但是在多线程并发中，会出现资源抢夺现象。为了避免这种情况需要上锁 分类可重入锁，又名递归锁指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，也即是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。 使用synchronized class Phone{ public void sendSMS() { System.out.println(Thread.currentThread().getName()+"\t invoked sendSMS()"); sendEmail(); } private void sendEmail() { System.out.println(Thread.currentThread().getName()+"\t ###########invoked sendEmail()"); } } public class ReentrantLockDemo { public static void main(String[] args) { Phone phone = new Phone(); new Thread(()->{ phone.sendSMS(); },"t1").start(); new Thread(()->{ phone.sendSMS(); },"t2").start(); } } 结果 t1 invoked sendSMS() //t1线程在外层方法获取锁的时候 t1 ###########invoked sendEmail() //t1在线程进入内层方法会自动获取锁 t2 invoked sendSMS() t2 ###########invoked sendEmail()使用ReentrantLockimport java.util.concurrent.TimeUnit; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; class Phone implements Runnable { Lock lock = new ReentrantLock(); public void sendSMS() { System.out.println(Thread.currentThread().getName() + "\t invoked sendSMS()"); sendEmail(); } private void sendEmail() { System.out.println(Thread.currentThread().getName() + "\t ###########invoked sendEmail()"); } @Override public void run() { get(); } public void get() { lock.lock(); try{ System.out.println(Thread.currentThread().getName() + "\t invoked get()"); set(); }catch (Exception e){ }finally { lock.unlock(); } } private void set() { lock.lock(); try{ System.out.println(Thread.currentThread().getName() + "\t invoked set()"); }catch (Exception e){ }finally { lock.unlock(); } } } public class ReentrantLockDemo { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -> { phone.sendSMS(); }, "t1").start(); new Thread(() -> { phone.sendSMS(); }, "t2").start(); //暂停一会线程 try { TimeUnit.MICROSECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(); System.out.println(); System.out.println(); System.out.println(); Thread t3 = new Thread(phone,"t3"); Thread t4 = new Thread(phone,"t4"); t3.start(); t4.start(); } } 结果 t1 invoked sendSMS() t1 ###########invoked sendEmail() t2 invoked sendSMS() t2 ###########invoked sendEmail() t3 invoked get() t3 invoked set() t4 invoked get() t4 invoked set()自旋锁CAS循环比较并交换 是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicReference; public class SpinLockDemo { AtomicReference&lt;Thread> atomicReference = new AtomicReference&lt;>(); public void myLock() { Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + "\t come in..."); while (!atomicReference.compareAndSet(null, thread)) { } } public void myUnLock() { Thread thread = Thread.currentThread(); atomicReference.compareAndSet(thread, null); System.out.println(Thread.currentThread().getName() + "\t invoked myUnLock()"); } public static void main(String[] args) { SpinLockDemo spinLockDemo = new SpinLockDemo(); new Thread(() -> { spinLockDemo.myLock(); //暂停一会线程 try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } spinLockDemo.myUnLock(); }, "AA").start(); //暂停一会线程 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -> { spinLockDemo.myLock(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } spinLockDemo.myUnLock(); }, "BB").start(); } } 结果 AA come in... BB come in... AA invoked myUnLock() BB invoked myUnLock()读写锁读时共享资源数据，写时独占资源数据 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果有一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写。 读-读能共存 读-写不能共存 写-写不能共存 没有使用读写锁前import java.util.HashMap; import java.util.Map; import java.util.concurrent.TimeUnit; class MyCache{ private volatile Map&lt;String,Object> map=new HashMap&lt;>(); public void put(String key, String value) { System.out.println(Thread.currentThread().getName()+"\t 正在写入："+key); //暂停一会线程 try { TimeUnit.MICROSECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } map.put(key,value); System.out.println(Thread.currentThread().getName()+"\t 写入完成："); } public void get(String key) { System.out.println(Thread.currentThread().getName()+"\t 正在读取："); //暂停一会线程 try { TimeUnit.MICROSECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } Object result = map.get(key); System.out.println(Thread.currentThread().getName()+"\t 读取完成："+result); } } public class ReadWriteDemo { public static void main(String[] args) { MyCache myCache = new MyCache(); //创建5个线程,写入资源数据 for(int i=1;i&lt;=5;i++){ final int tempInt = i; new Thread(()->{ myCache.put(tempInt+"",tempInt+""); },String.valueOf(i)).start(); } //创建5个线程,读取资源数据 for(int i=1;i&lt;=5;i++){ final int tempInt = i; new Thread(()->{ myCache.get(tempInt+""); },String.valueOf(i)).start(); } } } 结果 写时并不满足原子性和独占性，整个过程必须是一个完整的统一体，中间不允许被分割，被打断 5 正在写入：5 1 正在写入：1 3 正在写入：3 2 正在读取： 4 正在写入：4 2 正在写入：2 1 正在读取： 5 正在读取： 3 正在读取： 4 正在读取： 2 写入完成： 5 读取完成：5 5 写入完成： 4 读取完成：null 2 读取完成：null 3 写入完成： 1 读取完成：null 1 写入完成： 3 读取完成：3 4 写入完成：使用读写锁后使用ReentrantReadWriteLock import java.util.HashMap; import java.util.Map; import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.ReentrantReadWriteLock; class MyCache { private volatile Map&lt;String, Object> map = new HashMap&lt;>(); //读写锁 private ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock(); public void put(String key, String value) { rwlock.writeLock().lock(); try { System.out.println(Thread.currentThread().getName() + "\t 正在写入：" + key); //暂停一会线程 try { TimeUnit.MICROSECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } map.put(key, value); System.out.println(Thread.currentThread().getName() + "\t 写入完成："); } catch (Exception e) { e.printStackTrace(); } finally { rwlock.writeLock().unlock(); } } public void get(String key) { rwlock.readLock().lock(); try { System.out.println(Thread.currentThread().getName() + "\t 正在读取："); //暂停一会线程 try { TimeUnit.MICROSECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } Object result = map.get(key); System.out.println(Thread.currentThread().getName() + "\t 读取完成：" + result); } catch (Exception e) { e.printStackTrace(); } finally { rwlock.readLock().unlock(); } } } public class ReadWriteDemo { public static void main(String[] args) { MyCache myCache = new MyCache(); //创建5个线程,写入资源数据 for (int i = 1; i &lt;= 5; i++) { final int tempInt = i; new Thread(() -> { myCache.put(tempInt + "", tempInt + ""); }, String.valueOf(i)).start(); } //创建5个线程,读取资源数据 for (int i = 1; i &lt;= 5; i++) { final int tempInt = i; new Thread(() -> { myCache.get(tempInt + ""); }, String.valueOf(i)).start(); } } } 结果 4 正在写入：4 4 写入完成： 2 正在写入：2 2 写入完成： 1 正在写入：1 1 写入完成： 3 正在写入：3 3 写入完成： 5 正在写入：5 5 写入完成： 1 正在读取： 4 正在读取： 2 正在读取： 3 正在读取： 5 正在读取： 3 读取完成：3 1 读取完成：1 5 读取完成：5 2 读取完成：2 4 读取完成：4参考一道面试题比较synchronized和读写锁 - where - ITeye博客]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic]]></title>
    <url>%2F2019%2F07%2F08%2Felastic%2F</url>
    <content type="text"><![CDATA[安装elastic下载Elasticsearch 6.3.1 | Elastic 解压[root@192 modules]# tar -zxvf elasticsearch-6.3.1.tar.gz启动报错一elasticsearch 为了安全性默认不允许root 用户来启动 [root@192 elasticsearch-6.3.1]# cd bin/ [root@192 bin]# ./elasticsearch [2019-07-08T08:45:49,312][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [] uncaught exception in thread [main] org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:140) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:127) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) ~[elasticsearch-cli-6.3.1.jar:6.3.1] at org.elasticsearch.cli.Command.main(Command.java:90) ~[elasticsearch-cli-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:93) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:86) ~[elasticsearch-6.3.1.jar:6.3.1] Caused by: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:104) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:171) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:326) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:136) ~[elasticsearch-6.3.1.jar:6.3.1] ... 6 more 新建立es用户 [root@192 bin]# useradd es [root@192 bin]# pwd /opt/modules/elasticsearch-6.3.1/bin [root@192 bin]# cd [root@192 ~]# pwd /root [root@192 ~]# cd /opt/modules/elasticsearch-6.3.1 [root@192 elasticsearch-6.3.1]# ll total 460 drwxr-xr-x. 3 root root 4096 Jul 8 08:43 bin drwxr-xr-x. 2 root root 4096 Jul 8 08:45 config drwxr-xr-x. 2 root root 4096 Jun 30 2018 lib -rw-r--r--. 1 root root 13675 Jun 30 2018 LICENSE.txt drwxr-xr-x. 2 root root 4096 Jul 8 08:45 logs drwxr-xr-x. 17 root root 4096 Jun 30 2018 modules -rw-r--r--. 1 root root 416018 Jun 30 2018 NOTICE.txt drwxr-xr-x. 2 root root 4096 Jun 30 2018 plugins -rw-r--r--. 1 root root 8511 Jun 30 2018 README.textile报错二授权、启动 [root@192 elasticsearch-6.3.1]# chown -R es:es ./ [root@192 elasticsearch-6.3.1]# ll total 460 drwxr-xr-x. 3 es es 4096 Jul 8 08:43 bin drwxr-xr-x. 2 es es 4096 Jul 8 08:45 config drwxr-xr-x. 2 es es 4096 Jun 30 2018 lib -rw-r--r--. 1 es es 13675 Jun 30 2018 LICENSE.txt drwxr-xr-x. 2 es es 4096 Jul 8 08:45 logs drwxr-xr-x. 17 es es 4096 Jun 30 2018 modules -rw-r--r--. 1 es es 416018 Jun 30 2018 NOTICE.txt drwxr-xr-x. 2 es es 4096 Jun 30 2018 plugins -rw-r--r--. 1 es es 8511 Jun 30 2018 README.textile [root@192 elasticsearch-6.3.1]# su es [es@192 elasticsearch-6.3.1]$ ./bin/elasticsearch [2019-07-08T08:48:42,989][WARN ][o.e.b.JNANatives ] unable to install syscall filter: java.lang.UnsupportedOperationException: seccomp unavailable: CONFIG_SECCOMP not compiled into kernel, CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER are needed at org.elasticsearch.bootstrap.SystemCallFilter.linuxImpl(SystemCallFilter.java:341) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.SystemCallFilter.init(SystemCallFilter.java:616) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.JNANatives.tryInstallSystemCallFilter(JNANatives.java:258) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Natives.tryInstallSystemCallFilter(Natives.java:113) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:109) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:171) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:326) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:136) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:127) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) [elasticsearch-cli-6.3.1.jar:6.3.1] at org.elasticsearch.cli.Command.main(Command.java:90) [elasticsearch-cli-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:93) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:86) [elasticsearch-6.3.1.jar:6.3.1]解决 进入/opt/modules/elasticsearch-6.3.1/config目录，修改配置文件 elasticsearch.yml，末尾追加 bootstrap.memory_lock: false bootstrap.system_call_filter: false报错三用户最大文件描述符限制低于 65536 而抛出的异常 用户最大的线程数限制低于 4096 而抛出的异常 系统最大虚拟内存低于 262144 而抛出的异常 [es@192 elasticsearch-6.3.1]$ ./bin/elasticsearch [2019-07-08T08:56:38,934][INFO ][o.e.n.Node ] [] initializing ... [2019-07-08T08:56:39,016][INFO ][o.e.e.NodeEnvironment ] [zzp49gD] using [1] data paths, mounts [[/ (rootfs)]], net usable_space [9.2gb], net total_space [14.6gb], types [rootfs] [2019-07-08T08:56:39,016][INFO ][o.e.e.NodeEnvironment ] [zzp49gD] heap size [989.8mb], compressed ordinary object pointers [true] [2019-07-08T08:56:39,017][INFO ][o.e.n.Node ] [zzp49gD] node name derived from node ID [zzp49gDDT1yAkU_sqvvLdw]; set [node.name] to override [2019-07-08T08:56:39,018][INFO ][o.e.n.Node ] [zzp49gD] version[6.3.1], pid[3815], build[default/tar/eb782d0/2018-06-29T21:59:26.107521Z], OS[Linux/2.6.32-642.el6.x86_64/amd64], JVM[Oracle Corporation/Java HotSpot(TM) 64-Bit Server VM/1.8.0_202/25.202-b08] [2019-07-08T08:56:39,018][INFO ][o.e.n.Node ] [zzp49gD] JVM arguments [-Xms1g, -Xmx1g, -XX:+UseConcMarkSweepGC, -XX:CMSInitiatingOccupancyFraction=75, -XX:+UseCMSInitiatingOccupancyOnly, -XX:+AlwaysPreTouch, -Xss1m, -Djava.awt.headless=true, -Dfile.encoding=UTF-8, -Djna.nosys=true, -XX:-OmitStackTraceInFastThrow, -Dio.netty.noUnsafe=true, -Dio.netty.noKeySetOptimization=true, -Dio.netty.recycler.maxCapacityPerThread=0, -Dlog4j.shutdownHookEnabled=false, -Dlog4j2.disable.jmx=true, -Djava.io.tmpdir=/tmp/elasticsearch.KQ6g6BOC, -XX:+HeapDumpOnOutOfMemoryError, -XX:HeapDumpPath=data, -XX:ErrorFile=logs/hs_err_pid%p.log, -XX:+PrintGCDetails, -XX:+PrintGCDateStamps, -XX:+PrintTenuringDistribution, -XX:+PrintGCApplicationStoppedTime, -Xloggc:logs/gc.log, -XX:+UseGCLogFileRotation, -XX:NumberOfGCLogFiles=32, -XX:GCLogFileSize=64m, -Des.path.home=/opt/modules/elasticsearch-6.3.1, -Des.path.conf=/opt/modules/elasticsearch-6.3.1/config, -Des.distribution.flavor=default, -Des.distribution.type=tar] [2019-07-08T08:56:40,833][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [aggs-matrix-stats] [2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [analysis-common] [2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [ingest-common] [2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [lang-expression] [2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [lang-mustache] [2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [lang-painless] [2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [mapper-extras] [2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [parent-join] [2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [percolator] [2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [rank-eval] [2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [reindex] [2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [repository-url] [2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [transport-netty4] [2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [tribe] [2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-core] [2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-deprecation] [2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-graph] [2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-logstash] [2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-ml] [2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-monitoring] [2019-07-08T08:56:40,836][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-rollup] [2019-07-08T08:56:40,836][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-security] [2019-07-08T08:56:40,836][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-sql] [2019-07-08T08:56:40,836][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-upgrade] [2019-07-08T08:56:40,836][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-watcher] [2019-07-08T08:56:40,836][INFO ][o.e.p.PluginsService ] [zzp49gD] no plugins loaded [2019-07-08T08:56:43,471][INFO ][o.e.x.s.a.s.FileRolesStore] [zzp49gD] parsed [0] roles from file [/opt/modules/elasticsearch-6.3.1/config/roles.yml] [2019-07-08T08:56:43,817][INFO ][o.e.x.m.j.p.l.CppLogMessageHandler] [controller/3894] [Main.cc@109] controller (64 bit): Version 6.3.1 (Build 4d0b8f0a0ef401) Copyright (c) 2018 Elasticsearch BV [2019-07-08T08:56:44,114][DEBUG][o.e.a.ActionModule ] Using REST wrapper from plugin org.elasticsearch.xpack.security.Security [2019-07-08T08:56:44,331][INFO ][o.e.d.DiscoveryModule ] [zzp49gD] using discovery type [zen] [2019-07-08T08:56:45,016][INFO ][o.e.n.Node ] [zzp49gD] initialized [2019-07-08T08:56:45,016][INFO ][o.e.n.Node ] [zzp49gD] starting ... [2019-07-08T08:56:45,173][INFO ][o.e.t.TransportService ] [zzp49gD] publish_address {192.168.1.101:9300}, bound_addresses {192.168.1.101:9300} [2019-07-08T08:56:45,196][INFO ][o.e.b.BootstrapChecks ] [zzp49gD] bound or publishing to a non-loopback address, enforcing bootstrap checks ERROR: [3] bootstrap checks failed [1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536] [2]: max number of threads [1024] for user [es] is too low, increase to at least [4096] [3]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] [2019-07-08T08:56:45,223][INFO ][o.e.n.Node ] [zzp49gD] stopping ... [2019-07-08T08:56:45,295][INFO ][o.e.n.Node ] [zzp49gD] stopped [2019-07-08T08:56:45,295][INFO ][o.e.n.Node ] [zzp49gD] closing ... [2019-07-08T08:56:45,307][INFO ][o.e.n.Node ] [zzp49gD] closed [2019-07-08T08:56:45,313][INFO ][o.e.x.m.j.p.NativeController] Native controller process has stopped - no new native processes can be started 解决户最大文件描述符限制低于 65536 而抛出的异常 切换到root用户,进入/etc/security/目录，修改limits.conf文件，末尾追加 * hard nofile 65536 * soft nofile 131072 * hard nproc 4096 * soft nproc 2048解决用户最大的线程数限制低于 4096 而抛出的异常 切换到root用户,进入/etc/security/limits.d目录，修改90-nproc.conf文件 * soft nproc 4096 root soft nproc unlimited解决系统最大虚拟内存低于 262144 而抛出的异常 修改/etc/sysctl.conf文件，末尾追加 vm.max_map_count=655360 fs.file-max=655360配置访问地址进入/opt/modules/elasticsearch-6.3.1/config目录，修改elasticsearch.yml文件 访问 [es@192 elasticsearch-6.3.1]$ curl http://192.168.1.101:9200 { &quot;name&quot; : &quot;zzp49gD&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;i0I9Oc2gQxOkc-jk4ZvEvw&quot;, &quot;version&quot; : { &quot;number&quot; : &quot;6.3.1&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;eb782d0&quot;, &quot;build_date&quot; : &quot;2018-06-29T21:59:26.107521Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;7.3.1&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot; } [es@192 elasticsearch-6.3.1]$ 安装kibana下载Kibana 6.3.1 | Elastic 解压[root@192 bin]# tar -zxvf kibana-6.3.1-linux-x86_64.tar.gz 修改配置文件进入 [root@192 bin]# cd kibana-6.3.1-linux-x86_64/config/修改kibana.yml配置文件 启动[root@192 bin]# pwd /opt/modules/kibana-6.3.1-linux-x86_64/bin [root@192 bin]# nohup ./kibana &amp; [1] 3665 [root@192 bin]# nohup: ignoring input and appending output to `nohup.out&#39; [root@192 bin]# ps -ef | grep node root 3665 3615 51 08:45 pts/0 00:00:25 ./../node/bin/node --no-warnings ./../src/cli root 3685 3615 0 08:46 pts/0 00:00:00 grep node 访问 操作es增删改查ES 简单操作 - ELK - Wiki.Shileizcc.com 增 PUT /movie_index/movie/1 { "id":1, "name":"operation red sea", "doubanscore":8.5, "actorList":[ { "id":1,"name":"zhang yi" }, { "id":2,"name":"hai qing" }, { "id":3,"name":"zhang han yu" } ] } 删 DELETE /movie_index/movie/1改 和新增一样，PUT既可以新增，也可以修改 PUT /movie_index/movie/1 { &quot;id&quot;:2, &quot;name&quot;:&quot;operation red sea&quot;, &quot;doubanscore&quot;:8.5, &quot;actorList&quot;:[ { &quot;id&quot;:1,&quot;name&quot;:&quot;zhang yi&quot; }, { &quot;id&quot;:2,&quot;name&quot;:&quot;hai qing&quot; }, { &quot;id&quot;:3,&quot;name&quot;:&quot;zhang han yu&quot; } ] }查 GET /movie_index/_search安装分词器analysis-ik下载Release v6.3.1 · medcl/elasticsearch-analysis-ik 解压、上传 [root@192 ~]# cd /opt/modules/elasticsearch-6.3.1/plugins/ [root@192 plugins]# ll total 4 drwxr-xr-x. 3 root root 4096 Jul 10 08:51 elasticsearch-analysis-ik-6.3.1 [root@192 plugins]# 重启es[root@192 bin]# su es [es@192 bin]$ nohup ./elasticsearch &amp; [1] 4002 [es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&#39; [es@192 bin]$ ps -ef|grep elastic es 4002 3987 99 08:45 pts/0 00:00:25 /usr/java/jdk1.8.0_202-amd64/bin/java -Xms1g -Xmx1g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -Xss1m -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djna.nosys=true -XX:-OmitStackTraceInFastThrow -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Djava.io.tmpdir=/tmp/elasticsearch.iMX34Qx6 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=data -XX:ErrorFile=logs/hs_err_pid%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -Xloggc:logs/gc.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=32 -XX:GCLogFileSize=64m -Des.path.home=/opt/modules/elasticsearch-6.3.1 -Des.path.conf=/opt/modules/elasticsearch-6.3.1/config -Des.distribution.flavor=default -Des.distribution.type=tar -cp /opt/modules/elasticsearch-6.3.1/lib/* org.elasticsearch.bootstrap.Elasticsearch es 4081 4002 0 08:45 pts/0 00:00:00 /opt/modules/elasticsearch-6.3.1/modules/x-pack/x-pack-ml/platform/linux-x86_64/bin/controller es 4092 3987 0 08:45 pts/0 00:00:00 grep elastic [es@192 bin]$ kill -9 4002 [es@192 bin]$ ps -ef|grep elastic es 4235 3987 0 08:54 pts/0 00:00:00 grep elastic [2]+ Killed nohup ./kibana [es@192 bin]$ cd /opt/modules/elasticsearch-6.3.1/bin/ [es@192 bin]$ nohup ./elasticsearch &amp; [1] 4238 [es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&#39; [es@192 bin]$ ps -ef|grep elastic es 4238 3987 99 08:54 pts/0 00:00:15 /usr/java/jdk1.8.0_202-amd64/bin/java -Xms1g -Xmx1g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -Xss1m -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djna.nosys=true -XX:-OmitStackTraceInFastThrow -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Djava.io.tmpdir=/tmp/elasticsearch.zw6LMXqV -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=data -XX:ErrorFile=logs/hs_err_pid%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -Xloggc:logs/gc.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=32 -XX:GCLogFileSize=64m -Des.path.home=/opt/modules/elasticsearch-6.3.1 -Des.path.conf=/opt/modules/elasticsearch-6.3.1/config -Des.distribution.flavor=default -Des.distribution.type=tar -cp /opt/modules/elasticsearch-6.3.1/lib/* org.elasticsearch.bootstrap.Elasticsearch es 4317 4238 0 08:54 pts/0 00:00:00 /opt/modules/elasticsearch-6.3.1/modules/x-pack/x-pack-ml/platform/linux-x86_64/bin/controller es 4325 3987 0 08:54 pts/0 00:00:00 grep elastic [es@192 bin]$ cd /opt/modules/kibana-6.3.1-linux-x86_64/bin/ [es@192 bin]$ nohup ./kibana &amp; [2] 4384 [es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&#39; [es@192 bin]$ ps -ef|grep node es 4384 3987 77 08:55 pts/0 00:00:06 ./../node/bin/node --no-warnings ./../src/cli es 4396 3987 0 08:55 pts/0 00:00:00 grep node 重启kibana[es@192 bin]$ cd /opt/modules/kibana-6.3.1-linux-x86_64/bin/ [es@192 bin]$ nohup ./kibana &amp; [2] 4155 [es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&#39; [es@192 bin]$ ps -ef|grep node es 4155 3987 56 08:46 pts/0 00:00:04 ./../node/bin/node --no-warnings ./../src/cli es 4167 3987 0 08:46 pts/0 00:00:00 grep node [es@192 bin]$ kill -9 4155 [es@192 bin]$ ps -ef|grep node es 4237 3987 0 08:54 pts/0 00:00:00 grep node 访问es 访问kibana入分词器前 加入分词器后简易分词器 尽最大可能分词器 es集群克隆克隆一个已经安装好elastic、kibana、analysis-ik的机器 虚拟机—-快照—拍摄快照 虚拟机—管理—克隆—现有快照 修改IP修改克隆后机器102的主机名、IP地址、硬件Mac地址 参考 虚拟机配置静态ip | 小兵兵 集群配置es修改配置文件修改101机器进入/opt/modules/elasticsearch-6.3.1/config目录，修改elasticsearch.yml配置文件 # ======================== Elasticsearch Configuration ========================= # # NOTE: Elasticsearch comes with reasonable defaults for most settings. # Before you set out to tweak and tune the configuration, make sure you # understand what are you trying to accomplish and the consequences. # # The primary way of configuring a node is via this file. This template lists # the most important settings you may want to configure for a production cluster. # # Please consult the documentation for further information on configuration options: # https://www.elastic.co/guide/en/elasticsearch/reference/index.html # # ---------------------------------- Cluster ----------------------------------- # # Use a descriptive name for your cluster: # cluster.name: my-application # # ------------------------------------ Node ------------------------------------ # # Use a descriptive name for the node: # node.name: node-1 # # Add custom attributes to the node: # #node.attr.rack: r1 # # ----------------------------------- Paths ------------------------------------ # # Path to directory where to store the data (separate multiple locations by comma): # node.master: true node.data: true path.data: /opt/data # # Path to log files: # path.logs: /opt/logs # # ----------------------------------- Memory ----------------------------------- # # Lock the memory on startup: # #bootstrap.memory_lock: true # # Make sure that the heap size is set to about half the memory available # on the system and that the owner of the process is allowed to use this # limit. # # Elasticsearch performs poorly when the system is swapping the memory. # # ---------------------------------- Network ----------------------------------- # # Set the bind address to a specific IP (IPv4 or IPv6): # network.host: 192.168.1.101 # # Set a custom port for HTTP: # http.port: 9200 transport.tcp.port: 9300 # # For more information, consult the network module documentation. # # --------------------------------- Discovery ---------------------------------- # # Pass an initial list of hosts to perform discovery when new node is started: # The default list of hosts is ["127.0.0.1", "[::1]"] # discovery.zen.ping.unicast.hosts: ["192.168.1.102"] # # Prevent the "split brain" by configuring the majority of nodes (total number of master-eligible nodes / 2 + 1): # discovery.zen.minimum_master_nodes: 2 # # For more information, consult the zen discovery module documentation. # # ---------------------------------- Gateway ----------------------------------- # # Block initial recovery after a full cluster restart until N nodes are started: # #gateway.recover_after_nodes: 3 # # For more information, consult the gateway module documentation. # # ---------------------------------- Various ----------------------------------- # # Require explicit names when deleting indices: # #action.destructive_requires_name: true bootstrap.memory_lock: false bootstrap.system_call_filter: false 建立数据存储目录、日志目录 [root@192 config]# cd /opt/ [root@192 opt]# mkdir data [root@192 opt]# mkdir logs [root@192 opt]# ll total 16 drwxr-xr-x. 2 root root 4096 Jul 10 09:58 data drwxr-xr-x. 2 root root 4096 Jul 10 09:58 logs drwxr-xr-x. 4 root root 4096 Jul 9 08:42 modules drwxr-xr-x. 2 root root 4096 Mar 26 2015 rh [root@192 opt]# chown es:es -R data/ logs/ [root@192 opt]# ll total 16 drwxr-xr-x. 2 es es 4096 Jul 10 09:58 data drwxr-xr-x. 2 es es 4096 Jul 10 09:58 logs drwxr-xr-x. 4 root root 4096 Jul 9 08:42 modules drwxr-xr-x. 2 root root 4096 Mar 26 2015 rh 修改102机器进入/opt/modules/elasticsearch-6.3.1/config目录，修改elasticsearch.yml配置文件 # ======================== Elasticsearch Configuration ========================= # # NOTE: Elasticsearch comes with reasonable defaults for most settings. # Before you set out to tweak and tune the configuration, make sure you # understand what are you trying to accomplish and the consequences. # # The primary way of configuring a node is via this file. This template lists # the most important settings you may want to configure for a production cluster. # # Please consult the documentation for further information on configuration options: # https://www.elastic.co/guide/en/elasticsearch/reference/index.html # # ---------------------------------- Cluster ----------------------------------- # # Use a descriptive name for your cluster: # cluster.name: my-application # # ------------------------------------ Node ------------------------------------ # # Use a descriptive name for the node: # node.name: node-2 # # Add custom attributes to the node: # #node.attr.rack: r1 # # ----------------------------------- Paths ------------------------------------ # # Path to directory where to store the data (separate multiple locations by comma): # node.master: true node.data: true path.data: /opt/data # # Path to log files: # path.logs: /opt/logs # # ----------------------------------- Memory ----------------------------------- # # Lock the memory on startup: # #bootstrap.memory_lock: true # # Make sure that the heap size is set to about half the memory available # on the system and that the owner of the process is allowed to use this # limit. # # Elasticsearch performs poorly when the system is swapping the memory. # # ---------------------------------- Network ----------------------------------- # # Set the bind address to a specific IP (IPv4 or IPv6): # network.host: 192.168.1.102 # # Set a custom port for HTTP: # http.port: 9200 transport.tcp.port: 9300 # # For more information, consult the network module documentation. # # --------------------------------- Discovery ---------------------------------- # # Pass an initial list of hosts to perform discovery when new node is started: # The default list of hosts is ["127.0.0.1", "[::1]"] # discovery.zen.ping.unicast.hosts: ["192.168.1.101"] # # Prevent the "split brain" by configuring the majority of nodes (total number of master-eligible nodes / 2 + 1): # discovery.zen.minimum_master_nodes: 2 # # For more information, consult the zen discovery module documentation. # # ---------------------------------- Gateway ----------------------------------- # # Block initial recovery after a full cluster restart until N nodes are started: # #gateway.recover_after_nodes: 3 # # For more information, consult the gateway module documentation. # # ---------------------------------- Various ----------------------------------- # # Require explicit names when deleting indices: # #action.destructive_requires_name: true bootstrap.memory_lock: false bootstrap.system_call_filter: false 建立数据存储目录、日志目录 [root@192 config]# cd /opt/ [root@192 opt]# mkdir data [root@192 opt]# mkdir logs [root@192 opt]# ll total 16 drwxr-xr-x. 2 root root 4096 Jul 10 09:58 data drwxr-xr-x. 2 root root 4096 Jul 10 09:58 logs drwxr-xr-x. 4 root root 4096 Jul 9 08:42 modules drwxr-xr-x. 2 root root 4096 Mar 26 2015 rh [root@192 opt]# chown es:es -R data/ logs/ [root@192 opt]# ll total 16 drwxr-xr-x. 2 es es 4096 Jul 10 09:58 data drwxr-xr-x. 2 es es 4096 Jul 10 09:58 logs drwxr-xr-x. 4 root root 4096 Jul 9 08:42 modules drwxr-xr-x. 2 root root 4096 Mar 26 2015 rh 重启重启101机器[es@192 bin]$ pwd /opt/modules/elasticsearch-6.3.1/bin [es@192 bin]$ ps -ef | grep elastic es 3795 3638 0 10:08 pts/0 00:00:00 grep elastic [1]+ Killed nohup ./elasticsearch [es@192 bin]$ nohup ./elasticsearch &amp; [1] 3796 [es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&#39; [es@192 bin]$ ps -ef | grep elastic es 3796 3638 99 10:09 pts/0 00:00:07 /usr/java/jdk1.8.0_202-amd64/bin/java -Xms1g -Xmx1g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -Xss1m -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djna.nosys=true -XX:-OmitStackTraceInFastThrow -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Djava.io.tmpdir=/tmp/elasticsearch.wZB2cw0p -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=data -XX:ErrorFile=logs/hs_err_pid%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -Xloggc:logs/gc.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=32 -XX:GCLogFileSize=64m -Des.path.home=/opt/modules/elasticsearch-6.3.1 -Des.path.conf=/opt/modules/elasticsearch-6.3.1/config -Des.distribution.flavor=default -Des.distribution.type=tar -cp /opt/modules/elasticsearch-6.3.1/lib/* org.elasticsearch.bootstrap.Elasticsearch es 3875 3796 0 10:09 pts/0 00:00:00 /opt/modules/elasticsearch-6.3.1/modules/x-pack/x-pack-ml/platform/linux-x86_64/bin/controller es 3881 3638 0 10:09 pts/0 00:00:00 grep elastic 重启102机器[es@192 bin]$ pwd /opt/modules/elasticsearch-6.3.1/bin [es@192 bin]$ ps -ef|grep elastic es 4284 3992 0 10:10 pts/1 00:00:00 grep elastic [es@192 bin]$ nohup ./elasticsearch &amp; [1] 4285 [es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&#39; [es@192 bin]$ ps -ef|grep elastic es 4285 3992 99 10:10 pts/1 00:00:04 /usr/java/jdk1.8.0_202-amd64/bin/java -Xms1g -Xmx1g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -Xss1m -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djna.nosys=true -XX:-OmitStackTraceInFastThrow -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Djava.io.tmpdir=/tmp/elasticsearch.JmqOtV9r -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=data -XX:ErrorFile=logs/hs_err_pid%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -Xloggc:logs/gc.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=32 -XX:GCLogFileSize=64m -Des.path.home=/opt/modules/elasticsearch-6.3.1 -Des.path.conf=/opt/modules/elasticsearch-6.3.1/config -Des.distribution.flavor=default -Des.distribution.type=tar -cp /opt/modules/elasticsearch-6.3.1/lib/* org.elasticsearch.bootstrap.Elasticsearch es 4364 4285 0 10:10 pts/1 00:00:00 /opt/modules/elasticsearch-6.3.1/modules/x-pack/x-pack-ml/platform/linux-x86_64/bin/controller es 4370 3992 0 10:10 pts/1 00:00:00 grep elastic [es@192 bin]$ ll 访问访问101机器 访问102机器 集群管理工具cerebro插件【head,bigdesk,cerebro[kopf]】安装 下载Releases · lmenezes/cerebro 上传、解压 [root@192 modules]# cd /opt/ [root@192 opt]# mkdir soft [root@192 opt]# ll total 20 drwxr-xr-x. 3 es es 4096 Jul 10 10:01 data drwxr-xr-x. 2 es es 4096 Jul 10 10:01 logs drwxr-xr-x. 4 root root 4096 Jul 10 10:23 modules drwxr-xr-x. 2 root root 4096 Mar 26 2015 rh drwxr-xr-x. 2 root root 4096 Jul 10 10:25 soft [root@192 opt]# cd /opt/modules/ [root@192 modules]# ll total 581928 -rw-r--r--. 1 root root 52397010 Jul 10 10:23 cerebro-0.8.3.tgz drwxr-xr-x. 9 es es 4096 Jul 9 17:16 elasticsearch-6.3.1 -rw-r--r--. 1 root root 91429350 Jul 8 08:42 elasticsearch-6.3.1.tar.gz -rwxrwxrwx. 1 root root 178418154 Jul 7 21:08 jdk-8u202-linux-x64.rpm drwxrwxr-x. 11 es es 4096 Jun 30 2018 kibana-6.3.1-linux-x86_64 -rw-r--r--. 1 root root 205397076 Jul 8 08:42 kibana-6.3.1-linux-x86_64.tar.gz -rw-r--r--. 1 root root 17855952 Jun 8 20:04 MySQL-client-5.5.48-1.linux2.6.x86_64.rpm -rw-r--r--. 1 root root 50372369 Jun 8 20:24 MySQL-server-5.5.48-1.linux2.6.x86_64.rpm [root@192 modules]# tar -zxvf cerebro-0.8.3.tgz -C /opt/soft/ 启动[root@192 modules]# cd /opt/soft/ [root@192 soft]# ll total 4 drwxr-xr-x. 5 503 games 4096 Apr 5 16:48 cerebro-0.8.3 [root@192 soft]# cd cerebro-0.8.3/ [root@192 cerebro-0.8.3]# cd bin/ [root@192 bin]# ll total 20 -rwxr-xr-x. 1 503 games 9497 Apr 5 16:48 cerebro -rwxr-xr-x. 1 503 games 4970 Apr 5 16:48 cerebro.bat [root@192 bin]# nohup ./cerebro &amp; [1] 4030 [root@192 bin]# nohup: ignoring input and appending output to `nohup.out&#39;访问 测试建立一条数据 启动kibana，访问添加数据 [root@192 modules]# cd /opt/modules/kibana-6.3.1-linux-x86_64/bin/ [root@192 bin]# ll total 948 -rwxr-xr-x. 1 es es 632 Jun 30 2018 kibana -rwxr-xr-x. 1 es es 588 Jun 30 2018 kibana-keystore -rwxr-xr-x. 1 es es 639 Jun 30 2018 kibana-plugin -rw-------. 1 es es 952696 Jul 10 09:17 nohup.out [root@192 bin]# su es [es@192 bin]$ nohup ./kibana &amp; [1] 4434 [es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&#39; cerebro管理工具查看]]></content>
      <categories>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[压力测试工具ab]]></title>
    <url>%2F2019%2F07%2F06%2Fya-li-ce-shi-gong-ju-ab%2F</url>
    <content type="text"><![CDATA[压力测试工具ab下载Apache Haus Downloads 解压 测试-c代表并发数 -n代表请求总次数 C:\Users\shenlibing\Downloads\httpd-2.4.34-o102o-x64-vc14\Apache24\bin&gt;ab -n 1000 -c 100 http://jd.com/ This is ApacheBench, Version 2.3 &lt;$Revision: 1826891 $&gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking jd.com (be patient) Completed 100 requests Completed 200 requests Completed 300 requests Completed 400 requests Completed 500 requests Completed 600 requests Completed 700 requests Completed 800 requests Completed 900 requests Completed 1000 requests Finished 1000 requests Server Software: jfe Server Hostname: jd.com Server Port: 80 Document Path: / Document Length: 165 bytes Concurrency Level: 100 Time taken for tests: 88.367 seconds Complete requests: 1000 Failed requests: 0 Non-2xx responses: 1000 Total transferred: 343000 bytes HTML transferred: 165000 bytes Requests per second: 11.32 [#/sec] (mean) Time per request: 8836.697 [ms] (mean) Time per request: 88.367 [ms] (mean, across all concurrent requests) Transfer rate: 3.79 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 51 88 178.8 59 1461 Processing: 60 8357 2879.1 7889 14700 Waiting: 60 4265 2937.5 3699 12704 Total: 121 8445 2893.0 7951 14759 Percentage of the requests served within a certain time (ms) 50% 7951 66% 9226 75% 10625 80% 11233 90% 12374 95% 13742 98% 14712 99% 14721 100% 14759 (longest request) C:\Users\shenlibing\Downloads\httpd-2.4.34-o102o-x64-vc14\Apache24\bin&gt;]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>ab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java动态代理]]></title>
    <url>%2F2019%2F07%2F03%2Fjava-dong-tai-dai-li%2F</url>
    <content type="text"><![CDATA[代理：设计模式代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理 相关的类和接口动态代理机制的主类java.lang.reflect.Proxy：这是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象 方法一该方法用于获取指定代理对象所关联的调用处理器 /** * Returns the invocation handler for the specified proxy instance. * * @param proxy the proxy instance to return the invocation handler for * @return the invocation handler for the proxy instance * @throws IllegalArgumentException if the argument is not a * proxy instance * @throws SecurityException if a security manager, &lt;em>s&lt;/em>, is present * and the caller's class loader is not the same as or an * ancestor of the class loader for the invocation handler * and invocation of {@link SecurityManager#checkPackageAccess * s.checkPackageAccess()} denies access to the invocation * handler's class. */ @CallerSensitive public static InvocationHandler getInvocationHandler(Object proxy) throws IllegalArgumentException { /* * Verify that the object is actually a proxy instance. */ if (!isProxyClass(proxy.getClass())) { throw new IllegalArgumentException("not a proxy instance"); } final Proxy p = (Proxy) proxy; final InvocationHandler ih = p.h; if (System.getSecurityManager() != null) { Class&lt;?> ihClass = ih.getClass(); Class&lt;?> caller = Reflection.getCallerClass(); if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), ihClass.getClassLoader())) { ReflectUtil.checkPackageAccess(ihClass); } } return ih; } 方法二该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象 /** * Returns the {@code java.lang.Class} object for a proxy class * given a class loader and an array of interfaces. The proxy class * will be defined by the specified class loader and will implement * all of the supplied interfaces. If any of the given interfaces * is non-public, the proxy class will be non-public. If a proxy class * for the same permutation of interfaces has already been defined by the * class loader, then the existing proxy class will be returned; otherwise, * a proxy class for those interfaces will be generated dynamically * and defined by the class loader. * * &lt;p>There are several restrictions on the parameters that may be * passed to {@code Proxy.getProxyClass}: * * &lt;ul> * &lt;li>All of the {@code Class} objects in the * {@code interfaces} array must represent interfaces, not * classes or primitive types. * * &lt;li>No two elements in the {@code interfaces} array may * refer to identical {@code Class} objects. * * &lt;li>All of the interface types must be visible by name through the * specified class loader. In other words, for class loader * {@code cl} and every interface {@code i}, the following * expression must be true: * &lt;pre> * Class.forName(i.getName(), false, cl) == i * &lt;/pre> * * &lt;li>All non-public interfaces must be in the same package; * otherwise, it would not be possible for the proxy class to * implement all of the interfaces, regardless of what package it is * defined in. * * &lt;li>For any set of member methods of the specified interfaces * that have the same signature: * &lt;ul> * &lt;li>If the return type of any of the methods is a primitive * type or void, then all of the methods must have that same * return type. * &lt;li>Otherwise, one of the methods must have a return type that * is assignable to all of the return types of the rest of the * methods. * &lt;/ul> * * &lt;li>The resulting proxy class must not exceed any limits imposed * on classes by the virtual machine. For example, the VM may limit * the number of interfaces that a class may implement to 65535; in * that case, the size of the {@code interfaces} array must not * exceed 65535. * &lt;/ul> * * &lt;p>If any of these restrictions are violated, * {@code Proxy.getProxyClass} will throw an * {@code IllegalArgumentException}. If the {@code interfaces} * array argument or any of its elements are {@code null}, a * {@code NullPointerException} will be thrown. * * &lt;p>Note that the order of the specified proxy interfaces is * significant: two requests for a proxy class with the same combination * of interfaces but in a different order will result in two distinct * proxy classes. * * @param loader the class loader to define the proxy class * @param interfaces the list of interfaces for the proxy class * to implement * @return a proxy class that is defined in the specified class loader * and that implements the specified interfaces * @throws IllegalArgumentException if any of the restrictions on the * parameters that may be passed to {@code getProxyClass} * are violated * @throws SecurityException if a security manager, &lt;em>s&lt;/em>, is present * and any of the following conditions is met: * &lt;ul> * &lt;li> the given {@code loader} is {@code null} and * the caller's class loader is not {@code null} and the * invocation of {@link SecurityManager#checkPermission * s.checkPermission} with * {@code RuntimePermission("getClassLoader")} permission * denies access.&lt;/li> * &lt;li> for each proxy interface, {@code intf}, * the caller's class loader is not the same as or an * ancestor of the class loader for {@code intf} and * invocation of {@link SecurityManager#checkPackageAccess * s.checkPackageAccess()} denies access to {@code intf}.&lt;/li> * &lt;/ul> * @throws NullPointerException if the {@code interfaces} array * argument or any of its elements are {@code null} */ @CallerSensitive public static Class&lt;?> getProxyClass(ClassLoader loader, Class&lt;?>... interfaces) throws IllegalArgumentException { final Class&lt;?>[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) { checkProxyAccess(Reflection.getCallerClass(), loader, intfs); } return getProxyClass0(loader, intfs); } 方法三该方法用于判断指定类对象是否是一个动态代理类 /** * Returns true if and only if the specified class was dynamically * generated to be a proxy class using the {@code getProxyClass} * method or the {@code newProxyInstance} method. * * &lt;p>The reliability of this method is important for the ability * to use it to make security decisions, so its implementation should * not just test if the class in question extends {@code Proxy}. * * @param cl the class to test * @return {@code true} if the class is a proxy class and * {@code false} otherwise * @throws NullPointerException if {@code cl} is {@code null} */ public static boolean isProxyClass(Class&lt;?> cl) { return Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl); } 方法四该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例 /** * Returns an instance of a proxy class for the specified interfaces * that dispatches method invocations to the specified invocation * handler. * * &lt;p>{@code Proxy.newProxyInstance} throws * {@code IllegalArgumentException} for the same reasons that * {@code Proxy.getProxyClass} does. * * @param loader the class loader to define the proxy class * @param interfaces the list of interfaces for the proxy class * to implement * @param h the invocation handler to dispatch method invocations to * @return a proxy instance with the specified invocation handler of a * proxy class that is defined by the specified class loader * and that implements the specified interfaces * @throws IllegalArgumentException if any of the restrictions on the * parameters that may be passed to {@code getProxyClass} * are violated * @throws SecurityException if a security manager, &lt;em>s&lt;/em>, is present * and any of the following conditions is met: * &lt;ul> * &lt;li> the given {@code loader} is {@code null} and * the caller's class loader is not {@code null} and the * invocation of {@link SecurityManager#checkPermission * s.checkPermission} with * {@code RuntimePermission("getClassLoader")} permission * denies access;&lt;/li> * &lt;li> for each proxy interface, {@code intf}, * the caller's class loader is not the same as or an * ancestor of the class loader for {@code intf} and * invocation of {@link SecurityManager#checkPackageAccess * s.checkPackageAccess()} denies access to {@code intf};&lt;/li> * &lt;li> any of the given proxy interfaces is non-public and the * caller class is not in the same {@linkplain Package runtime package} * as the non-public interface and the invocation of * {@link SecurityManager#checkPermission s.checkPermission} with * {@code ReflectPermission("newProxyInPackage.{package name}")} * permission denies access.&lt;/li> * &lt;/ul> * @throws NullPointerException if the {@code interfaces} array * argument or any of its elements are {@code null}, or * if the invocation handler, {@code h}, is * {@code null} */ @CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?>[] interfaces, InvocationHandler h) throws IllegalArgumentException { Objects.requireNonNull(h); final Class&lt;?>[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) { checkProxyAccess(Reflection.getCallerClass(), loader, intfs); } /* * Look up or generate the designated proxy class. */ Class&lt;?> cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try { if (sm != null) { checkNewProxyPermission(Reflection.getCallerClass(), cl); } final Constructor&lt;?> cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) { AccessController.doPrivileged(new PrivilegedAction&lt;Void>() { public Void run() { cons.setAccessible(true); return null; } }); } return cons.newInstance(new Object[]{h}); } catch (IllegalAccessException|InstantiationException e) { throw new InternalError(e.toString(), e); } catch (InvocationTargetException e) { Throwable t = e.getCause(); if (t instanceof RuntimeException) { throw (RuntimeException) t; } else { throw new InternalError(t.toString(), t); } } catch (NoSuchMethodException e) { throw new InternalError(e.toString(), e); } } 调用处理器接口java.lang.reflect.Proxy：这是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象 核心方法该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上发射执行 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; 创建动态代理版本一实现 InvocationHandler 接口通过实现 InvocationHandler 接口创建自己的调用处理器 创建动态代理类通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类 获得动态代理类的构造函数通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型 创建动态代理类实例通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入 代码// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发 // 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用 InvocationHandler handler = new InvocationHandlerImpl(..); // 通过 Proxy 为包括 Interface 接口在内的一组接口动态创建代理类的类对象 Class clazz = Proxy.getProxyClass(classLoader, new Class[] { Interface.class, ... }); // 通过反射从生成的类对象获得构造函数对象 Constructor constructor = clazz.getConstructor(new Class[] { InvocationHandler.class }); // 通过构造函数对象创建动态代理类实例 Interface Proxy = (Interface)constructor.newInstance(new Object[] { handler }); 版本二简化的动态代理对象创建过程 代码// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发 InvocationHandler handler = new InvocationHandlerImpl(..); // 通过 Proxy 直接创建动态代理类实例 Interface proxy = (Interface)Proxy.newProxyInstance( classLoader, new Class[] { Interface.class }, handler ); 使用java动态代理Demo1编写接口Advice.java package com.zbiti.proxy; import java.lang.reflect.Method; public interface Advice { void forwardMethod(Method method); void backMethod(Method method); } 编写接口实现类AdviceImpl.java package com.zbiti.proxy; import java.lang.reflect.Method; public class AdviceImpl implements Advice{ long beginTime = 0; @Override public void forwardMethod(Method method) { System.out.println("end"); beginTime = System.currentTimeMillis(); } @Override public void backMethod(Method method) { System.out.println("start"); long endTime = System.currentTimeMillis(); System.out.println(method.getName() + " running time of " + (endTime - beginTime)); } } 测试ProxyTest.java package com.zbiti.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.util.ArrayList; import java.util.Collection; public class ProxyTest { public static void main(String args[]){ //创建目标类的实例对象 ArrayList&lt;String> target = new ArrayList&lt;>(); AdviceImpl adviceImpl = new AdviceImpl(); //创建动态类 Collection proxy = (Collection) getProxy(target, adviceImpl); proxy.add("aa"); System.out.println(proxy.size()); System.out.println(proxy.getClass().getName()); } public static Object getProxy(final Object target, final Advice advice){ Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() { //动态类通过Invocation类的invoke方法调用目标类所需的方法 public Object invoke(Object proxy, Method method, Object[] args) throws Exception { advice.forwardMethod(method); Object retVal = method.invoke(target, args); advice.backMethod(method); return retVal; } } ); return proxy; } } 结果： end start add running time of 0 end start size running time of 0 1 com.sun.proxy.$Proxy0 Process finished with exit code 0Demo2手动实现一个数据库连接池, 没有使用代理模式的情况下如下： MyPool.java package com.zbiti.proxy; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.util.LinkedList; public class MyPool { // 初始化连接数目 private int init_count = 3; // 最大连接数 private int max_count = 6; // 记录当前使用连接数 private int current_count = 0; // 连接池 （存放所有的初始化连接） private LinkedList&lt;Connection> pool = new LinkedList&lt;Connection>(); //1. 构造函数中，初始化连接放入连接池 public MyPool() { // 初始化连接 for (int i = 0; i &lt; init_count; i++) { // 记录当前连接数目 current_count++; // 创建原始的连接对象 Connection con = createConnection(); // 把连接加入连接池 pool.addLast(con); } } //2. 创建一个新的连接的方法 private Connection createConnection() { try { Class.forName("com.mysql.jdbc.Driver"); // 原始的目标对象 Connection con = DriverManager.getConnection("jdbc:mysql://192.168.1.101:3306/cmj", "root", "000000"); return con; } catch (Exception e) { throw new RuntimeException(e); } } //3. 获取连接 public Connection getConnection() { // 3.1 判断连接池中是否有连接, 如果有连接，就直接从连接池取出 if (pool.size() > 0) { return pool.removeFirst(); } // 3.2 连接池中没有连接： 判断，如果没有达到最大连接数，创建； if (current_count &lt; max_count) { // 记录当前使用的连接数 current_count++; // 创建连接 return createConnection(); } // 3.3 如果当前已经达到最大连接数，抛出异常 throw new RuntimeException("当前连接已经达到最大连接数目 ！"); } //4. 释放连接 public void realeaseConnection(Connection con) { // 4.1 判断： 池的数目如果小于初始化连接，就放入池中 if (pool.size() &lt; init_count) { pool.addLast(con); } else { try { // 4.2 关闭 current_count--; con.close(); } catch (SQLException e) { throw new RuntimeException(e); } } } // 测试： public static void main(String[] args) throws SQLException { MyPool pool = new MyPool(); System.out.println("当前连接: " + pool.current_count); // 3 // 使用连接 pool.getConnection(); pool.getConnection(); Connection con4 = pool.getConnection(); Connection con3 = pool.getConnection(); Connection con2 = pool.getConnection(); Connection con1 = pool.getConnection(); // 释放连接, 连接放回连接池 // pool.realeaseConnection(con1); /* * 希望：当关闭连接的时候，要把连接放入连接池！【当调用Connection接口的close方法时候，希望触发pool.addLast(con);操作】把连接放入连接池 * 解决1：实现Connection接口，重写close方法 connection接口方法太多，都实现太麻烦，放弃 * 解决2：动态代理 */ con1.close(); // 再获取 pool.getConnection(); System.out.println("连接池：" + pool.pool.size()); // 0 System.out.println("当前连接: " + pool.current_count); // 3 } } 使用代理模式 MyPool2.java package com.zbiti.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.util.LinkedList; /** * JDK 动态代理 Object obj = Proxy.newProxyInstance(....)； * 1.参数1：ClassLoader loader ,确定类加载器。程序运行时动态创建类，需要类加载加载到内存。类加载器作用：class文件 --> Class对象 * * 一般情况使用都是当前类的类加载器 * * 类加载器获得方式：MyFactory.class.getClassLoader(); * 2.参数2：Class[] interfaces 代理需要实现的接口们（可能有多个） * * 方式1：userService.getClass().getInterfaces()【此方式只能在代理对象和接口是父子关系时使用】 * * 方式2：new Class[]{UserService.class}【当被代理对象和其实现接口之间是隔代关系时（即祖孙关系）(即:一个一个列出接口) * 3.参数3：InvocationHandler h 请求处理类，代理类方法执行时，需要请求处理类来处理。 * * 一般采用匿名内部类：new InvocationHandler(){} * * 实现方法 invoke ，代理类每一个方法执行一次，将调用一次invoke * 参数1.1：Object proxy ,代理对象（即 proxyService，不是“代理之前对象”），一般不用。 * 参数2.2：Method method ，当前执行的方法 * * 当前调用方法名：method.getName(); * * 执行目标类方法：Object obj = method.invoke(代理之前对象 , args) * 参数3.3：Object[] args * * 当前方法实际参数 */ public class MyPool2 { // 初始化连接数目 private int init_count = 3; // 最大连接数 private int max_count = 6; // 记录当前使用连接数 private int current_count = 0; // 连接池 （存放所有的初始化连接） private LinkedList&lt;Connection> pool = new LinkedList&lt;Connection>(); //1. 构造函数中，初始化连接放入连接池 public MyPool2() { // 初始化连接 for (int i=0; i&lt;init_count; i++){ // 记录当前连接数目 current_count++; // 创建原始的连接对象 Connection con = createConnection(); // 把连接加入连接池 pool.addLast(con); } } //2. 创建一个新的连接的方法 private Connection createConnection(){ try { Class.forName("com.mysql.jdbc.Driver"); // 原始的目标对象 final Connection con = DriverManager.getConnection("jdbc:mysql://192.168.1.101:3306/cmj", "root", "000000"); /**********对con对象代理**************/ // 对con创建其代理对象 Connection proxy = (Connection) Proxy.newProxyInstance( con.getClass().getClassLoader(), // 类加载器 //con.getClass().getInterfaces(), // 当目标对象是一个具体的类的时候 new Class[]{Connection.class}, // 目标对象实现的接口 new InvocationHandler() { // 当调用con对象方法的时候， 自动触发事务处理器 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 方法返回值 Object result = null; // 当前执行的方法的方法名 String methodName = method.getName(); // 判断当执行了close方法的时候，把连接放入连接池 if ("close".equals(methodName)) { System.out.println("begin:当前执行close方法开始！"); // 连接放入连接池 pool.addLast(con); System.out.println("end: 当前连接已经放入连接池了！"); } else { // 调用目标对象方法，注意这里不是代理对象 result = method.invoke(con, args); } return result; } } ); return proxy; } catch (Exception e) { throw new RuntimeException(e); } } //3. 获取连接 public Connection getConnection(){ // 3.1 判断连接池中是否有连接, 如果有连接，就直接从连接池取出 if (pool.size() > 0){ return pool.removeFirst(); } // 3.2 连接池中没有连接： 判断，如果没有达到最大连接数，创建； if (current_count &lt; max_count) { // 记录当前使用的连接数 current_count++; // 创建连接 return createConnection(); } // 3.3 如果当前已经达到最大连接数，抛出异常 throw new RuntimeException("当前连接已经达到最大连接数目 ！"); } //4. 释放连接 public void realeaseConnection(Connection con) { // 4.1 判断： 池的数目如果小于初始化连接，就放入池中 if (pool.size() &lt; init_count){ pool.addLast(con); } else { try { // 4.2 关闭 current_count--; con.close(); } catch (SQLException e) { throw new RuntimeException(e); } } } // 测试： public static void main(String[] args) throws SQLException { MyPool2 pool = new MyPool2(); System.out.println("当前连接: " + pool.current_count); // 3 // 使用连接 pool.getConnection(); pool.getConnection(); Connection con4 = pool.getConnection(); Connection con3 = pool.getConnection(); Connection con2 = pool.getConnection(); Connection con1 = pool.getConnection(); // 释放连接, 连接放回连接池 // pool.realeaseConnection(con1); /* * 希望：当关闭连接的时候，要把连接放入连接池！【当调用Connection接口的close方法时候，希望触发pool.addLast(con);操作】把连接放入连接池 * 解决1：实现Connection接口，重写close方法 * 解决2：动态代理 */ con1.close(); // 再获取 pool.getConnection(); System.out.println("连接池：" + pool.pool.size()); // 0 System.out.println("当前连接: " + pool.current_count); // 3 } } 参考Java 动态代理机制分析及扩展，第 1 部分 Java基础学习(4)——动态代理 - 王泽远的博客 | Crow’s Blog]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringData]]></title>
    <url>%2F2019%2F06%2F15%2Fspringdata%2F</url>
    <content type="text"><![CDATA[涉及技术介绍HibernateYour relational data. Objectively. - Hibernate ORM Object/Relational MappingHibernate ORM enables developers to more easily write applications whose data outlives the application process. As an Object/Relational Mapping (ORM) framework, Hibernate is concerned with data persistence as it applies to relational databases (via JDBC). Unfamiliar with the notion of ORM? Read here. JPA ProviderIn addition to its own “native” API, Hibernate is also an implementation of the Java Persistence API (JPA) specification. As such, it can be easily used in any environment supporting JPA including Java SE applications, Java EE application servers, Enterprise OSGi containers, etc. Idiomatic persistenceHibernate enables you to develop persistent classes following natural Object-oriented idioms including inheritance, polymorphism, association, composition, and the Java collections framework. Hibernate requires no interfaces or base classes for persistent classes and enables any class or data structure to be persistent. High PerformanceHibernate supports lazy initialization, numerous fetching strategies and optimistic locking with automatic versioning and time stamping. Hibernate requires no special database tables or fields and generates much of the SQL at system initialization time instead of at runtime. Hibernate consistently offers superior performance over straight JDBC code, both in terms of developer productivity and runtime performance. ScalabilityHibernate was designed to work in an application server cluster and deliver a highly scalable architecture. Hibernate scales well in any environment: Use it to drive your in-house Intranet that serves hundreds of users or for mission-critical applications that serve hundreds of thousands. ReliableHibernate is well known for its excellent stability and quality, proven by the acceptance and use by tens of thousands of Java developers. ExtensibilityHibernate is highly configurable and extensible. JPA 标准Java Persistence API - Wikipedia The Java Persistence API (JPA) is a Java application programming interface specification that describes the management of relational data in applications using Java Platform, Standard Edition and Java Platform, Enterprise Edition. Persistence in this context covers three areas: the API itself, defined in the javax.persistence package the Java Persistence Query Language (JPQL) object/relational metadata Hibernate JPAHibernate 在3.2 以后根据JPA 规范提供了一套操作持久层的 API Spring DataSpring Data Spring Data’s mission is to provide a familiar and consistent, Spring-based programming model for data access while still retaining the special traits of the underlying data store. It makes it easy to use data access technologies, relational and non-relational databases, map-reduce frameworks, and cloud-based data services. This is an umbrella project which contains many subprojects that are specific to a given database. The projects are developed by working together with many of the companies and developers that are behind these exciting technologies. Spring Data JPASpring Data JPA Spring Data JPA, part of the larger Spring Data family, makes it easy to easily implement JPA based repositories. This module deals with enhanced support for JPA based data access layers. It makes it easier to build Spring-powered applications that use data access technologies. Implementing a data access layer of an application has been cumbersome for quite a while. Too much boilerplate code has to be written to execute simple queries as well as perform pagination, and auditing. Spring Data JPA aims to significantly improve the implementation of data access layers by reducing the effort to the amount that’s actually needed. As a developer you write your repository interfaces, including custom finder methods, and Spring will provide the implementation automatically. Spring Data RedisSpring Data Redis Spring Data Redis, part of the larger Spring Data family, provides easy configuration and access to Redis from Spring applications. It offers both low-level and high-level abstractions for interacting with the store, freeing the user from infrastructural concerns. Spring 整合 Hibernate导入jar包spring jar包spring-iocspring-beans-4.2.0.RELEASE.jar spring-context-4.2.0.RELEASE.jar spring-core-4.2.0.RELEASE.jar spring-expression-4.2.0.RELEASE.jar spring-aopaopalliance.jar aspectjrt.jar aspectjweaver.jar spring-aop-4.2.0.RELEASE.jar spring-aspects-4.2.0.RELEASE.jar spring-jdbcspring-jdbc-4.2.0.RELEASE.jar spring-tx-4.2.0.RELEASE.jar spring-ormspring-orm-4.2.0.RELEASE.jar spring-testspring-test-4.2.0.RELEASE.jar apache-loggingcommons-logging-1.1.1.jar hibernate jar包hibernate-coreantlr-2.7.7.jar dom4j-1.6.1.jar geronimo-jta_1.1_spec-1.1.1.jar hibernate-commons-annotations-5.0.1.Final.jar hibernate-core-5.0.7.Final.jar hibernate-jpa-2.1-api-1.0.0.Final.jar jandex-2.0.0.Final.jar javassist-3.18.1-GA.jar jboss-logging-3.3.0.Final.jar mysqql-drivermysql-connector-java-5.1.7-bin.jar c3p0连接池c3p0-0.9.2.1.jar hibernate-c3p0-5.0.7.Final.jar mchange-commons-java-0.2.3.4.jar spring整合hibernate编写配置文件 配置读取properties文件的工具类 配置c3p0数据库连接池 配置Hibernate的SeesionFactory 配置Hibernate的事务管理器 配置开启注解事务处理 配置springIOC的注解扫描 applicationContext.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"> &lt;!-- 配置读取properties文件的工具类 --> &lt;context:property-placeholder location="classpath:jdbc.properties"/> &lt;!-- 配置c3p0数据库连接池 --> &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"> &lt;property name="jdbcUrl" value="${jdbc.url}"/> &lt;property name="driverClass" value="${jdbc.driver.class}"/> &lt;property name="user" value="${jdbc.username}"/> &lt;property name="password" value="${jdbc.password}"/> &lt;/bean> &lt;!-- 配置Hibernate的SeesionFactory --> &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"> &lt;property name="dataSource" ref="dataSource"/> &lt;!-- hibernateProperties属性：配置与hibernate相关的内容，如显示sql语句，开启正向工程 --> &lt;property name="hibernateProperties"> &lt;props> &lt;!-- 显示当前执行的sql语句 --> &lt;prop key="hibernate.show_sql">true&lt;/prop> &lt;!-- 开启正向工程 --> &lt;prop key="hibernate.hbm2ddl.auto">update&lt;/prop> &lt;/props> &lt;/property> &lt;!-- 扫描实体所在的包 --> &lt;property name="packagesToScan"> &lt;list> &lt;value>com.bjsxt.pojo&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;!-- 配置Hibernate的事务管理器 --> &lt;bean id="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"> &lt;property name="sessionFactory" ref="sessionFactory"/> &lt;/bean> &lt;!-- 配置开启注解事务处理 --> &lt;tx:annotation-driven transaction-manager="transactionManager"/> &lt;!-- 配置springIOC的注解扫描 --> &lt;context:component-scan base-package="com.bjsxt"/> &lt;/beans> hibernate完成CRUD创建数据库 编写实体类Users.java package com.bjsxt.pojo; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name="t_users") public class Users implements Serializable{ @Id @GeneratedValue(strategy=GenerationType.IDENTITY)//strategy=GenerationType.IDENTITY 自增长 @Column(name="userid") private Integer userid; @Column(name="username") private String username; @Column(name="userage") private Integer userage; public Integer getUserid() { return userid; } public void setUserid(Integer userid) { this.userid = userid; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Integer getUserage() { return userage; } public void setUserage(Integer userage) { this.userage = userage; } @Override public String toString() { return "Users [userid=" + userid + ", username=" + username + ", userage=" + userage + "]"; } } 修改配置文件添加 HibernateTemplate，修改applicationContext.xml配置文件 &lt;!-- 配置HiberanteTemplate对象 --> &lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate5.HibernateTemplate"> &lt;property name="sessionFactory" ref="sessionFactory"/> &lt;/bean> 编写接口UsersDao.java package com.bjsxt.dao; import java.util.List; import com.bjsxt.pojo.Users; public interface UsersDao { void insertUsers(Users users); void updateUsers(Users users); void deleteUsers(Users users); Users selectUsersById(Integer userid); } 编写实现类UsersDaoImpl.java package com.bjsxt.dao.impl; import java.util.List; import org.hibernate.Query; import org.hibernate.Session; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.orm.hibernate5.HibernateTemplate; import org.springframework.stereotype.Repository; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; @Repository public class UsersDaoImpl implements UsersDao { @Autowired private HibernateTemplate hibernateTemplate; @Override public void insertUsers(Users users) { this.hibernateTemplate.save(users); } @Override public void updateUsers(Users users) { this.hibernateTemplate.update(users); } @Override public void deleteUsers(Users users) { this.hibernateTemplate.delete(users); } @Override public Users selectUsersById(Integer userid) { return this.hibernateTemplate.get(Users.class, userid); } } 编写测试代码UsersDaoImplTest.java package com.bjsxt.test; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class UsersDaoImplTest { @Autowired private UsersDao usersDao; /** * 添加用户 */ @Test @Transactional// 在测试类对于事务提交方式默认的是回滚。 @Rollback(false)//取消自动回滚 public void testInsertUsers(){ Users users = new Users(); users.setUserage(20); users.setUsername("张三"); this.usersDao.insertUsers(users); } /** * 更新用户 */ @Test @Transactional @Rollback(false) public void testUpdateUsers(){ Users users = new Users(); users.setUserid(2); users.setUserage(22); users.setUsername("李四"); this.usersDao.updateUsers(users); } /** * 根据userid查询用户 */ @Test public void testSelectUsersById(){ Users users = this.usersDao.selectUsersById(2); System.out.println(users); } /** * 删除用户 */ @Test @Transactional @Rollback(false) public void testDeleteUsers(){ Users users = new Users(); users.setUserid(2); this.usersDao.deleteUsers(users); } } HQL查询HQL：Hibernate Query LanguageHQL的语法：就是将原来的 sql语句中的表与字段名称换成对象与属性的名称就可以了 修改接口添加查询方法 List&lt;Users> selectUserByName(String username); 修改实现类实现查询方法 @Override public List&lt;Users> selectUserByName(String username) { //getCurrentSession:当前session必须要有事务边界，且只能处理唯一的一个事务。当事务提交或者回滚后session自动失效 //openSession:每次都会打开一个新的session.加入每次使用多次。则获得的是不同session对象。使用完毕后我们需要手动的调用colse方法关闭session Session session = this.hibernateTemplate.getSessionFactory().getCurrentSession(); //sql:select * from t_users where username = Query query = session.createQuery("from Users where username = :abc"); Query queryTemp = query.setString("abc",username); return queryTemp.list(); } 编写测试代码测试HQL查询 /** * HQL测试 */ @Test @Transactional public void testSelectUserByName(){ List&lt;Users> list = this.usersDao.selectUserByName("张三"); for (Users users : list) { System.out.println(users); } } SQL查询修改接口添加查询方法 List&lt;Users> selectUserByNameUseSQL(String username); 修改实现类实现查询方法 @Override public List&lt;Users> selectUserByNameUseSQL(String username) { Session session = this.hibernateTemplate.getSessionFactory().getCurrentSession(); Query query = session.createSQLQuery("select * from t_users where username = ?").addEntity(Users.class).setString(0, username); return query.list(); } 编写测试代码测试SQL查询 /** * SQL测试 */ @Test @Transactional public void testSelectUserByNameUseSQL(){ List&lt;Users> list = this.usersDao.selectUserByNameUseSQL("张三"); for (Users users : list) { System.out.println(users); } } QBC查询QBC：Query By Criteria 修改接口添加查询方法 List&lt;Users> selectUserByNameUseCriteria(String username); 修改实现类实现接口查询方法 @Override public List&lt;Users> selectUserByNameUseCriteria(String username) { Session session = this.hibernateTemplate.getSessionFactory().getCurrentSession(); //sql:select * from t_users where username = 张三 Criteria c = session.createCriteria(Users.class); c.add(Restrictions.eq("username", username)); return c.list(); } 编写测试代码测试QBC查询 /** * Criteria测试 */ @Test @Transactional public void testSelectUserByNameUseCriteria(){ List&lt;Users> list = this.usersDao.selectUserByNameUseCriteria("张三"); for (Users users : list) { System.out.println(users); } } Spring整合Hibernate JPAJPA：由 Sun公司提供了一对对于持久层操作的标准(接口+文档)Hibernate:是 Gavin King开发的一套对于持久层操作的自动的ORM框架。Hibernate JPA:是在Hibernate3.2版本那种提供了对于 JPA的标准的实现。提供了一套按照 JPA 标准来实现持久层开发的 API 导入jar包在项目中导入 HIbernateJPA相关的 jar hibernate-entitymanager-5.0.7.Final.jar 修改配置文件修改applicationContext.xml配置文件 配置读取properties文件的工具类 配置c3p0数据库连接池 Spring整合JPA 配置EntityManagerFactory 配置jpa的事务管理器 配置开启注解事务处理 配置springIOC的注解扫描 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"> &lt;!-- 配置读取properties文件的工具类 --> &lt;context:property-placeholder location="classpath:jdbc.properties"/> &lt;!-- 配置c3p0数据库连接池 --> &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"> &lt;property name="jdbcUrl" value="${jdbc.url}"/> &lt;property name="driverClass" value="${jdbc.driver.class}"/> &lt;property name="user" value="${jdbc.username}"/> &lt;property name="password" value="${jdbc.password}"/> &lt;/bean> &lt;!-- Spring整合JPA 配置EntityManagerFactory--> &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"> &lt;property name="dataSource" ref="dataSource"/> &lt;property name="jpaVedorAdapter"> &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"> &lt;!-- hibernate相关的属性的注入 --> &lt;!-- 配置数据库类型 --> &lt;property name="database" value="MYSQL"/> &lt;!-- 正向工程 自动创建表 --> &lt;property name="generateDdl" value="true"/> &lt;!-- 显示执行的SQL --> &lt;property name="showSql" value="true"/> &lt;/bean> &lt;/property> &lt;!-- 扫描实体的包 --> &lt;property name="packagesToScan"> &lt;list> &lt;value>com.bjsxt.pojo&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;!-- 配置jpa的事务管理器 --> &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"> &lt;property name="entityManagerFactory" ref="entityManagerFactory"/> &lt;/bean> &lt;!-- 配置开启注解事务处理 --> &lt;tx:annotation-driven transaction-manager="transactionManager"/> &lt;!-- 配置springIOC的注解扫描 --> &lt;context:component-scan base-package="com.bjsxt"/> &lt;/beans> Hibernate JPA的CRUD编写实体类Users.java package com.bjsxt.pojo; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name="t_users") public class Users implements Serializable{ @Id @GeneratedValue(strategy=GenerationType.IDENTITY)//strategy=GenerationType.IDENTITY 自增长 @Column(name="userid") private Integer userid; @Column(name="username") private String username; @Column(name="userage") private Integer userage; public Integer getUserid() { return userid; } public void setUserid(Integer userid) { this.userid = userid; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Integer getUserage() { return userage; } public void setUserage(Integer userage) { this.userage = userage; } @Override public String toString() { return "Users [userid=" + userid + ", username=" + username + ", userage=" + userage + "]"; } } 编写接口UsersDao.java package com.bjsxt.dao; import java.util.List; import com.bjsxt.pojo.Users; public interface UsersDao { void insertUsers(Users users); void updateUsers(Users users); void deleteUsers(Users users); Users selectUsersById(Integer userid); } 编写实现类UsersDaoImpl.java package com.bjsxt.dao.impl; import java.util.List; import javax.persistence.EntityManager; import javax.persistence.PersistenceContext; import org.hibernate.Criteria; import org.hibernate.Query; import org.hibernate.Session; import org.hibernate.criterion.Restrictions; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.orm.hibernate5.HibernateTemplate; import org.springframework.stereotype.Repository; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; @Repository public class UsersDaoImpl implements UsersDao { @PersistenceContext(name="entityManagerFactory") private EntityManager entityManager; @Override public void insertUsers(Users users) { this.entityManager.persist(users); } @Override public void updateUsers(Users users) { this.entityManager.merge(users); } @Override public void deleteUsers(Users users) { Users u = this.selectUsersById(users.getUserid()); this.entityManager.remove(u); } @Override public Users selectUsersById(Integer userid) { return this.entityManager.find(Users.class, userid); } } 编写测试代码UsersDaoImplTest.java package com.bjsxt.test; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class UsersDaoImplTest { @Autowired private UsersDao usersDao; /** * 添加用户 */ @Test @Transactional// 在测试类对于事务提交方式默认的是回滚。 @Rollback(false)//取消自动回滚 public void testInsertUsers(){ Users users = new Users(); users.setUserage(24); users.setUsername("王小丽"); this.usersDao.insertUsers(users); } /** * 更新用户 */ @Test @Transactional @Rollback(false) public void testUpdateUsers(){ Users users = new Users(); users.setUserid(5); users.setUserage(22); users.setUsername("王五"); this.usersDao.updateUsers(users); } /** * 根据userid查询用户 */ @Test public void testSelectUsersById(){ Users users = this.usersDao.selectUsersById(4); System.out.println(users); } /** * 删除用户 */ @Test @Transactional @Rollback(false) public void testDeleteUsers(){ Users users = new Users(); users.setUserid(4); this.usersDao.deleteUsers(users); } } HQL查询修改接口添加HQL查询方法 List&lt;Users> selectUserByName(String username); 修改实现类实现HQL查询接口方法 @Override public List&lt;Users> selectUserByName(String username) { return this.entityManager.createQuery(" from Users where username = :abc").setParameter("abc", username).getResultList(); } 修改测试代码测试HQL查询 /** * HQL测试 */ @Test @Transactional public void testSelectUserByName(){ List&lt;Users> list = this.usersDao.selectUserByName("王五"); for (Users users : list) { System.out.println(users); } } SQL查询修改接口添加SQL查询方法 List&lt;Users> selectUserByNameUseSQL(String username); 修改实现类实现SQL查询接口方法 @Override public List&lt;Users> selectUserByNameUseSQL(String username) { //在Hibernate JPA中 如果通过？方式来帮顶参数，那么他的查数是从1开始的。而hibernate中是从0开始的。 return this.entityManager.createNativeQuery("select * from t_users where username = ?", Users.class).setParameter(1, username).getResultList(); } 修改测试代码测试SQL查询 /** * SQL测试 */ @Test @Transactional public void testSelectUserByNameUseSQL(){ List&lt;Users> list = this.usersDao.selectUserByNameUseSQL("王五"); for (Users users : list) { System.out.println(users); } } QBC查询修改接口添加QBC查询方法 List&lt;Users> selectUserByNameUseCriteria(String username); 修改实现类实现QBC查询接口方法 @Override public List&lt;Users> selectUserByNameUseCriteria(String username) { //CriteriaBuilder对象：创建一个CriteriaQuery,创建查询条件。 CriteriaBuilder builber = this.entityManager.getCriteriaBuilder(); //CriteriaQuery对象：执行查询的Criteria对象 //select * from t_users CriteriaQuery&lt;Users> query = builber.createQuery(Users.class); //获取要查询的实体类的对象 Root&lt;Users> root = query.from(Users.class); //封装查询条件 Predicate cate = builber.equal(root.get("username"), username); //select * from t_users where username = 张三 query.where(cate); //执行查询 TypedQuery&lt;Users> typeQuery = this.entityManager.createQuery(query); return typeQuery.getResultList(); } 修改测试代码测试QBC查询 /** * Criteria测试 */ @Test @Transactional public void testSelectUserByNameUseCriteria(){ List&lt;Users> list = this.usersDao.selectUserByNameUseCriteria("王五"); for (Users users : list) { System.out.println(users); } } Spring Data JPASpring Data JPA：Spring Data JPA 是spring data项目下的一个模块。提供了一套基于JPA标准操作数据库的简化方案。底层默认的是依赖 Hibernate JPA来实现的。Spring Data JPA的技术特点：我们只需要定义接口并集成Spring Data JPA中所提供的接口就可以了。不需要编写接口实现类。 入门导入jar包在spring整合hibernate、hibernate JPA的基础jar包上添加 spring-data-commons-1.11.0.RELEASE.jar spring-data-jpa-1.9.0.RELEASE.jar slf4j-api-1.6.1.jar slf4j-log4j12-1.7.2.jar log4j-1.2.16.jar 修改配置文件 JPA命名空间xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot; Spring Data JPA 的配置&lt;jpa:repositories base-package=&quot;com.bjsxt.dao&quot;/&gt; &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jpa="http://www.springframework.org/schema/data/jpa" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"> &lt;!-- 配置读取properties文件的工具类 --> &lt;context:property-placeholder location="classpath:jdbc.properties"/> &lt;!-- 配置c3p0数据库连接池 --> &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"> &lt;property name="jdbcUrl" value="${jdbc.url}"/> &lt;property name="driverClass" value="${jdbc.driver.class}"/> &lt;property name="user" value="${jdbc.username}"/> &lt;property name="password" value="${jdbc.password}"/> &lt;/bean> &lt;!-- Spring整合JPA 配置EntityManagerFactory--> &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"> &lt;property name="dataSource" ref="dataSource"/> &lt;property name="jpaVendorAdapter"> &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"> &lt;!-- hibernate相关的属性的注入 --> &lt;!-- 配置数据库类型 --> &lt;property name="database" value="MYSQL"/> &lt;!-- 正向工程 自动创建表 --> &lt;property name="generateDdl" value="true"/> &lt;!-- 显示执行的SQL --> &lt;property name="showSql" value="true"/> &lt;/bean> &lt;/property> &lt;!-- 扫描实体的包 --> &lt;property name="packagesToScan"> &lt;list> &lt;value>com.bjsxt.pojo&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;!-- 配置Hibernate的事务管理器 --> &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"> &lt;property name="entityManagerFactory" ref="entityManagerFactory"/> &lt;/bean> &lt;!-- 配置开启注解事务处理 --> &lt;tx:annotation-driven transaction-manager="transactionManager"/> &lt;!-- 配置springIOC的注解扫描 --> &lt;context:component-scan base-package="com.bjsxt"/> &lt;!-- Spring Data JPA 的配置 --> &lt;!-- base-package：扫描dao接口所在的包 --> &lt;jpa:repositories base-package="com.bjsxt.dao"/> &lt;/beans> 编写DAOpackage com.bjsxt.dao; import org.springframework.data.jpa.repository.JpaRepository; import com.bjsxt.pojo.Users; public interface UsersDao extends JpaRepository&lt;Users, Integer> { } 编写测试代码 JUnit单元测试，事务默认是回滚的 package com.bjsxt.test; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class UsersDaoImplTest { @Autowired private UsersDao usersDao; /** * 添加用户 */ @Test @Transactional// 在测试类对于事务提交方式默认的是回滚。 @Rollback(false)//取消自动回滚 public void testInsertUsers(){ Users users = new Users(); users.setUserage(24); users.setUsername("张三"); this.usersDao.save(users); } } 接口继承结构 运行原理 入门编写测试代码时，我们注入了接口UsersDao,自己并没有实现save但是可以直接调用，实际上通过工厂对象JpaRepositoryFactory帮我们生成了代理对象 @PersistenceContext(name="entityManagerFactory") private EntityManager em; @Test public void test1(){ //org.springframework.data.jpa.repository.support.SimpleJpaRepository@fba8bf //System.out.println(this.usersDao); //class com.sun.proxy.$Proxy29 代理对象 是基于 JDK 的动态代理方式创建的 //System.out.println(this.usersDao.getClass()); JpaRepositoryFactory factory = new JpaRepositoryFactory(em); //getRepository(UsersDao.class);可以帮助我们为接口生成实现类。而这个实现类是 SimpleJpaRepository 的对象 //要求：该接口必须要是继承 Repository 接口 UsersDao ud = factory.getRepository(UsersDao.class); System.out.println(ud); System.out.println(ud.getClass()); } Repository接口Repository 接口是 Spring Data JPA 中为我我们提供的所有接口中的顶层接口Repository提供了两种查询方式的支持 基于方法名称命名规则查询 基于@Query 注解查询 方法名称命名规则查询 规则：findBy(关键字)+属性名称(属性名称的首字母大写)+查询条件(首字母大写) 关键字 方法命名 sql where 子句 And findByNameAndPwd where name= ? and pwd =? Or findByNameOrSex where name= ? or sex=? Is,Equal findById,findByIdEquals where id= ? Between findByIdBetween where id between ? and ? LessThan findByIdLessThan where id &lt; ? LessThanEqual findByIdLessThanEquals where id &lt;= ? GreaterThan findByIdGreaterThan where id &gt; ? GreaterThanEqual findByIdGreaterThanEquals where id &gt; = ? After findByIdAfter where id &gt; ? Before findByIdBefore where id &lt; ? IsNull findByNameIsNull where name is null isNotNull,NotNull findByNameNotNull where name is not null Like findByNameLike whre name like ? NotLike findByNameNotLike where name not like ? StartingWith findByNameStartingWith where name like ‘?%’ EndingWith findByNameEndingWith where name like ‘%?’ Containing findByNameContaining where name like ‘%?%’ OrderBy findByIdOrderByXDesc where id=? order by x desc Not findByNameNot where name &lt;&gt; ? In findByIdIn(Collection&lt;?&gt; c) where id in (?) NotIn findByIdNotIn(Collection&lt;?&gt; c) where id not in (?) True findByAaaTue where aaa = true False findByAaaFalse where aaa = false IgnoreCase findByNameIgnoreCase where UPPER(name)=UPPER(?) 编写接口 UsersDao.java package com.bjsxt.dao; import java.util.List; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.repository.Repository; import com.bjsxt.pojo.Users; /** * Repository接口讲解 * @author Administrator * */ public interface UsersDao extends Repository&lt;Users, Integer> { List&lt;Users> findByUsernameIs(String string); List&lt;Users> findByUsernameLike(String string); List&lt;Users> findByUsernameAndUserageGreaterThanEqual(String name,Integer age); } 编写测试类 RepositoryTest.java package com.bjsxt.test; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * Repository接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 需求：使用用户名作为查询条件 */ @Test public void test1(){ /** * 判断相等的条件，有三种表示方式 * 1,什么都不写，默认的就是做相等判断 * 2,Is * 3,Equal */ List&lt;Users> list = this.usersDao.findByUsernameIs("王五"); for (Users users : list) { System.out.println(users); } } /** * 需求：根据用户姓名做Like处理 * Like:条件关键字 */ @Test public void test2(){ List&lt;Users> list = this.usersDao.findByUsernameLike("王%"); for (Users users : list) { System.out.println(users); } } /** * 需求：查询名称为王五，并且他的年龄大于等于22岁 */ @Test public void test3(){ List&lt;Users> list = this.usersDao.findByUsernameAndUserageGreaterThanEqual("王五", 22); for (Users users : list) { System.out.println(users); } } } @Query 注解的查询JPQL语句查询JPQL：通过 Hibernate 的HQL演变过来的。他和 HQL语法及其相似 编写接口 @Query(value=&quot;from Users where username = ?&quot;)—&gt;表：实体对象，字段：属性 UsersDao.java package com.bjsxt.dao; import java.util.List; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.Repository; import com.bjsxt.pojo.Users; /** * Repository接口讲解 * @author Administrator * */ public interface UsersDao extends Repository&lt;Users, Integer> { //使用@Query注解查询 @Query(value="from Users where username = ?") List&lt;Users> queryUserByNameUseJPQL(String name); @Query("from Users where username like ?") List&lt;Users> queryUserByLikeNameUseJPQL(String name); @Query("from Users where username = ? and userage >= ?") List&lt;Users> queryUserByNameAndAge(String name,Integer age); } 编写测试类RepositoryTest.java package com.bjsxt.test; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * Repository接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 测试@Query查询 JPQL */ @Test public void test4(){ List&lt;Users> list = this.usersDao.queryUserByNameUseJPQL("王五"); for (Users users : list) { System.out.println(users); } } /** * 测试@Query查询 JPQL */ @Test public void test5(){ List&lt;Users> list = this.usersDao.queryUserByLikeNameUseJPQL("王%"); for (Users users : list) { System.out.println(users); } } /** * 测试@Query查询 JPQL */ @Test public void test6(){ List&lt;Users> list = this.usersDao.queryUserByNameAndAge("王五", 22); for (Users users : list) { System.out.println(users); } } } SQL语句查询 原生SQL书写方式，nativeQuery=true表示不转义SQL 编写接口UsersDao.java package com.bjsxt.dao; import java.util.List; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.Repository; import com.bjsxt.pojo.Users; /** * Repository接口讲解 * @author Administrator * */ public interface UsersDao extends Repository&lt;Users, Integer> { //使用@Query注解查询SQL //nativeQuery:默认的是false.表示不开启sql查询。是否对value中的语句做转义。 @Query(value="select * from t_users where username = ?",nativeQuery=true) List&lt;Users> queryUserByNameUseSQL(String name); @Query(value="select * from t_users where username like ?",nativeQuery=true) List&lt;Users> queryUserByLikeNameUseSQL(String name); @Query(value="select * from t_users where username = ? and userage >= ?",nativeQuery=true) List&lt;Users> queryUserByNameAndAgeUseSQL(String name,Integer age); } 编写测试类RepositoryTest.java package com.bjsxt.test; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * Repository接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 测试@Query查询 SQL */ @Test public void test7(){ List&lt;Users> list = this.usersDao.queryUserByNameUseSQL("王五"); for (Users users : list) { System.out.println(users); } } /** * 测试@Query查询 SQL */ @Test public void test8(){ List&lt;Users> list = this.usersDao.queryUserByLikeNameUseSQL("王%"); for (Users users : list) { System.out.println(users); } } /** * 测试@Query查询 SQL */ @Test public void test9(){ List&lt;Users> list = this.usersDao.queryUserByNameAndAgeUseSQL("王五", 22); for (Users users : list) { System.out.println(users); } } } @Query注解的更新编写接口package com.bjsxt.dao; import java.util.List; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.Repository; import com.bjsxt.pojo.Users; /** * Repository接口讲解 * @author Administrator * */ public interface UsersDao extends Repository&lt;Users, Integer> { @Query("update Users set userage = ? where userid = ?") @Modifying //@Modifying当前语句是一个更新语句 void updateUserAgeById(Integer age,Integer id); } 编写测试类package com.bjsxt.test; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * Repository接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 测试@Query update */ @Test @Transactional @Rollback(false) public void test10(){ this.usersDao.updateUserAgeById(24, 5); } } CrudRepository接口编写接口UsersDao.java package com.bjsxt.dao; import org.springframework.data.repository.CrudRepository; import com.bjsxt.pojo.Users; /** * CrudRepository接口讲解 * @author Administrator * */ public interface UsersDao extends CrudRepository&lt;Users, Integer> { } 编写测试类RepositoryTest.java package com.bjsxt.test; import java.util.ArrayList; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * CrudRepository接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 添加单条数据 */ @Test public void test1(){ Users user = new Users(); user.setUserage(21); user.setUsername("赵小丽"); this.usersDao.save(user); } /** * 批量添加数据 */ @Test public void test2(){ Users user = new Users(); user.setUserage(21); user.setUsername("赵小丽"); Users user1 = new Users(); user1.setUserage(25); user1.setUsername("王小虎"); List&lt;Users> list= new ArrayList&lt;>(); list.add(user); list.add(user1); this.usersDao.save(list); } /** * 根据ID查询单条数据 */ @Test public void test3(){ Users users = this.usersDao.findOne(13); System.out.println(users); } /** * 查询全部数据 */ @Test public void test4(){ List&lt;Users> list = (List&lt;Users>)this.usersDao.findAll(); for (Users users : list) { System.out.println(users); } } /** * 删除数据 */ @Test public void test5(){ this.usersDao.delete(13); } /** * 更新数据 方式一 */ @Test public void test6(){ Users user = this.usersDao.findOne(12); user.setUsername("王小红"); this.usersDao.save(user); } /** * 更新数据 方式二 */ @Test @Transactional @Rollback(false) public void test7(){ Users user = this.usersDao.findOne(12);//持久化状态的 user.setUsername("王小小"); } } PagingAndSortingRepository接口分页编写接口UsersDao.java package com.bjsxt.dao; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.PagingAndSortingRepository; import com.bjsxt.pojo.Users; /** * PagingAndSortingRepository接口讲解 * @author Administrator * */ public interface UsersDao extends PagingAndSortingRepository&lt;Users, Integer>{ } 编写测试代码RepositoryTest.java package com.bjsxt.test; import java.util.ArrayList; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * PagingAndSortingRepository接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 分页 */ @Test public void test1(){ int page = 2; //page:当前页的索引。注意索引都是从0开始的。 int size = 3;// size:每页显示3条数据 Pageable pageable= new PageRequest(page, size); Page&lt;Users> p = this.usersDao.findAll(pageable); System.out.println("数据的总条数："+p.getTotalElements()); System.out.println("总页数："+p.getTotalPages()); List&lt;Users> list = p.getContent(); for (Users users : list) { System.out.println(users); } } } 排序编写接口UsersDao.java package com.bjsxt.dao; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.PagingAndSortingRepository; import com.bjsxt.pojo.Users; /** * PagingAndSortingRepository接口讲解 * @author Administrator * */ public interface UsersDao extends PagingAndSortingRepository&lt;Users, Integer>{ } 编写测试代码RepositoryTest.java package com.bjsxt.test; import java.util.ArrayList; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.domain.Sort.Direction; import org.springframework.data.domain.Sort.Order; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestPropertySource; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * PagingAndSortingRepository接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 对单列做排序处理 */ @Test public void test2(){ //Sort:该对象封装了排序规则以及指定的排序字段(对象的属性来表示) //direction:排序规则 //properties:指定做排序的属性 Sort sort = new Sort(Direction.DESC,"userid"); List&lt;Users> list = (List&lt;Users>)this.usersDao.findAll(sort); for (Users users : list) { System.out.println(users); } } /** * 多列的排序处理 */ @Test public void test3(){ //Sort:该对象封装了排序规则以及指定的排序字段(对象的属性来表示) //direction:排序规则 //properties:指定做排序的属性 Order order1 = new Order(Direction.DESC,"userage"); Order order2 = new Order(Direction.ASC,"username"); Sort sort = new Sort(order1,order2); List&lt;Users> list = (List&lt;Users>)this.usersDao.findAll(sort); for (Users users : list) { System.out.println(users); } } } JpaRepository接口JpaRepository接口是我们开发时使用的最多的接口。其特点是可以帮助我们将其他接口的方法的返回值做适配处理。可以使得我们在开发时更方便的使用这些方法。 编写接口UsersDao.java package com.bjsxt.dao; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.PagingAndSortingRepository; import com.bjsxt.pojo.Users; /** * JpaRepository接口讲解 * @author Administrator * */ public interface UsersDao extends JpaRepository&lt;Users, Integer>{ } 编写测试类RepositoryTest.java package com.bjsxt.test; import java.util.ArrayList; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.domain.Sort.Direction; import org.springframework.data.domain.Sort.Order; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestPropertySource; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * JpaRepository接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 查询全部数据 */ @Test public void test1(){ List&lt;Users> list = this.usersDao.findAll(); for (Users users : list) { System.out.println(users); } } } JpaSpecificationExecutor接口完成多条件查询，并且支持分页与排序 单条件查询编写接口 JpaSpecificationExecutor&lt;Users&gt;:不能单独使用，需要配合着jpa中的其他接口一起使用 UsersDao.java package com.bjsxt.dao; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.PagingAndSortingRepository; import com.bjsxt.pojo.Users; /** * JpaSpecificationExecutor接口讲解 * @author Administrator *注意：JpaSpecificationExecutor&lt;Users>:不能单独使用，需要配合着jpa中的其他接口一起使用 */ public interface UsersDao extends JpaRepository&lt;Users, Integer>,JpaSpecificationExecutor&lt;Users>{ } 编写测试类RepositoryTest.java package com.bjsxt.test; import java.util.ArrayList; import java.util.List; import javax.persistence.criteria.CriteriaBuilder; import javax.persistence.criteria.CriteriaQuery; import javax.persistence.criteria.Predicate; import javax.persistence.criteria.Root; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.domain.Sort.Direction; import org.springframework.data.domain.Sort.Order; import org.springframework.data.jpa.domain.Specification; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestPropertySource; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * JpaSpecificationExecutor接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 需求：根据用户姓名查询数据 */ @Test public void test1(){ Specification&lt;Users> spec = new Specification&lt;Users>() { /** * @return Predicate:定义了查询条件 * @param Root&lt;Users> root:根对象。封装了查询条件的对象 * @param CriteriaQuery&lt;?> query:定义了一个基本的查询。一般不使用 * @param CriteriaBuilder cb:创建一个查询条件 */ @Override public Predicate toPredicate(Root&lt;Users> root, CriteriaQuery&lt;?> query, CriteriaBuilder cb) { Predicate pre = cb.equal(root.get("username"), "王五"); return pre; } }; List&lt;Users> list = this.usersDao.findAll(spec); for (Users users : list) { System.out.println(users); } } } 多条件查询方式一编写接口UsersDao.java package com.bjsxt.dao; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.PagingAndSortingRepository; import com.bjsxt.pojo.Users; /** * JpaSpecificationExecutor接口讲解 * @author Administrator *注意：JpaSpecificationExecutor&lt;Users>:不能单独使用，需要配合着jpa中的其他接口一起使用 */ public interface UsersDao extends JpaRepository&lt;Users, Integer>,JpaSpecificationExecutor&lt;Users>{ } 编写测试类RepositoryTest.java package com.bjsxt.test; import java.util.ArrayList; import java.util.List; import javax.persistence.criteria.CriteriaBuilder; import javax.persistence.criteria.CriteriaQuery; import javax.persistence.criteria.Predicate; import javax.persistence.criteria.Root; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.domain.Sort.Direction; import org.springframework.data.domain.Sort.Order; import org.springframework.data.jpa.domain.Specification; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestPropertySource; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * JpaSpecificationExecutor接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 多条件查询 方式一 * 需求：使用用户姓名以及年龄查询数据 */ @Test public void test2(){ Specification&lt;Users> spec = new Specification&lt;Users>() { @Override public Predicate toPredicate(Root&lt;Users> root, CriteriaQuery&lt;?> query, CriteriaBuilder cb) { List&lt;Predicate> list = new ArrayList&lt;>(); list.add(cb.equal(root.get("username"),"王五")); list.add(cb.equal(root.get("userage"),24)); //此时条件之间是没有任何关系的。 Predicate[] arr = new Predicate[list.size()]; return cb.and(list.toArray(arr)); } }; List&lt;Users> list = this.usersDao.findAll(spec); for (Users users : list) { System.out.println(users); } } } 方式二编写接口UsersDao.java package com.bjsxt.dao; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.PagingAndSortingRepository; import com.bjsxt.pojo.Users; /** * JpaSpecificationExecutor接口讲解 * @author Administrator *注意：JpaSpecificationExecutor&lt;Users>:不能单独使用，需要配合着jpa中的其他接口一起使用 */ public interface UsersDao extends JpaRepository&lt;Users, Integer>,JpaSpecificationExecutor&lt;Users>{ } 编写测试类RepositoryTest.java package com.bjsxt.test; import java.util.ArrayList; import java.util.List; import javax.persistence.criteria.CriteriaBuilder; import javax.persistence.criteria.CriteriaQuery; import javax.persistence.criteria.Predicate; import javax.persistence.criteria.Root; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.domain.Sort.Direction; import org.springframework.data.domain.Sort.Order; import org.springframework.data.jpa.domain.Specification; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestPropertySource; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * JpaSpecificationExecutor接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 多条件查询 方式二 * 需求：使用用户姓名或者年龄查询数据 */ @Test public void test3(){ Specification&lt;Users> spec = new Specification&lt;Users>() { @Override public Predicate toPredicate(Root&lt;Users> root, CriteriaQuery&lt;?> query, CriteriaBuilder cb) { return cb.or(cb.equal(root.get("username"),"王五"),cb.equal(root.get("userage"), 25)); } }; List&lt;Users> list = this.usersDao.findAll(spec); for (Users users : list) { System.out.println(users); } } } 分页编写接口UsersDao.java package com.bjsxt.dao; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.PagingAndSortingRepository; import com.bjsxt.pojo.Users; /** * JpaSpecificationExecutor接口讲解 * @author Administrator *注意：JpaSpecificationExecutor&lt;Users>:不能单独使用，需要配合着jpa中的其他接口一起使用 */ public interface UsersDao extends JpaRepository&lt;Users, Integer>,JpaSpecificationExecutor&lt;Users>{ } 编写测试类RepositoryTest.java package com.bjsxt.test; import java.util.ArrayList; import java.util.List; import javax.persistence.criteria.CriteriaBuilder; import javax.persistence.criteria.CriteriaQuery; import javax.persistence.criteria.Predicate; import javax.persistence.criteria.Root; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.domain.Sort.Direction; import org.springframework.data.domain.Sort.Order; import org.springframework.data.jpa.domain.Specification; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestPropertySource; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * JpaSpecificationExecutor接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 需求：查询王姓用户，并且做分页处理 */ @Test public void test4(){ //条件 Specification&lt;Users> spec = new Specification&lt;Users>() { @Override public Predicate toPredicate(Root&lt;Users> root, CriteriaQuery&lt;?> query, CriteriaBuilder cb) { return cb.like(root.get("username").as(String.class), "王%"); } }; //分页 Pageable pageable = new PageRequest(2, 2); Page&lt;Users> page = this.usersDao.findAll(spec, pageable); System.out.println("总条数："+page.getTotalElements()); System.out.println("总页数："+page.getTotalPages()); List&lt;Users> list = page.getContent(); for (Users users : list) { System.out.println(users); } } } 排序编写接口UsersDao.java package com.bjsxt.dao; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.PagingAndSortingRepository; import com.bjsxt.pojo.Users; /** * JpaSpecificationExecutor接口讲解 * @author Administrator *注意：JpaSpecificationExecutor&lt;Users>:不能单独使用，需要配合着jpa中的其他接口一起使用 */ public interface UsersDao extends JpaRepository&lt;Users, Integer>,JpaSpecificationExecutor&lt;Users>{ } 编写测试类RepositoryTest.java package com.bjsxt.test; import java.util.ArrayList; import java.util.List; import javax.persistence.criteria.CriteriaBuilder; import javax.persistence.criteria.CriteriaQuery; import javax.persistence.criteria.Predicate; import javax.persistence.criteria.Root; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.domain.Sort.Direction; import org.springframework.data.domain.Sort.Order; import org.springframework.data.jpa.domain.Specification; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestPropertySource; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * JpaSpecificationExecutor接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 需求：查询数据库中王姓的用户，并且根据用户id做倒序排序 */ @Test public void test5(){ //条件 Specification&lt;Users> spec = new Specification&lt;Users>() { @Override public Predicate toPredicate(Root&lt;Users> root, CriteriaQuery&lt;?> query, CriteriaBuilder cb) { return cb.like(root.get("username").as(String.class), "王%"); } }; //排序 Sort sort = new Sort(Direction.DESC,"userid"); List&lt;Users> list = this.usersDao.findAll(spec, sort); for (Users users : list) { System.out.println(users); } } } 分页与排序编写接口UsersDao.java package com.bjsxt.dao; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.PagingAndSortingRepository; import com.bjsxt.pojo.Users; /** * JpaSpecificationExecutor接口讲解 * @author Administrator *注意：JpaSpecificationExecutor&lt;Users>:不能单独使用，需要配合着jpa中的其他接口一起使用 */ public interface UsersDao extends JpaRepository&lt;Users, Integer>,JpaSpecificationExecutor&lt;Users>{ } 编写测试类RepositoryTest.java package com.bjsxt.test; import java.util.ArrayList; import java.util.List; import javax.persistence.criteria.CriteriaBuilder; import javax.persistence.criteria.CriteriaQuery; import javax.persistence.criteria.Predicate; import javax.persistence.criteria.Root; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.domain.Sort.Direction; import org.springframework.data.domain.Sort.Order; import org.springframework.data.jpa.domain.Specification; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestPropertySource; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * JpaSpecificationExecutor接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 需求：查询数据库中王姓的用户，做分页处理，并且根据用户id做倒序排序 */ @Test public void test6(){ //排序等定义 Sort sort = new Sort(Direction.DESC,"userid"); //分页的定义 Pageable pageable = new PageRequest(2,2, sort); //查询条件 Specification&lt;Users> spec = new Specification&lt;Users>() { @Override public Predicate toPredicate(Root&lt;Users> root, CriteriaQuery&lt;?> query, CriteriaBuilder cb) { return cb.like(root.get("username").as(String.class), "王%"); } }; Page&lt;Users> page = this.usersDao.findAll(spec, pageable); System.out.println("总条数："+page.getTotalElements()); System.out.println("总页数："+page.getTotalPages()); List&lt;Users> list = page.getContent(); for (Users users : list) { System.out.println(users); } } } 自定义 Repository 接口编写接口UsersRepository.java package com.bjsxt.dao; import com.bjsxt.pojo.Users; public interface UsersRepository { public Users findUserById(Integer userid); } 使用接口UsersDao.java package com.bjsxt.dao; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.PagingAndSortingRepository; import com.bjsxt.pojo.Users; /** * 用户自定义Repository接口讲解 * @author Administrator */ public interface UsersDao extends JpaRepository&lt;Users, Integer>,JpaSpecificationExecutor&lt;Users>,UsersRepository{ } 编写接口实现类UsersDaoImpl.java package com.bjsxt.dao; import javax.persistence.EntityManager; import javax.persistence.PersistenceContext; import com.bjsxt.pojo.Users; public class UsersDaoImpl implements UsersRepository { @PersistenceContext(name="entityManagerFactory") private EntityManager em; @Override public Users findUserById(Integer userid) { System.out.println("MyRepository......"); return this.em.find(Users.class, userid); } } 编写测试类RepositoryTest.java package com.bjsxt.test; import java.util.ArrayList; import java.util.List; import javax.persistence.criteria.CriteriaBuilder; import javax.persistence.criteria.CriteriaQuery; import javax.persistence.criteria.Predicate; import javax.persistence.criteria.Root; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.domain.Sort.Direction; import org.springframework.data.domain.Sort.Order; import org.springframework.data.jpa.domain.Specification; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestPropertySource; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.transaction.annotation.Transactional; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Users; /** * JpaRepository接口测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 需求：根据用户ID查询数据 */ @Test public void test1(){ Users users = this.usersDao.findUserById(5); System.out.println(users); } } 多表操作一对一需求：用户与角色的一对一的关联关系用户：一方角色：一方 编写Users实体Users.java package com.bjsxt.pojo; import java.io.Serializable; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name="t_users") public class Users implements Serializable{ @Id @GeneratedValue(strategy=GenerationType.IDENTITY)//strategy=GenerationType.IDENTITY 自增长 @Column(name="userid") private Integer userid; @Column(name="username") private String username; @Column(name="userage") private Integer userage; public Roles getRoles() { return roles; } public void setRoles(Roles roles) { this.roles = roles; } @OneToOne(cascade=CascadeType.PERSIST) //@JoinColumn：就是维护一个外键 @JoinColumn(name="roles_id") private Roles roles; public Integer getUserid() { return userid; } public void setUserid(Integer userid) { this.userid = userid; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Integer getUserage() { return userage; } public void setUserage(Integer userage) { this.userage = userage; } @Override public String toString() { return "Users [userid=" + userid + ", username=" + username + ", userage=" + userage + "]"; } } 编写Roles实体package com.bjsxt.pojo; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name="t_roles") public class Roles { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="roleid") private Integer roleid; @Column(name="rolename") private String rolename; @OneToOne(mappedBy="roles") private Users users; public Users getUsers() { return users; } public void setUsers(Users users) { this.users = users; } public Integer getRoleid() { return roleid; } public void setRoleid(Integer roleid) { this.roleid = roleid; } public String getRolename() { return rolename; } public void setRolename(String rolename) { this.rolename = rolename; } @Override public String toString() { return "Roles [roleid=" + roleid + ", rolename=" + rolename + "]"; } } 编写测试类OneToOneTest.java package com.bjsxt.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Roles; import com.bjsxt.pojo.Users; /** * 一对一关联关系测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class OneToOneTest { @Autowired private UsersDao usersDao; /** * 添加用户同时添加角色 */ @Test public void test1(){ //创建角色 Roles roles = new Roles(); roles.setRolename("管理员"); //创建用户 Users users = new Users(); users.setUserage(30); users.setUsername("赵小刚"); //建立关系 users.setRoles(roles); roles.setUsers(users); //保存数据 this.usersDao.save(users); } /** * 根据用户ID查询用户，同时查询用户角色 */ @Test public void test2(){ Users users = this.usersDao.findOne(13); System.out.println("用户信息："+users); Roles roles = users.getRoles(); System.out.println(roles); } } 一对多需求：从角色到用户的一对多的关联关系角色：一方用户：多方 编写Users实体Users.java package com.bjsxt.pojo; import java.io.Serializable; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name="t_users") public class Users implements Serializable{ @Id @GeneratedValue(strategy=GenerationType.IDENTITY)//strategy=GenerationType.IDENTITY 自增长 @Column(name="userid") private Integer userid; @Column(name="username") private String username; @Column(name="userage") private Integer userage; @ManyToOne(cascade=CascadeType.PERSIST) @JoinColumn(name="roles_id") private Roles roles; public Roles getRoles() { return roles; } public void setRoles(Roles roles) { this.roles = roles; } public Integer getUserid() { return userid; } public void setUserid(Integer userid) { this.userid = userid; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Integer getUserage() { return userage; } public void setUserage(Integer userage) { this.userage = userage; } @Override public String toString() { return "Users [userid=" + userid + ", username=" + username + ", userage=" + userage + "]"; } } 编写Roles实体Roles.java package com.bjsxt.pojo; import java.util.HashSet; import java.util.Set; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.OneToMany; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name="t_roles") public class Roles { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="roleid") private Integer roleid; @Column(name="rolename") private String rolename; @OneToMany(mappedBy="roles") private Set&lt;Users> users = new HashSet&lt;>(); public Set&lt;Users> getUsers() { return users; } public void setUsers(Set&lt;Users> users) { this.users = users; } public Integer getRoleid() { return roleid; } public void setRoleid(Integer roleid) { this.roleid = roleid; } public String getRolename() { return rolename; } public void setRolename(String rolename) { this.rolename = rolename; } @Override public String toString() { return "Roles [roleid=" + roleid + ", rolename=" + rolename + "]"; } } 编写测试类OneToManyTest.java package com.bjsxt.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.dao.UsersDao; import com.bjsxt.pojo.Roles; import com.bjsxt.pojo.Users; /** * 一对多的关联关系测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class OneToManyTest { @Autowired private UsersDao usersDao; /** * 添加用户同时添加角色 */ @Test public void test1(){ //创建角色 Roles roles = new Roles(); roles.setRolename("管理员"); //创建用户 Users users =new Users(); users.setUserage(30); users.setUsername("小王"); //建立关系 roles.getUsers().add(users); users.setRoles(roles); //保存数据 this.usersDao.save(users); } /** * 根据用户ID查询用户信息，同时查询角色 */ @Test public void test2(){ Users users = this.usersDao.findOne(14); System.out.println("用户姓名："+users.getUsername()); Roles roles = users.getRoles(); System.out.println(roles); } } 多对多双向的一对多 需求：一个角色可以拥有多个菜单，一个菜单可以分配多个角色。多对多的关联关系角色：多方菜单：多方 编写Roles实体Roles.java package com.bjsxt.pojo; import java.util.HashSet; import java.util.Set; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.JoinTable; import javax.persistence.ManyToMany; import javax.persistence.OneToMany; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name="t_roles") public class Roles { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="roleid") private Integer roleid; @Column(name="rolename") private String rolename; @ManyToMany //@JoinTable:配置中间表信息 //joinColumns:建立当前表在中间表中的外键字段 @JoinTable(name="t_roles_menus",joinColumns=@JoinColumn(name="role_id"),inverseJoinColumns=@JoinColumn(name="menu_id")) private Set&lt;Menus> menus = new HashSet&lt;>(); public Set&lt;Menus> getMenus() { return menus; } public void setMenus(Set&lt;Menus> menus) { this.menus = menus; } public Integer getRoleid() { return roleid; } public void setRoleid(Integer roleid) { this.roleid = roleid; } public String getRolename() { return rolename; } public void setRolename(String rolename) { this.rolename = rolename; } @Override public String toString() { return "Roles [roleid=" + roleid + ", rolename=" + rolename + "]"; } } 编写Menus实体Menus.java package com.bjsxt.pojo; import java.util.HashSet; import java.util.Set; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.ManyToMany; import javax.persistence.Table; @Entity @Table(name="t_menus") public class Menus { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="menusid") private Integer menusid; @Column(name="menusname") private String menusname; @Column(name="menusurl") private String menusurl; @Column(name="fatherid") private Integer fatherid; @ManyToMany(mappedBy="menus") private Set&lt;Roles> roles = new HashSet&lt;>(); public Set&lt;Roles> getRoles() { return roles; } public void setRoles(Set&lt;Roles> roles) { this.roles = roles; } public Integer getMenusid() { return menusid; } public void setMenusid(Integer menusid) { this.menusid = menusid; } public String getMenusname() { return menusname; } public void setMenusname(String menusname) { this.menusname = menusname; } public String getMenusurl() { return menusurl; } public void setMenusurl(String menusurl) { this.menusurl = menusurl; } public Integer getFatherid() { return fatherid; } public void setFatherid(Integer fatherid) { this.fatherid = fatherid; } @Override public String toString() { return "Menus [menusid=" + menusid + ", menusname=" + menusname + ", menusurl=" + menusurl + ", fatherid=" + fatherid + "]"; } } 编写测试类ManyToManyTest.java package com.bjsxt.test; import java.util.Set; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.dao.RolesDao; import com.bjsxt.pojo.Menus; import com.bjsxt.pojo.Roles; /** * 多对多关联关系测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class ManyToManyTest { @Autowired private RolesDao rolesDao; /** * 添加角色同时添加菜单 */ @Test public void test1(){ //创建角色对象 Roles roles = new Roles(); roles.setRolename("超级管理员"); //创建菜单对象 XXX管理平台 --->用户管理 Menus menus = new Menus(); menus.setMenusname("XXX管理平台"); menus.setFatherid(-1); menus.setMenusurl(null); //用户管理菜单 Menus menus1 = new Menus(); menus1.setMenusname("用户管理"); menus1.setFatherid(1); menus1.setMenusurl(null); //建立关系 roles.getMenus().add(menus); roles.getMenus().add(menus1); menus.getRoles().add(roles); menus1.getRoles().add(roles); //保存数据 this.rolesDao.save(roles); } /** * 查询Roles */ @Test public void test2(){ Roles roles = this.rolesDao.findOne(3); System.out.println("角色信息："+roles); Set&lt;Menus> menus = roles.getMenus(); for (Menus menus2 : menus) { System.out.println("菜单信息："+menus2); } } } Spring Data RedisSpring Data Redis Spring Data Redis, part of the larger Spring Data family, provides easy configuration and access to Redis from Spring applications. It offers both low-level and high-level abstractions for interacting with the store, freeing the user from infrastructural concerns. 安装环境Redis 版本：3.0.0环境：Linux 步骤安装 gcc 编译器yum install gcc-c++解压安装包tar -zxf redis-3.0.0.tar.gz进入解压目录进行编译cd redis-3.0.0 make将 Redis 安装到指定目录make PREFIX=/usr/local/redis install启动 Redis 前置启动 默认的是前置启动：./redis-server 后置启动 先将 redis.conf 文件拷贝到 redis 的安装目录cp redis.conf /usr/local/redis/bin 编辑 redis.conf 文件修改：daemonize yes 启动：./redis-server redis.conf 查看 redis 进程：ps aux|grep redis 关闭后置启动的 Redis：./redis-cli shutdown 搭建整合环境创建项目导入jar包spring-iocspring-beans-4.2.0.RELEASE.jar spring-context-4.2.0.RELEASE.jar spring-core-4.2.0.RELEASE.jar spring-expression-4.2.0.RELEASE.jar spring-aopaopalliance.jar aspectjrt.jar aspectjweaver.jar spring-aop-4.2.0.RELEASE.jar spring-aspects-4.2.0.RELEASE.jar spring-jdbcspring-jdbc-4.2.0.RELEASE.jar(这里没有用到) spring-tx-4.2.0.RELEASE.jar spring-orm这里不需要用到 spring testspring-tx-4.2.0.RELEASE.jar apache-loggingcommons-logging-1.1.1.jar spring-data-rediscommons-pool2-2.3.jar jedis-2.7.2.jar spring-data-redis-1.6.0.RELEASE.jar 编写配置文件 配置读取properties文件的工具类 Jedis连接池 Jedis连接工厂:创建Jedis对象的工厂 Redis模板对象:是SpringDataRedis提供的用户操作Redis的对象 applicationContext.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> &lt;!-- 配置读取properties文件的工具类 --> &lt;context:property-placeholder location="classpath:redis.properties"/> &lt;!-- Jedis连接池 --> &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"> &lt;property name="maxTotal" value="${redis.pool.maxtTotal}"/> &lt;property name="maxIdle" value="${redis.pool.maxtIdle}"/> &lt;property name="minIdle" value="${redis.pool.minIdle}"/> &lt;/bean> &lt;!-- Jedis连接工厂:创建Jedis对象的工厂 --> &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"> &lt;!-- IP地址 --> &lt;property name="hostName" value="${redis.hostname}"/> &lt;!-- 端口 --> &lt;property name="port" value="${redis.port}"/> &lt;!-- 连接池 --> &lt;property name="poolConfig" ref="poolConfig"/> &lt;/bean> &lt;!-- Redis模板对象:是SpringDataRedis提供的用户操作Redis的对象 --> &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"> &lt;!-- 默认的序列化器：序列化器就是根据规则将存储的数据中的key与value做字符串的序列化处理 --> &lt;!-- keySerializer、valueSerializer：对应的是Redis中的String类型 --> &lt;!-- hashKeySerializer、hashValueSerializer：对应的是Redis中的Hash类型 --> &lt;property name="keySerializer"> &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer">&lt;/bean> &lt;/property> &lt;property name="valueSerializer"> &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer">&lt;/bean> &lt;/property> &lt;/bean> &lt;/beans> redis.properties redis.pool.maxtTotal=20 redis.pool.maxIdle=10 redis.pool.minIdle=5 redis.hostname=192.168.70.129 redis.port=6379编写测试类RedisTest.java package com.bjsxt.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; /** * Redis测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RedisTest { @Autowired private RedisTemplate&lt;String, Object> redisTemplate; /** * 添加键值对 */ @Test public void test1(){ this.redisTemplate.opsForValue().set("key", "test"); } /** * 获取redis中的数据 */ @Test public void test2(){ String str = (String)this.redisTemplate.opsForValue().get("key"); System.out.println(str); } } 存储实体对象编写实体类要实现序列化接口Serializable Users.java package com.bjsxt.pojo; import java.io.Serializable; public class Users implements Serializable{ private Integer id; private String name; private Integer age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return "Users [id=" + id + ", name=" + name + ", age=" + age + "]"; } } 编写测试类默认序列化StringRedisSerializer在配置文件applicationContext.xml中指定，测试的时候可以更换序列化器 RedisTest.java package com.bjsxt.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.pojo.Users; /** * Redis测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RedisTest { @Autowired private RedisTemplate&lt;String, Object> redisTemplate; /** * 添加Users */ @Test public void test3(){ Users users = new Users(); users.setAge(30); users.setId(1); users.setName("张三"); //更换序列化器 this.redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); this.redisTemplate.opsForValue().set("users", users); } /** * 获取Users * */ @Test public void test4(){ //更换序列化器 this.redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); Users users = (Users)this.redisTemplate.opsForValue().get("users"); System.out.println(users); } } 以 JSON格式存储对象导入jar包jackson-annotations-2.8.0.jar jackson-core-2.8.10.jar jackson-databind-2.8.10.jar 编写实体类实现序列化接口 Users.java package com.bjsxt.pojo; import java.io.Serializable; public class Users implements Serializable{ private Integer id; private String name; private Integer age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return "Users [id=" + id + ", name=" + name + ", age=" + age + "]"; } } 编写测试类设置json序列化器this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Users.class)); RedisTest.java package com.bjsxt.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.pojo.Users; /** * Redis测试 * @author Administrator * */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:applicationContext.xml") public class RedisTest { @Autowired private RedisTemplate&lt;String, Object> redisTemplate; /** * 添加Users JSON格式 */ @Test public void test5(){ Users users = new Users(); users.setAge(23); users.setId(2); users.setName("李四"); this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;>(Users.class)); this.redisTemplate.opsForValue().set("usersjson", users); } /** * 获取Uesrs JSON格式 */ @Test public void test6(){ this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;>(Users.class)); Users users = (Users)this.redisTemplate.opsForValue().get("usersjson"); System.out.println(users); } }]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>springdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo]]></title>
    <url>%2F2019%2F06%2F13%2Fdubbo%2F</url>
    <content type="text"><![CDATA[dubbo环境搭建安装zookeeper下载zookeeperIndex of /dist/zookeeper/zookeeper-3.4.13 解压 修改配置文件进入C:\Users\shenlibing\Downloads\zookeeper-3.4.13\conf将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可 dataDir 临时数据存储的目录（可写相对路径） clientPort=2181 zookeeper的端口号 测试 开启服务端 开启客户端 安装dubbo-admin管理控制台dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。 但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。 下载dubbo-adminapache/dubbo-admin at master 解压 修改dubbo-admin配置 指定zookeeper地址 打包dubbo-adminmvn clean package -Dmaven.test.skip=true 运行dubbo-adminjava -jar dubbo-admin-0.0.1-SNAPSHOT.jar 访问http://localhost:7001，默认使用`root/root `登陆 dubbo-helloworld创建订单服务web模块 用户服务service模块 分包版本一 order-service-consumer订单消费层 user-service-provider用户服务提供层 版本二将公共的地址实体、订单接口、用户接口提取到公共接口层，新建一个公共接口层 gmall-interface公共接口层 order-service-consumer订单消费层 user-service-provider用户服务提供层 代码公共接口层代码UserAddress.java package com.atguigu.gmall.bean; import java.io.Serializable; /** * 用户地址 * @author lfy * */ public class UserAddress implements Serializable { private Integer id; private String userAddress; //用户地址 private String userId; //用户id private String consignee; //收货人 private String phoneNum; //电话号码 private String isDefault; //是否为默认地址 Y-是 N-否 public UserAddress() { super(); // TODO Auto-generated constructor stub } public UserAddress(Integer id, String userAddress, String userId, String consignee, String phoneNum, String isDefault) { super(); this.id = id; this.userAddress = userAddress; this.userId = userId; this.consignee = consignee; this.phoneNum = phoneNum; this.isDefault = isDefault; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUserAddress() { return userAddress; } public void setUserAddress(String userAddress) { this.userAddress = userAddress; } public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public String getConsignee() { return consignee; } public void setConsignee(String consignee) { this.consignee = consignee; } public String getPhoneNum() { return phoneNum; } public void setPhoneNum(String phoneNum) { this.phoneNum = phoneNum; } public String getIsDefault() { return isDefault; } public void setIsDefault(String isDefault) { this.isDefault = isDefault; } } OrderService.java package com.atguigu.gmall.service; import java.util.List; import com.atguigu.gmall.bean.UserAddress; public interface OrderService { /** * 初始化订单 * @param userId */ public List&lt;UserAddress> initOrder(String userId); } UserService.java package com.atguigu.gmall.service; import java.util.List; import com.atguigu.gmall.bean.UserAddress; /** * 用户服务 * @author lfy * */ public interface UserService { /** * 按照用户id返回所有的收货地址 * @param userId * @return */ public List&lt;UserAddress> getUserAddressList(String userId); } 订单消费层代码OrderServiceImpl.java package com.atguigu.gmall.service.impl; import java.util.List; import com.atguigu.gmall.bean.UserAddress; import com.atguigu.gmall.service.OrderService; import com.atguigu.gmall.service.UserService; /** * 1、将服务提供者注册到注册中心（暴露服务） * 1）、导入dubbo依赖（2.6.2）\操作zookeeper的客户端(curator) * 2）、配置服务提供者 * * 2、让服务消费者去注册中心订阅服务提供者的服务地址 * @author lfy * */ public class OrderServiceImpl implements OrderService { UserService userService; @Override public List&lt;UserAddress> initOrder(String userId) { // TODO Auto-generated method stub System.out.println("用户id："+userId); //1、查询用户的收货地址 List&lt;UserAddress> addressList = userService.getUserAddressList(userId); for (UserAddress userAddress : addressList) { System.out.println(userAddress.getUserAddress()); } return addressList; } } 用户服务提供层代码UserServiceImpl.java package com.atguigu.gmall.service.impl; import java.util.Arrays; import java.util.List; import com.atguigu.gmall.bean.UserAddress; import com.atguigu.gmall.service.UserService; public class UserServiceImpl implements UserService { @Override public List&lt;UserAddress> getUserAddressList(String userId) { UserAddress address1 = new UserAddress(1, "北京市昌平区宏福科技园综合楼3层", "1", "李老师", "010-56253825", "Y"); UserAddress address2 = new UserAddress(2, "深圳市宝安区西部硅谷大厦B座3层（深圳分校）", "1", "王老师", "010-56253825", "N"); return Arrays.asList(address1,address2); } } 依赖配置订单消费层需要引用公共接口层 pom.xml &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.atguigu.gmall&lt;/groupId> &lt;artifactId>order-service-consumer&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;dependencies> &lt;dependency> &lt;groupId>com.atguigu.gmall&lt;/groupId> &lt;artifactId>gmall-interface&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/project> 用户服务提供层需要引用公共接口层 pom.xml &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.atguigu.gmall&lt;/groupId> &lt;artifactId>user-service-provider&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;dependencies> &lt;dependency> &lt;groupId>com.atguigu.gmall&lt;/groupId> &lt;artifactId>gmall-interface&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/project> dubbo通信为了让订单消费层和用户服务提供层可以通信，使用dubbo进行配置 用户服务提供层导入依赖 导入dubbo依赖（2.6.2） 操作zookeeper的客户端(curator)依赖 &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.atguigu.gmall&lt;/groupId> &lt;artifactId>user-service-provider&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;dependencies> &lt;dependency> &lt;groupId>com.atguigu.gmall&lt;/groupId> &lt;artifactId>gmall-interface&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;/dependency> &lt;!-- 引入dubbo --> &lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>dubbo&lt;/artifactId> &lt;version>2.6.2&lt;/version> &lt;/dependency> &lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端端 --> &lt;dependency> &lt;groupId>org.apache.curator&lt;/groupId> &lt;artifactId>curator-framework&lt;/artifactId> &lt;version>2.12.0&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/project> 配置服务提供者新建provider.xml文件 指定当前服务/应用的名字 指定注册中心的位置 指定通信规则（通信协议？通信端口） 暴露服务 provider.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"> &lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --> &lt;dubbo:application name="user-service-provider">&lt;/dubbo:application> &lt;!-- 2、指定注册中心的位置 --> &lt;!-- &lt;dubbo:registry address="zookeeper://127.0.0.1:2181">&lt;/dubbo:registry> --> &lt;dubbo:registry protocol="zookeeper" address="127.0.0.1:2181">&lt;/dubbo:registry> &lt;!-- 3、指定通信规则（通信协议？通信端口） --> &lt;dubbo:protocol name="dubbo" port="20882">&lt;/dubbo:protocol> &lt;!-- 4、暴露服务 ref：指向服务的真正的实现对象 --> &lt;dubbo:service interface="com.atguigu.gmall.service.UserService" ref="userServiceImpl"> &lt;/dubbo:service> &lt;!-- 服务的实现 --> &lt;bean id="userServiceImpl" class="com.atguigu.gmall.service.impl.UserServiceImpl">&lt;/bean> &lt;/beans> 测试服务提供者新建MainApplication.java MainApplication.java package com.atguigu.gmall; import java.io.IOException; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainApplication { public static void main(String[] args) throws IOException { ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext("provider.xml"); ioc.start(); System.in.read(); } } 在dubbo控制台进行查看,可以看到有一个服务提供者 订单消费层导入依赖pom.xml &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.atguigu.gmall&lt;/groupId> &lt;artifactId>order-service-consumer&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;dependencies> &lt;dependency> &lt;groupId>com.atguigu.gmall&lt;/groupId> &lt;artifactId>gmall-interface&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;/dependency> &lt;!-- 引入dubbo --> &lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>dubbo&lt;/artifactId> &lt;version>2.6.2&lt;/version> &lt;/dependency> &lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端端 --> &lt;dependency> &lt;groupId>org.apache.curator&lt;/groupId> &lt;artifactId>curator-framework&lt;/artifactId> &lt;version>2.12.0&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/project> 配置订单消费者新建consumer.xml文件 consumer.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"> &lt;context:component-scan base-package="com.atguigu.gmall.service.impl">&lt;/context:component-scan> &lt;dubbo:application name="order-service-consumer">&lt;/dubbo:application> &lt;dubbo:registry address="zookeeper://127.0.0.1:2181">&lt;/dubbo:registry> &lt;!--声明需要调用的远程服务的接口；生成远程服务代理 --> &lt;dubbo:reference interface="com.atguigu.gmall.service.UserService" id="userService"> &lt;/dubbo:reference> &lt;/beans> 测试订单消费者新建MainApplication.java MainApplication.java package com.atguigu.gmall; import java.io.IOException; import org.springframework.context.support.ClassPathXmlApplicationContext; import com.atguigu.gmall.service.OrderService; public class MainApplication { @SuppressWarnings("resource") public static void main(String[] args) throws IOException { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("consumer.xml"); OrderService orderService = applicationContext.getBean(OrderService.class); orderService.initOrder("1"); System.out.println("调用完成...."); System.in.read(); } } 运行MainApplication.java 扫描订单消费层 修改订单消费代码，将消费实现加入到容器，并把UserService注入进来 查看dubbo控制台，服务数：1，应用数：2，提供者数：1，消费者数：1 安装dubbo-monitor-simple简单的监控中心 下载apache/dubbo-admin at master 解压 修改配置文件进入C:\Users\shenlibing\Downloads\dubbo-admin-master\dubbo-monitor-simple\src\main\resources\conf目录，编辑dubbo.properties 打包mvn clean package -Dmaven.test.skip=true 解压解压dubbo-monitor-simple-2.0.0-assembly.tar.gz—&gt;dubbo-monitor-simple-2.0.0-assembly.tar—&gt;dubbo-monitor-simple-2.0.0 运行 访问http://localhost:8080,如下图所示]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2019%2F06%2F08%2Fmysql%2F</url>
    <content type="text"><![CDATA[安装下载MySQL :: Download MySQL Community Server (Archived Versions) rzsz[root@192 modules]# yum -y install lrzsz上传[root@192 modules]# ll total 66632 -rw-r--r--. 1 root root 17855952 Jun 8 20:04 MySQL-client-5.5.48-1.linux2.6.x86_64.rpm -rw-r--r--. 1 root root 50372369 Jun 8 20:24 MySQL-server-5.5.48-1.linux2.6.x86_64.rpm 卸载方式一[root@192 modules]# rpm -qa | grep -i mysql mysql-libs-5.1.73-7.el6.x86_64 [root@192 modules]# rpm -e --nodeps mysql-libs-5.1.73-7.el6.x86_64方式二[root@192 modules]# yum -y remove mysql-libs-5.1.73-7.el6.x86_64如果提示“GPG keys...”安装失败，解决方案：rpm -ivh rpm软件名 --force --nodoeps 服务端[root@192 modules]# rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm warning: MySQL-server-5.5.48-1.linux2.6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY Preparing... ########################################### [100%] 1:MySQL-server ########################################### [100%] 190608 20:32:37 [Note] /usr/sbin/mysqld (mysqld 5.5.48) starting as process 26375 ... 190608 20:32:37 [Note] /usr/sbin/mysqld (mysqld 5.5.48) starting as process 26382 ... PLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER ! To do so, start the server, then issue the following commands: /usr/bin/mysqladmin -u root password &#39;new-password&#39; /usr/bin/mysqladmin -u root -h 192.168.1.101 password &#39;new-password&#39; Alternatively you can run: /usr/bin/mysql_secure_installation which will also give you the option of removing the test databases and anonymous user created by default. This is strongly recommended for production servers. See the manual for more instructions. Please report any problems at http://bugs.mysql.com/客户端[root@192 modules]# rpm -ivh MySQL-client-5.5.48-1.linux2.6.x86_64.rpm warning: MySQL-client-5.5.48-1.linux2.6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY Preparing... ########################################### [100%] 1:MySQL-client ########################################### [100%]验证[root@192 mysql]# mysqladmin --version mysqladmin Ver 8.42 Distrib 5.5.48, for Linux on x86_64启动服务方式一[root@192 mysql]# service mysql start; Starting MySQL.. [ OK ] 方式二 在计算机reboot后 登陆MySQL : mysql可能会报错： &quot;/var/lib/mysql/mysql.sock不存在&quot; 原因：是Mysql服务没有启动 解决 ： 启动服务 每次使用前 手动启动服务 /etc/init.d/mysql start 开机自启 chkconfig mysql on ,chkconfig mysql off [root@192 modules]# /etc/init.d/mysql start Starting MySQL.. [ OK ]方式三 开启自启mysql服务 [root@192 mysql]# chkconfig mysql on [root@192 mysql]# chkconfig mysql --list mysql 0:off 1:off 2:on 3:on 4:on 5:on 6:off关闭服务[root@192 mysql]# service mysql stop Shutting down MySQL... [ OK ]重启服务[root@192 mysql]# service mysql restart; Shutting down MySQL. [ OK ] Starting MySQL.. [ OK ]检查开机是否自动启动mysql服务[root@192 mysql]# ntsysv 修改密码[root@192 modules]# /usr/bin/mysqladmin -u root password &#39;000000&#39;连接[root@192 modules]# mysql -uroot -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 2 Server version: 5.5.48 MySQL Community Server (GPL) Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement. mysql&gt; 授权mysql&gt; grant all privileges on *.* to root@&#39;%&#39; identified by &quot;000000&quot;; Query OK, 0 rows affected (0.00 sec) mysql&gt; FLUSH PRIVILEGES; Query OK, 0 rows affected (0.00 sec)坑 客户端连接不上 关闭防火墙 [root@192 ~]# service iptables stop; iptables: Setting chains to policy ACCEPT: filter [ OK ] iptables: Flushing firewall rules: [ OK ] iptables: Unloading modules: [ OK ] [root@192 ~]# service iptables status; iptables: Firewall is not running. rpm安装mysql，找不到/etc/my.cnf 复制/usr/share/mysql目录下的my-huge.cnf文件到/etc目录，并改名为my.cnf即可 [root@192 mysql]# cp /usr/share/mysql/my-huge.cnf /etc/my.cnf数据库存放目录[root@192 mysql]# ps -ef|grep mysql root 5790 3618 0 14:13 pts/1 00:00:00 mysql -uroot -p root 5802 4605 0 14:24 pts/3 00:00:00 mysql -uroot -p root 7266 1 0 14:46 pts/0 00:00:00 /bin/sh /usr/bin/mysqld_safe --datadir=/var/lib/mysql --pid-file=/var/lib/mysql/192.168.1.101.pid mysql 7615 7266 0 14:46 pts/0 00:00:00 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib64/mysql/plugin --user=mysql --log-error=/var/lib/mysql/192.168.1.101.err --pid-file=/var/lib/mysql/192.168.1.101.pid --socket=/var/lib/mysql/mysql.sock --port=3306 root 7672 4519 0 15:02 pts/0 00:00:00 grep mysql 数据库目录datadir=/var/lib/mysql pid文件目录：--pid-file=/var/lib/mysql/bigdata01.pid MySQL核心目录 /var/lib/mysql :mysql 安装目录 /usr/share/mysql: 配置文件 /usr/bin：命令目录（mysqladmin、mysqldump等） /etc/init.d/mysql启停脚本 MySQL配置文件 my-huge.cnf 高端服务器 1-2G内存 my-large.cnf 中等规模 my-medium.cnf 一般 my-small.cnf 较小 但是，以上配置文件mysql默认不能识别，默认只能识别/etc/my.cnf，因此需要拷贝一份以上配置文件 [root@192 mysql]# cp /usr/share/mysql/my-huge.cnf /etc/my.cnf注意：mysql5.5默认配置文件/etc/my.cnf；Mysql5.6默认配置文件/etc/mysql-default.cnf mysql字符编码查看字符编码mysql&gt; show variables like &#39;%char%&#39;; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | latin1 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 8 rows in set (0.00 sec) 安装NPPFTP设置—导入—-导入插件 修改字符编码为utf8编辑配置文件vim /etc/my.cnf，追加 [mysql] default-character-set=utf8 [client] default-character-set=utf8 [mysqld] character_set_server=utf8 character_set_client=utf8 collation_server=utf8_general_ci再次查看字符编码 mysql&gt; show variables like &#39;%char%&#39;; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 8 rows in set (0.00 sec) 清屏 Ctrl+L system clear SQL语句查询步步深入：MySQL架构总览-&gt;查询执行流程-&gt;SQL解析顺序 - AnnsShadoW - 博客园 语法顺序 SELECT FROM LEFT JOIN ON WHERE GROUP BY HAVING ORDER BY LIMIT 执行顺序SELECT * FROM user LEFT JOIN order ON user.id = order.uid WHERE order.price > 1000 GROUP BY user.name HAVING count(1) > 5 ORDER BY user.name LIMIT 0,10 FROM（将最近的两张表，进行笛卡尔积），得到临时结果集VT1 ON（将VT1按照它的条件进行过滤）—VT2 LEFT JOIN（保留左表的记录）—VT3 WHERE（过滤VT3中的记录）–VT4…VTn GROUP BY（对VT4的记录进行分组）—VT5 HAVING（对VT5中的记录进行过滤）—VT6 SELECT（对VT6中的记录，选取指定的列）–VT7 ORDER BY（对VT7的记录进行排序）–游标 LIMIT（对排序之后的值进行分页） WHERE条件执行顺序（影响性能） MYSQL：从左往右去执行WHERE条件的。 Oracle：从右往左去执行WHERE条件的。 结论：写WHERE条件的时候，优先级高的部分要去编写过滤力度最大的条件语句。 多表之间关系一对一一对多从表是：分类表。从表中，应该有一个字段去关联主表，而这个关联字段就是主键。 主表是：商品表。主表中，应该有一个字段去关联从表，而这个关联字段就是外键。 在互联网项目中，一般情况下，不建议建立外键关系。 多对多 双向的一对多 存储引擎 存储引擎是针对表的,MySQL 5.5之后，默认的存储引擎由MyISAM变为InnoDB。 查询数据库支持哪些引擎 mysql&gt; show engines; +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | Engine | Support | Comment | Transactions | XA | Savepoints | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO | | MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO | | CSV | YES | CSV storage engine | NO | NO | NO | | BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO | | MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO | | InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES | | ARCHIVE | YES | Archive storage engine | NO | NO | NO | | MyISAM | YES | MyISAM storage engine | NO | NO | NO | | FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ 9 rows in set (0.00 sec) 查看当前使用的引擎mysql&gt; show variables like &#39;%storage_engine%&#39; ; +------------------------+--------+ | Variable_name | Value | +------------------------+--------+ | default_storage_engine | InnoDB | | storage_engine | InnoDB | +------------------------+--------+ 2 rows in set (0.00 sec) 指定数据库对象的引擎 create table tb( id int(4) auto_increment , name varchar(5), dept varchar(5) , primary key(id) )ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ; 日志文件、数据文件日志位置mysql&gt; SHOW GLOBAL VARIABLES LIKE &#39;%log%&#39;; +-----------------------------------------+----------------------------------+ | Variable_name | Value | +-----------------------------------------+----------------------------------+ | back_log | 50 | | binlog_cache_size | 32768 | | binlog_direct_non_transactional_updates | OFF | | binlog_format | MIXED | | binlog_stmt_cache_size | 32768 | | expire_logs_days | 0 | | general_log | OFF | | general_log_file | /var/lib/mysql/192.log | | innodb_flush_log_at_trx_commit | 1 | | innodb_locks_unsafe_for_binlog | OFF | | innodb_log_buffer_size | 8388608 | | innodb_log_file_size | 5242880 | | innodb_log_files_in_group | 2 | | innodb_log_group_home_dir | ./ | | innodb_mirrored_log_groups | 1 | | log | OFF | | log_bin | ON | | log_bin_trust_function_creators | OFF | | log_error | /var/lib/mysql/192.168.1.101.err | | log_output | FILE | | log_queries_not_using_indexes | OFF | | log_slave_updates | OFF | | log_slow_queries | OFF | | log_warnings | 1 | | max_binlog_cache_size | 18446744073709547520 | | max_binlog_size | 1073741824 | | max_binlog_stmt_cache_size | 18446744073709547520 | | max_relay_log_size | 0 | | relay_log | | | relay_log_index | | | relay_log_info_file | relay-log.info | | relay_log_purge | ON | | relay_log_recovery | OFF | | relay_log_space_limit | 0 | | slow_query_log | OFF | | slow_query_log_file | /var/lib/mysql/192-slow.log | | sql_log_bin | ON | | sql_log_off | OFF | | sync_binlog | 0 | | sync_relay_log | 0 | | sync_relay_log_info | 0 | +-----------------------------------------+----------------------------------+ 41 rows in set (0.00 sec) 二进制日志 记录了数据库所有的ddl语句和dml语句，但不包括select语句内容 用于恢复数据 mysql&gt; SHOW VARIABLES LIKE &#39;log_bin%&#39;; +---------------------------------+-------+ | Variable_name | Value | +---------------------------------+-------+ | log_bin | ON | | log_bin_trust_function_creators | OFF | +---------------------------------+-------+ 2 rows in set (0.00 sec)错误日志mysql&gt; SHOW VARIABLES LIKE &#39;log_error%&#39;; +---------------+----------------------------------+ | Variable_name | Value | +---------------+----------------------------------+ | log_error | /var/lib/mysql/192.168.1.101.err | +---------------+----------------------------------+ 1 row in set (0.00 sec)查询日志mysql&gt; SHOW VARIABLES LIKE &#39;general_log%&#39;; +------------------+------------------------+ | Variable_name | Value | +------------------+------------------------+ | general_log | OFF | | general_log_file | /var/lib/mysql/192.log | +------------------+------------------------+ 2 rows in set (0.00 sec)慢查询日志mysql&gt; SHOW VARIABLES LIKE &#39;slow_query_log%&#39;; +---------------------+-----------------------------+ | Variable_name | Value | +---------------------+-----------------------------+ | slow_query_log | OFF | | slow_query_log_file | /var/lib/mysql/192-slow.log | +---------------------+-----------------------------+ 2 rows in set (0.00 sec) mysql&gt; SHOW VARIABLES LIKE &#39;long_query_time%&#39;; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.000000 | +-----------------+-----------+ 1 row in set (0.00 sec) 数据位置mysql&gt; SHOW VARIABLES LIKE &#39;%datadir%&#39;; +---------------+-----------------+ | Variable_name | Value | +---------------+-----------------+ | datadir | /var/lib/mysql/ | +---------------+-----------------+ 1 row in set (0.00 sec) SQL优化B-tree - Wikipedia MySQL :: MySQL 5.5 Reference Manual :: 8 Optimization MySQL索引背后的数据结构及算法原理 BTree和B+Tree详解 SQL优化， 主要就是 在优化索引，索引就 相当于书的目录 索引(index)是帮助MYSQL高效获取数据的数据结构。索引是数据结构（树：B树(默认)、Hash树…） B树索引 select * from student where age = 33如果不加索引，从上往下查找需要查找5次，而加了索引，查找的节点处于第三层，所以只需要查找3次 B+Tree Btree数据全部放在叶子节点 分类 主键索引： 不能重复，是一种特殊的唯一索引，不允许有空值 唯一索引 ：不能重复，允许为空值 单值索引 ： 单列， age ;一个表可以多个单值索引,name。 组合索引 ：多个列构成的索引 ，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。 创建索引如果一个字段是主键primary key，则该字段默认就是主键索引,需要注意的是DDL语句会自动提交,我们不需要手动commit 方式一create 索引类型 索引名 on 表(字段) 单值索引 create index dept_index on tb(dept); 唯一索引 create unique index name_index on tb(name) ; 组合索引 create index dept_name_index on tb(dept,name); 方式二alter table 表名 索引类型 索引名（字段） 单值索引 alter table tb add index dept_index(dept) ; 唯一索引 alter table tb add unique index name_index(name); 组合索引 alter table tb add index dept_name_index(dept,name); 删除索引drop index 索引名 on 表名 ; drop index name_index on tb ; 查询索引 show index from 表名 ; show index from 表名 \G mysql> show index from tb; +-------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +-------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | tb | 0 | PRIMARY | 1 | id | A | 0 | NULL | NULL | | BTREE | | | | tb | 1 | dept_index | 1 | dept | A | NULL | NULL | NULL | YES | BTREE | | | +-------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 2 rows in set (0.00 sec) 优势 提高查询效率（降低IO使用率） 降低CPU使用率 （...order by age desc,因为 B树索引 本身就是一个 好排序的结构，因此在排序时 可以直接使用） 弊端 索引本身很大， 可以存放在内存/硬盘（通常为 硬盘） 索引不是所有情况均适用 少量数据 频繁更新的字段 很少使用的字段 索引会降低增删改的效率（增删改 查） 建议 尽量创建组合索引（组合索引其实会默认按照最左前缀原则帮我们创建多组索引） 组合索引（id,name,sex）会帮我们创建多组索引—–&gt;[id],[id,name],[id,sex],[id,name,sex],[name,sex] SQL故障排除 慢查询日志:MySQL提供的一种日志记录，用于记录MySQL种响应时间超过阀值的SQL语句 （long_query_time，默认10秒） 慢查询日志默认是关闭的；建议一般开发调优时是打开，而最终部署时关闭。 性能优化思路 首先需要使用慢查询功能，去获取所有查询时间比较长的SQL语句 其次使用explain命令去查看有问题的SQL的执行计划 最后可以使用show profile[s] 查看有问题的SQL的性能使用情况 查看慢查询临时开启方式一mysql&gt; show variables like &#39;%slow_query_log%&#39; ; +---------------------+-----------------------------+ | Variable_name | Value | +---------------------+-----------------------------+ | slow_query_log | OFF | | slow_query_log_file | /var/lib/mysql/192-slow.log | +---------------------+-----------------------------+ 2 rows in set (0.00 sec) mysql&gt; set global slow_query_log = ON; Query OK, 0 rows affected (0.00 sec) mysql&gt; show variables like &#39;%slow_query_log%&#39; ; +---------------------+-----------------------------+ | Variable_name | Value | +---------------------+-----------------------------+ | slow_query_log | ON | | slow_query_log_file | /var/lib/mysql/192-slow.log | +---------------------+-----------------------------+ 2 rows in set (0.00 sec) 方式二mysql&gt; show variables like &#39;%slow_query_log%&#39; ; +---------------------+-----------------------------+ | Variable_name | Value | +---------------------+-----------------------------+ | slow_query_log | OFF | | slow_query_log_file | /var/lib/mysql/192-slow.log | +---------------------+-----------------------------+ 2 rows in set (0.00 sec) mysql&gt; set global slow_query_log = 1 ; Query OK, 0 rows affected (0.00 sec) mysql&gt; show variables like &#39;%slow_query_log%&#39; ; +---------------------+-----------------------------+ | Variable_name | Value | +---------------------+-----------------------------+ | slow_query_log | ON | | slow_query_log_file | /var/lib/mysql/192-slow.log | +---------------------+-----------------------------+ 2 rows in set (0.00 sec) 永久开启编辑/etc/my.cnf 中追加配置： vi /etc/my.cnf [mysqld] slow_query_log=1 slow_query_log_file=/var/lib/mysql/localhost-slow.log查看慢查询阀值mysql&gt; show variables like &#39;%long_query_time%&#39; ; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.000000 | +-----------------+-----------+ 1 row in set (0.00 sec)临时设置阀值 设置完毕后，重新登陆后起效 （不需要重启服务） mysql&gt; show variables like &#39;%long_query_time%&#39; ; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.000000 | +-----------------+-----------+ 1 row in set (0.00 sec) mysql&gt; set global long_query_time = 5 ; Query OK, 0 rows affected (0.00 sec) mysql&gt; show variables like &#39;%long_query_time%&#39; ; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.000000 | +-----------------+-----------+ 1 row in set (0.00 sec) mysql&gt; exit; Bye [root@192 ~]# mysql -uroot -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 4 Server version: 5.5.48-log MySQL Community Server (GPL) Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement. mysql&gt; show variables like &#39;%long_query_time%&#39; ; +-----------------+----------+ | Variable_name | Value | +-----------------+----------+ | long_query_time | 5.000000 | +-----------------+----------+ 1 row in set (0.00 sec) 永久设置阀值编辑/etc/my.cnf中追加配置： vi /etc/my.cnf [mysqld] long_query_time=3查看SQL执行计划explain +SQL语句 mysql> explain select * from tb ; +----+-------------+-------+--------+---------------+------+---------+------+------+---------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+--------+---------------+------+---------+------+------+---------------------+ | 1 | SIMPLE | tb | system | NULL | NULL | NULL | NULL | 0 | const row not found | +----+-------------+-------+--------+---------------+------+---------+------+------+---------------------+ 1 row in set (0.00 sec) id : 编号 select_type ：查询类型 table ：表 type ：类型 possible_keys ：预测用到的索引 key ：实际使用的索引 key_len ：实际使用索引的长度 ref :表之间的引用 rows ：通过索引查询到的数据量 Extra :额外的信息 表结构 课程表(course) 教师表(teacher) 教师课程描述表(teacherCard) 准备数据create table course ( cid int(3), cname varchar(20), tid int(3) ); create table teacher ( tid int(3), tname varchar(20), tcid int(3) ); create table teacherCard ( tcid int(3), tcdesc varchar(200) ); insert into course values(1,'java',1); insert into course values(2,'html',1); insert into course values(3,'sql',2); insert into course values(4,'web',3); insert into teacher values(1,'tz',1); insert into teacher values(2,'tw',2); insert into teacher values(3,'tl',3); insert into teacherCard values(1,'tzdesc') ; insert into teacherCard values(2,'twdesc') ; insert into teacherCard values(3,'tldesc') ; idid值相同 id值相同，从上往下 顺序执行。 数据小的表优先查询 用wehre连接表之间的关系，表的执行顺序是因数量的个数改变而改变，当教师表新插入3条数据，教师表变成了最后执行的原因是遵循笛卡儿积，尽管3*4*6=72和6*4*3=72最终的条数是一样的，但是它们的中间结果是不一样的，查询3*4=12条效率明显比6*4=24高 查询课程编号为2或教师证编号为3的老师信息 mysql> EXPLAIN select * from teacher t,course c,teacherCard tc where t.tid=c.tid and t.tcid=tc.tcid and (c.cid=2 or tc.tcid=3); +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ | 1 | SIMPLE | t | ALL | NULL | NULL | NULL | NULL | 3 | | | 1 | SIMPLE | tc | ALL | NULL | NULL | NULL | NULL | 3 | Using where; Using join buffer | | 1 | SIMPLE | c | ALL | NULL | NULL | NULL | NULL | 4 | Using where; Using join buffer | +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ 3 rows in set (0.00 sec) mysql> insert into teacher values(4,'ts',2); Query OK, 1 row affected (0.01 sec) mysql> insert into teacher values(5,'tw',3); Query OK, 1 row affected (0.01 sec) mysql> insert into teacher values(6,'tl',3); Query OK, 1 row affected (0.00 sec) mysql> EXPLAIN select * from teacher t,course c,teacherCard tc where t.tid=c.tid and t.tcid=tc.tcid and (c.cid=2 or tc.tcid=3); +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ | 1 | SIMPLE | tc | ALL | NULL | NULL | NULL | NULL | 3 | | | 1 | SIMPLE | c | ALL | NULL | NULL | NULL | NULL | 4 | Using where; Using join buffer | | 1 | SIMPLE | t | ALL | NULL | NULL | NULL | NULL | 6 | Using where; Using join buffer | +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ 3 rows in set (0.00 sec) id值不同 id值越大越优先查询 (本质上在嵌套子查询时，先查内层 再查外层) 查询教授SQL课程的老师的描述（desc） mysql> explain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid -> and t.tcid = tc.tcid and c.cname = 'sql' ; +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ | 1 | SIMPLE | tc | ALL | NULL | NULL | NULL | NULL | 3 | | | 1 | SIMPLE | c | ALL | NULL | NULL | NULL | NULL | 4 | Using where; Using join buffer | | 1 | SIMPLE | t | ALL | NULL | NULL | NULL | NULL | 6 | Using where; Using join buffer | +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ 3 rows in set (0.01 sec) mysql> explain select tc.tcdesc from teacherCard tc where tc.tcid = -> (select t.tcid from teacher t where t.tid = -> (select c.tid from course c where c.cname = 'sql') -> ); +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ | 1 | PRIMARY | tc | ALL | NULL | NULL | NULL | NULL | 3 | Using where | | 2 | SUBQUERY | t | ALL | NULL | NULL | NULL | NULL | 6 | Using where | | 3 | SUBQUERY | c | ALL | NULL | NULL | NULL | NULL | 4 | Using where | +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ 3 rows in set (0.00 sec) id值有相同，又有不同 id值越大越优先；id值相同，从上往下 顺序执行 子查询+多表 mysql> explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc where t.tcid= tc.tcid -> and t.tid = (select c.tid from course c where cname = 'sql') ; +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ | 1 | PRIMARY | tc | ALL | NULL | NULL | NULL | NULL | 3 | | | 1 | PRIMARY | t | ALL | NULL | NULL | NULL | NULL | 6 | Using where; Using join buffer | | 2 | SUBQUERY | c | ALL | NULL | NULL | NULL | NULL | 4 | Using where | +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ 3 rows in set (0.00 sec) select_type查询类型 PRIMARY:包含子查询SQL中的 主查询 （最外层） SUBQUERY：包含子查询SQL中的 子查询 （非最外层） simple:简单查询（不包含子查询、union） derived:衍生查询(使用到了临时表) 在from子查询中只有一张表 mysql> explain select cr.cname from ( select * from course where tid in (1,2) ) cr ; +----+-------------+------------+------+---------------+------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+------+---------------+------+---------+------+------+-------------+ | 1 | PRIMARY | &lt;derived2> | ALL | NULL | NULL | NULL | NULL | 3 | | | 2 | DERIVED | course | ALL | NULL | NULL | NULL | NULL | 4 | Using where | +----+-------------+------------+------+---------------+------+---------+------+------+-------------+ 2 rows in set (0.00 sec) 在from子查询中， 如果有table1 union table2 ，则table1 就是derived,table2就是union mysql> explain select cr.cname from ( select * from course where tid = 1 union select * from course where tid = 2 ) cr ; +----+--------------+------------+------+---------------+------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+--------------+------------+------+---------------+------+---------+------+------+-------------+ | 1 | PRIMARY | &lt;derived2> | ALL | NULL | NULL | NULL | NULL | 3 | | | 2 | DERIVED | course | ALL | NULL | NULL | NULL | NULL | 4 | Using where | | 3 | UNION | course | ALL | NULL | NULL | NULL | NULL | 4 | Using where | | NULL | UNION RESULT | &lt;union2,3> | ALL | NULL | NULL | NULL | NULL | NULL | | +----+--------------+------------+------+---------------+------+---------+------+------+-------------+ 4 rows in set (0.00 sec) union:上例 union result :告知开发人员，那些表之间存在union查询 type索引类型、类型 对type进行优化的前提：有索引 system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 比较常见的system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all,其中system,const只是理想情况；实际能达到 的是ref&gt;range system 可以忽略: 只有一条数据的系统表 ；或 衍生表只有一条数据的主查询 mysql> create table test01 -> ( -> tid int(3), -> tname varchar(20) -> ); Query OK, 0 rows affected (0.01 sec) mysql> mysql> insert into test01 values(1,'a') ; Query OK, 1 row affected (0.00 sec) mysql> commit; Query OK, 0 rows affected (0.00 sec) mysql> show tables; +---------------+ | Tables_in_kkb | +---------------+ | course | | lock | | tb | | teacher | | teacherCard | | test01 | | user | +---------------+ 7 rows in set (0.00 sec) mysql> alter table test01 add constraint tid_pk primary key(tid) ; Query OK, 1 row affected (0.02 sec) Records: 1 Duplicates: 0 Warnings: 0 mysql> explain select * from (select * from test01 )t where tid =1 ; +----+-------------+------------+--------+---------------+------+---------+------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+--------+---------------+------+---------+------+------+-------+ | 1 | PRIMARY | &lt;derived2> | system | NULL | NULL | NULL | NULL | 1 | | | 2 | DERIVED | test01 | ALL | NULL | NULL | NULL | NULL | 1 | | +----+-------------+------------+--------+---------------+------+---------+------+------+-------+ 2 rows in set (0.00 sec) const仅仅能查到一条数据的SQL ,用于Primary key或unique索引 （类型 与索引类型有关） mysql> explain select tid from test01 where tid =1 ; +----+-------------+--------+-------+---------------+---------+---------+-------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+---------+---------+-------+------+-------------+ | 1 | SIMPLE | test01 | const | PRIMARY | PRIMARY | 4 | const | 1 | Using index | +----+-------------+--------+-------+---------------+---------+---------+-------+------+-------------+ 1 row in set (0.00 sec) mysql> alter table test01 drop primary key ; Query OK, 1 row affected (0.02 sec) Records: 1 Duplicates: 0 Warnings: 0 mysql> explain select tid from test01 where tid =1 ; +----+-------------+--------+------+---------------+------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+------+---------+------+------+-------------+ | 1 | SIMPLE | test01 | ALL | NULL | NULL | NULL | NULL | 1 | Using where | +----+-------------+--------+------+---------------+------+---------+------+------+-------------+ 1 row in set (0.00 sec) mysql> create index test01_index on test01(tid) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> explain select tid from test01 where tid =1 ; +----+-------------+--------+------+---------------+--------------+---------+-------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+--------------+---------+-------+------+-------------+ | 1 | SIMPLE | test01 | ref | test01_index | test01_index | 4 | const | 1 | Using index | +----+-------------+--------+------+---------------+--------------+---------+-------+------+-------------+ 1 row in set (0.00 sec) #### eq_ref 唯一性索引：对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多 、不能0） ```sql mysql&gt; select * from teacher; +------+-------+------+ | tid | tname | tcid | +------+-------+------+ | 1 | tz | 1 | | 2 | tw | 2 | | 3 | tl | 3 | +------+-------+------+ 3 rows in set (0.00 sec) mysql&gt; select * from teacherCard; +------+--------+ | tcid | tcdesc | +------+--------+ | 1 | tzdesc | | 2 | twdesc | | 3 | tldesc | +------+--------+ 3 rows in set (0.00 sec) mysql&gt; explain select t.tcid from teacher t,teacherCard tc where t.tcid = tc.tcid ; +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ | 1 | SIMPLE | t | ALL | NULL | NULL | NULL | NULL | 3 | | | 1 | SIMPLE | tc | ALL | NULL | NULL | NULL | NULL | 3 | Using where; Using join buffer | +----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+ 2 rows in set (0.00 sec) mysql&gt; alter table teacherCard add constraint pk_tcid primary key(tcid); Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; alter table teacher add constraint uk_tcid unique index(tcid) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; explain select t.tcid from teacher t,teacherCard tc where t.tcid = tc.tcid ; +----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+ | 1 | SIMPLE | t | index | uk_tcid | uk_tcid | 5 | NULL | 3 | Using index | | 1 | SIMPLE | tc | eq_ref | PRIMARY | PRIMARY | 4 | kkb.t.tcid | 1 | Using index | +----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+ 2 rows in set (0.00 sec) 以上`SQL`，用到的索引是 `t.tcid`,即`teacher`表中的`tcid`字段； 如果`teacher`表的数据个数 和 连接查询的数据个数一致（都是3条数据），则有可能满足`eq_ref`级别；否则无法满足。 #### ref 非唯一性索引，对于每个索引键的查询，返回匹配的所有行（0行或者多行） ```sql mysql&gt; insert into teacher values(4,&#39;tz&#39;,4) ; Query OK, 1 row affected (0.00 sec) mysql&gt; insert into teacherCard values(4,&#39;tz222&#39;); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from teacher; +------+-------+------+ | tid | tname | tcid | +------+-------+------+ | 1 | tz | 1 | | 2 | tw | 2 | | 3 | tl | 3 | | 4 | tz | 4 | +------+-------+------+ 4 rows in set (0.00 sec) mysql&gt; select * from teacherCard; +------+--------+ | tcid | tcdesc | +------+--------+ | 1 | tzdesc | | 2 | twdesc | | 3 | tldesc | | 4 | tz222 | +------+--------+ 4 rows in set (0.00 sec) mysql&gt; alter table teacher add index index_name (tname) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; explain select * from teacher where tname = &#39;tz&#39;; +----+-------------+---------+------+---------------+------------+---------+-------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+---------+------+---------------+------------+---------+-------+------+-------------+ | 1 | SIMPLE | teacher | ref | index_name | index_name | 63 | const | 2 | Using where | +----+-------------+---------+------+---------------+------------+---------+-------+------+-------------+ 1 row in set (0.00 sec) range检索指定范围的行 ,where后面是一个范围查询 between &lt; &gt;= 特殊的情况，in有时候会失效 ，从而转为 无索引，进行全表扫描all) mysql> alter table teacher add index tid_index (tid) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> select * from teacher; +------+-------+------+ | tid | tname | tcid | +------+-------+------+ | 1 | tz | 1 | | 2 | tw | 2 | | 3 | tl | 3 | | 4 | tz | 4 | +------+-------+------+ 4 rows in set (0.00 sec) mysql> show index from teacher; +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | teacher | 0 | uk_tcid | 1 | tcid | A | 4 | NULL | NULL | YES | BTREE | | | | teacher | 1 | index_name | 1 | tname | A | 4 | NULL | NULL | YES | BTREE | | | | teacher | 1 | tid_index | 1 | tid | A | 4 | NULL | NULL | YES | BTREE | | | +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 3 rows in set (0.00 sec) mysql> explain select t.* from teacher t where t.tid in (1,2) ; +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ | 1 | SIMPLE | t | ALL | tid_index | NULL | NULL | NULL | 4 | Using where | +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ 1 row in set (0.00 sec) mysql> explain select t.* from teacher t where t.tid &lt;3 ; +----+-------------+-------+-------+---------------+-----------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+-------+---------------+-----------+---------+------+------+-------------+ | 1 | SIMPLE | t | range | tid_index | tid_index | 5 | NULL | 1 | Using where | +----+-------------+-------+-------+---------------+-----------+---------+------+------+-------------+ 1 row in set (0.00 sec) index查询全部索引中数据，tid 是索引， 只需要扫描索引表，不需要所有表中的所有数据 mysql> show index from teacher; +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | teacher | 0 | uk_tcid | 1 | tcid | A | 4 | NULL | NULL | YES | BTREE | | | | teacher | 1 | index_name | 1 | tname | A | 4 | NULL | NULL | YES | BTREE | | | | teacher | 1 | tid_index | 1 | tid | A | 4 | NULL | NULL | YES | BTREE | | | +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 3 rows in set (0.00 sec) mysql> select * from teacher; +------+-------+------+ | tid | tname | tcid | +------+-------+------+ | 1 | tz | 1 | | 2 | tw | 2 | | 3 | tl | 3 | | 4 | tz | 4 | +------+-------+------+ 4 rows in set (0.00 sec) mysql> explain select tid from teacher; +----+-------------+---------+-------+---------------+-----------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+---------+-------+---------------+-----------+---------+------+------+-------------+ | 1 | SIMPLE | teacher | index | NULL | tid_index | 5 | NULL | 4 | Using index | +----+-------------+---------+-------+---------------+-----------+---------+------+------+-------------+ 1 row in set (0.00 sec) all查询全部表中的数据 mysql> show index from course; Empty set (0.00 sec) mysql> select * from course; +------+-------+------+ | cid | cname | tid | +------+-------+------+ | 1 | java | 1 | | 2 | html | 1 | | 3 | sql | 2 | | 4 | web | 3 | +------+-------+------+ 4 rows in set (0.00 sec) mysql> explain select * from course; +----+-------------+--------+------+---------------+------+---------+------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+------+---------+------+------+-------+ | 1 | SIMPLE | course | ALL | NULL | NULL | NULL | NULL | 4 | | +----+-------------+--------+------+---------------+------+---------+------+------+-------+ 1 row in set (0.00 sec) possible_keys可能用到的索引，是一种预测，不准 mysql&gt; alter table course add index cname_index (cname); Query OK, 0 rows affected (0.04 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; select * from course; +------+-------+------+ | cid | cname | tid | +------+-------+------+ | 1 | java | 1 | | 2 | html | 1 | | 3 | sql | 2 | | 4 | web | 3 | +------+-------+------+ 4 rows in set (0.00 sec) mysql&gt; show index from course; +--------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +--------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | course | 1 | cname_index | 1 | cname | A | 4 | NULL | NULL | YES | BTREE | | | +--------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 1 row in set (0.00 sec) mysql&gt; show index from teacher; +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | teacher | 0 | uk_tcid | 1 | tcid | A | 4 | NULL | NULL | YES | BTREE | | | | teacher | 1 | index_name | 1 | tname | A | 4 | NULL | NULL | YES | BTREE | | | | teacher | 1 | tid_index | 1 | tid | A | 4 | NULL | NULL | YES | BTREE | | | +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 3 rows in set (0.00 sec) mysql&gt; show index from teacherCard; +-------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +-------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | teacherCard | 0 | PRIMARY | 1 | tcid | A | 4 | NULL | NULL | | BTREE | | | +-------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 1 row in set (0.00 sec) mysql&gt; explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc -&gt; where t.tcid= tc.tcid -&gt; and t.tid = (select c.tid from course c where cname = &#39;sql&#39;) ; +----+-------------+-------+--------+-------------------+-------------+---------+------------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+--------+-------------------+-------------+---------+------------+------+-------------+ | 1 | PRIMARY | t | ref | uk_tcid,tid_index | tid_index | 5 | const | 1 | Using where | | 1 | PRIMARY | tc | eq_ref | PRIMARY | PRIMARY | 4 | kkb.t.tcid | 1 | | | 2 | SUBQUERY | c | ref | cname_index | cname_index | 63 | | 1 | Using where | +----+-------------+-------+--------+-------------------+-------------+---------+------------+------+-------------+ 3 rows in set (0.00 sec) 如果 possible_key/key是NULL，则说明没用索引 mysql> explain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid -> and t.tcid = tc.tcid and c.cname = 'sql' ; +----+-------------+-------+--------+-------------------+-------------+---------+------------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+--------+-------------------+-------------+---------+------------+------+-------------+ | 1 | SIMPLE | c | ref | cname_index | cname_index | 63 | const | 1 | Using where | | 1 | SIMPLE | t | ref | uk_tcid,tid_index | tid_index | 5 | kkb.c.tid | 1 | Using where | | 1 | SIMPLE | tc | eq_ref | PRIMARY | PRIMARY | 4 | kkb.t.tcid | 1 | | +----+-------------+-------+--------+-------------------+-------------+---------+------------+------+-------------+ 3 rows in set (0.00 sec) mysql> drop index cname_index on course; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> explain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid and t.tcid = tc.tcid and c.cname = 'sql'; +----+-------------+-------+--------+-------------------+---------+---------+------------+------+--------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+--------+-------------------+---------+---------+------------+------+--------------------------------+ | 1 | SIMPLE | c | ALL | NULL | NULL | NULL | NULL | 4 | Using where | | 1 | SIMPLE | t | ALL | uk_tcid,tid_index | NULL | NULL | NULL | 4 | Using where; Using join buffer | | 1 | SIMPLE | tc | eq_ref | PRIMARY | PRIMARY | 4 | kkb.t.tcid | 1 | | +----+-------------+-------+--------+-------------------+---------+---------+------------+------+--------------------------------+ 3 rows in set (0.00 sec) key实际使用到的索引 key_len utf8:1个字符3个字节 gbk:1个字符2个字节 latin:1个字符1个字节 索引的长度, 用于判断复合索引是否被完全使用,key_len为60，在utf8：1个字符占3个字节 mysql> create table test_kl -> ( -> name char(20) not null default '' -> ); Query OK, 0 rows affected (0.01 sec) mysql> alter table test_kl add index index_name(name) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> explain select * from test_kl where name ='' ; +----+-------------+---------+------+---------------+------------+---------+-------+------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+---------+------+---------------+------------+---------+-------+------+--------------------------+ | 1 | SIMPLE | test_kl | ref | index_name | index_name | 60 | const | 1 | Using where; Using index | +----+-------------+---------+------+---------------+------------+---------+-------+------+--------------------------+ 1 row in set (0.01 sec) 如果索引字段可以为Null,则会使用1个字节用于标识。因此key_len为61 mysql> alter table test_kl add column name1 char(20) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> alter table test_kl add index index_name1(name1) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> explain select * from test_kl where name1 ='' ; +----+-------------+---------+------+---------------+-------------+---------+-------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+---------+------+---------------+-------------+---------+-------+------+-------------+ | 1 | SIMPLE | test_kl | ref | index_name1 | index_name1 | 61 | const | 1 | Using where | +----+-------------+---------+------+---------------+-------------+---------+-------+------+-------------+ 1 row in set (0.00 sec) 增加一个复合索引 ,根据最左前缀原则，两次key_len分别为121和60 mysql> drop index index_name on test_kl ; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> drop index index_name1 on test_kl ; Query OK, 0 rows affected (0.00 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> alter table test_kl add index name_name1_index (name,name1) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> show index from test_kl; +---------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +---------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | test_kl | 1 | name_name1_index | 1 | name | A | 0 | NULL | NULL | | BTREE | | | | test_kl | 1 | name_name1_index | 2 | name1 | A | 0 | NULL | NULL | YES | BTREE | | | +---------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 2 rows in set (0.00 sec) mysql> explain select * from test_kl where name1 = '' ; +----+-------------+---------+-------+---------------+------------------+---------+------+------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+---------+-------+---------------+------------------+---------+------+------+--------------------------+ | 1 | SIMPLE | test_kl | index | NULL | name_name1_index | 121 | NULL | 1 | Using where; Using index | +----+-------------+---------+-------+---------------+------------------+---------+------+------+--------------------------+ 1 row in set (0.00 sec) mysql> explain select * from test_kl where name = '' ; +----+-------------+---------+------+------------------+------------------+---------+-------+------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+---------+------+------------------+------------------+---------+-------+------+--------------------------+ | 1 | SIMPLE | test_kl | ref | name_name1_index | name_name1_index | 60 | const | 1 | Using where; Using index | +----+-------------+---------+------+------------------+------------------+---------+-------+------+--------------------------+ 1 row in set (0.00 sec) 索引字段为可变varchar类型,用2个字节 标识可变长度,1字节标识Null,因此20*3=60 + 1(null) +2(用2个字节 标识可变长度) =63 mysql> alter table test_kl add column name2 varchar(20) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> alter table test_kl add index name2_index (name2) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> explain select * from test_kl where name2 = '' ; +----+-------------+---------+------+---------------+-------------+---------+-------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+---------+------+---------------+-------------+---------+-------+------+-------------+ | 1 | SIMPLE | test_kl | ref | name2_index | name2_index | 63 | const | 1 | Using where | +----+-------------+---------+------+---------------+-------------+---------+-------+------+-------------+ 1 row in set (0.00 sec) ref表之间的引用，注意与type中的ref值区分 指明当前表所参照的字段select ....where a.c = b.x ;(其中b.x可以是常量，const) mysql> desc course; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | cid | int(3) | YES | | NULL | | | cname | varchar(20) | YES | | NULL | | | tid | int(3) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 3 rows in set (0.00 sec) mysql> alter table course add index tid_index (tid) ; Query OK, 0 rows affected (0.04 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> explain select * from course c,teacher t where c.tid = t.tid and t.tname ='tw' ; +----+-------------+-------+------+----------------------+------------+---------+-----------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+----------------------+------------+---------+-----------+------+-------------+ | 1 | SIMPLE | t | ref | index_name,tid_index | index_name | 63 | const | 1 | Using where | | 1 | SIMPLE | c | ref | tid_index | tid_index | 5 | kkb.t.tid | 1 | Using where | +----+-------------+-------+------+----------------------+------------+---------+-----------+------+-------------+ 2 rows in set (0.00 sec) rows被索引优化查询的 数据个数 (实际通过索引而查询到的 数据个数) mysql> select * from course; +------+-------+------+ | cid | cname | tid | +------+-------+------+ | 1 | java | 1 | | 2 | html | 1 | | 3 | sql | 2 | | 4 | web | 3 | +------+-------+------+ 4 rows in set (0.00 sec) mysql> select * from teacher; +------+-------+------+ | tid | tname | tcid | +------+-------+------+ | 1 | tz | 1 | | 2 | tw | 2 | | 3 | tl | 3 | | 4 | tz | 4 | +------+-------+------+ 4 rows in set (0.00 sec) mysql> show index from course; +--------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +--------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | course | 1 | tid_index | 1 | tid | A | 4 | NULL | NULL | YES | BTREE | | | +--------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 1 row in set (0.00 sec) mysql> show index from teacher; +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | teacher | 0 | uk_tcid | 1 | tcid | A | 4 | NULL | NULL | YES | BTREE | | | | teacher | 1 | index_name | 1 | tname | A | 4 | NULL | NULL | YES | BTREE | | | | teacher | 1 | tid_index | 1 | tid | A | 4 | NULL | NULL | YES | BTREE | | | +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 3 rows in set (0.00 sec) mysql> select * from course c,teacher t where c.tid = t.tid and t.tname = 'tz'; +------+-------+------+------+-------+------+ | cid | cname | tid | tid | tname | tcid | +------+-------+------+------+-------+------+ | 1 | java | 1 | 1 | tz | 1 | | 2 | html | 1 | 1 | tz | 1 | +------+-------+------+------+-------+------+ 2 rows in set (0.00 sec) mysql> explain select * from course c,teacher t where c.tid = t.tid and t.tname = 'tz'; +----+-------------+-------+------+----------------------+------------+---------+-----------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+----------------------+------------+---------+-----------+------+-------------+ | 1 | SIMPLE | t | ref | index_name,tid_index | index_name | 63 | const | 2 | Using where | | 1 | SIMPLE | c | ref | tid_index | tid_index | 5 | kkb.t.tid | 1 | Using where | +----+-------------+-------+------+----------------------+------------+---------+-----------+------+-------------+ 2 rows in set (0.00 sec) Extrausing filesortusing filesort ： 性能消耗大；需要“额外”的一次排序（查询） 。常见于 order by 语句中。 对于单索引， 如果排序和查找是同一个字段，则不会出现using filesort；如果排序和查找不是同一个字段，则会出现using filesort；，平常使用的话，where哪些字段，就order by那些字段 mysql> create table test02 -> ( -> a1 char(3), -> a2 char(3), -> a3 char(3), -> index idx_a1(a1), -> index idx_a2(a2), -> index idx_a3(a3) -> ); Query OK, 0 rows affected (0.01 sec) mysql> select * from test02 where a1 ='' order by a1 ; Empty set (0.00 sec) mysql> explain select * from test02 where a1 ='' order by a1 ; +----+-------------+--------+------+---------------+--------+---------+-------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+--------+---------+-------+------+-------------+ | 1 | SIMPLE | test02 | ref | idx_a1 | idx_a1 | 10 | const | 1 | Using where | +----+-------------+--------+------+---------------+--------+---------+-------+------+-------------+ 1 row in set (0.00 sec) mysql> explain select * from test02 where a1 ='' order by a2 ; +----+-------------+--------+------+---------------+--------+---------+-------+------+-----------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+--------+---------+-------+------+-----------------------------+ | 1 | SIMPLE | test02 | ref | idx_a1 | idx_a1 | 10 | const | 1 | Using where; Using filesort | +----+-------------+--------+------+---------------+--------+---------+-------+------+-----------------------------+ 1 row in set (0.00 sec) 复合索引：不能跨列（最佳左前缀），where和order by按照复合索引的顺序使用，不要跨列或无序使用。 mysql> drop index idx_a1 on test02; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> drop index idx_a2 on test02; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> drop index idx_a3 on test02; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> mysql> alter table test02 add index idx_a1_a2_a3 (a1,a2,a3) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> show index from test02; +--------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +--------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | test02 | 1 | idx_a1_a2_a3 | 1 | a1 | A | 0 | NULL | NULL | YES | BTREE | | | | test02 | 1 | idx_a1_a2_a3 | 2 | a2 | A | 0 | NULL | NULL | YES | BTREE | | | | test02 | 1 | idx_a1_a2_a3 | 3 | a3 | A | 0 | NULL | NULL | YES | BTREE | | | +--------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 3 rows in set (0.00 sec) mysql> explain select *from test02 where a1='' order by a3 ; +----+-------------+--------+------+---------------+--------------+---------+-------+------+------------------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+--------------+---------+-------+------+------------------------------------------+ | 1 | SIMPLE | test02 | ref | idx_a1_a2_a3 | idx_a1_a2_a3 | 10 | const | 1 | Using where; Using index; Using filesort | +----+-------------+--------+------+---------------+--------------+---------+-------+------+------------------------------------------+ 1 row in set (0.00 sec) mysql> explain select *from test02 where a2='' order by a3 ; +----+-------------+--------+-------+---------------+--------------+---------+------+------+------------------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+--------------+---------+------+------+------------------------------------------+ | 1 | SIMPLE | test02 | index | NULL | idx_a1_a2_a3 | 30 | NULL | 1 | Using where; Using index; Using filesort | +----+-------------+--------+-------+---------------+--------------+---------+------+------+------------------------------------------+ 1 row in set (0.00 sec) mysql> explain select *from test02 where a1='' order by a2 ; +----+-------------+--------+------+---------------+--------------+---------+-------+------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+--------------+---------+-------+------+--------------------------+ | 1 | SIMPLE | test02 | ref | idx_a1_a2_a3 | idx_a1_a2_a3 | 10 | const | 1 | Using where; Using index | +----+-------------+--------+------+---------------+--------------+---------+-------+------+--------------------------+ 1 row in set (0.00 sec) mysql> explain select *from test02 where a2='' order by a1 ; +----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+ | 1 | SIMPLE | test02 | index | NULL | idx_a1_a2_a3 | 30 | NULL | 1 | Using where; Using index | +----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+ 1 row in set (0.00 sec) using temporaryusing temporary:性能损耗大 ，用到了临时表。一般出现在group by 语句中。 查询那些列，就根据那些列 group by mysql> explain select a1 from test02 where a1 in ('1','2','3') group by a1 ; +----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+ | 1 | SIMPLE | test02 | index | idx_a1_a2_a3 | idx_a1_a2_a3 | 30 | NULL | 1 | Using where; Using index | +----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+ 1 row in set (0.00 sec) mysql> explain select a1 from test02 where a1 in ('1','2','3') group by a2 ; +----+-------------+--------+-------+---------------+--------------+---------+------+------+-----------------------------------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+--------------+---------+------+------+-----------------------------------------------------------+ | 1 | SIMPLE | test02 | index | idx_a1_a2_a3 | idx_a1_a2_a3 | 30 | NULL | 1 | Using where; Using index; Using temporary; Using filesort | +----+-------------+--------+-------+---------------+--------------+---------+------+------+-----------------------------------------------------------+ 1 row in set (0.00 sec) using index性能提升; 索引覆盖（覆盖索引）。原因：不读取原文件，只从索引文件中获取数据 （不需要回表查询） mysql> show index from test02; +--------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +--------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | test02 | 1 | idx_a1_a2_a3 | 1 | a1 | A | 0 | NULL | NULL | YES | BTREE | | | | test02 | 1 | idx_a1_a2_a3 | 2 | a2 | A | 0 | NULL | NULL | YES | BTREE | | | | test02 | 1 | idx_a1_a2_a3 | 3 | a3 | A | 0 | NULL | NULL | YES | BTREE | | | +--------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 3 rows in set (0.01 sec) mysql> explain select a1,a2 from test02 where a1='' or a2= '' ; +----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+ | 1 | SIMPLE | test02 | index | idx_a1_a2_a3 | idx_a1_a2_a3 | 30 | NULL | 1 | Using where; Using index | +----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+ 1 row in set (0.00 sec) mysql> drop index idx_a1_a2_a3 on test02; Query OK, 0 rows affected (0.00 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> alter table test02 add index idx_a1_a2(a1,a2) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> explain select a1,a3 from test02 where a1='' or a3= '' ; +----+-------------+--------+------+---------------+------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+------+---------+------+------+-------------+ | 1 | SIMPLE | test02 | ALL | idx_a1_a2 | NULL | NULL | NULL | 1 | Using where | +----+-------------+--------+------+---------------+------+---------+------+------+-------------+ 1 row in set (0.00 sec) 如果用到了索引覆盖(using index时)，会对possible_keys和key造成影响： 如果没有where，则索引只出现在key中；如果有where，则索引 出现在key和possible_keys中。 mysql> explain select a1,a2 from test02 where a1='' or a2= '' ; +----+-------------+--------+-------+---------------+-----------+---------+------+------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+-----------+---------+------+------+--------------------------+ | 1 | SIMPLE | test02 | index | idx_a1_a2 | idx_a1_a2 | 20 | NULL | 1 | Using where; Using index | +----+-------------+--------+-------+---------------+-----------+---------+------+------+--------------------------+ 1 row in set (0.00 sec) mysql> mysql> explain select a1,a2 from test02 ; +----+-------------+--------+-------+---------------+-----------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+-----------+---------+------+------+-------------+ | 1 | SIMPLE | test02 | index | NULL | idx_a1_a2 | 20 | NULL | 1 | Using index | +----+-------------+--------+-------+---------------+-----------+---------+------+------+-------------+ 1 row in set (0.00 sec) 查看SQL性能使用情况mysql&gt; select @@profiling; +-------------+ | @@profiling | +-------------+ | 0 | +-------------+ 1 row in set (0.00 sec) mysql&gt; set profiling=1; Query OK, 0 rows affected (0.00 sec) mysql&gt; select @@profiling; +-------------+ | @@profiling | +-------------+ | 1 | +-------------+ 1 row in set (0.00 sec) mysql&gt; select sleep(20); +-----------+ | sleep(20) | +-----------+ | 0 | +-----------+ 1 row in set (20.00 sec) mysql&gt; show profiles; +----------+-------------+--------------------+ | Query_ID | Duration | Query | +----------+-------------+--------------------+ | 1 | 0.00007700 | select @@profiling | | 2 | 20.00080200 | select sleep(20) | +----------+-------------+--------------------+ 2 rows in set (0.00 sec) mysql&gt; show profile; +----------------------+-----------+ | Status | Duration | +----------------------+-----------+ | starting | 0.000033 | | checking permissions | 0.000002 | | Opening tables | 0.000004 | | init | 0.000006 | | optimizing | 0.000002 | | executing | 0.000006 | | User sleep | 20.000621 | | end | 0.000012 | | query end | 0.000002 | | closing tables | 0.000002 | | freeing items | 0.000042 | | logging slow query | 0.000003 | | logging slow query | 0.000065 | | cleaning up | 0.000004 | +----------------------+-----------+ 14 rows in set (0.00 sec) mysql&gt; show profile cpu,swaps for query 2; +----------------------+-----------+----------+------------+-------+ | Status | Duration | CPU_user | CPU_system | Swaps | +----------------------+-----------+----------+------------+-------+ | starting | 0.000033 | 0.000000 | 0.000000 | 0 | | checking permissions | 0.000002 | 0.000000 | 0.000000 | 0 | | Opening tables | 0.000004 | 0.000000 | 0.000000 | 0 | | init | 0.000006 | 0.000000 | 0.000000 | 0 | | optimizing | 0.000002 | 0.000000 | 0.000000 | 0 | | executing | 0.000006 | 0.000000 | 0.000000 | 0 | | User sleep | 20.000621 | 0.006000 | 0.005999 | 0 | | end | 0.000012 | 0.000000 | 0.000000 | 0 | | query end | 0.000002 | 0.000000 | 0.000000 | 0 | | closing tables | 0.000002 | 0.000000 | 0.000000 | 0 | | freeing items | 0.000042 | 0.000000 | 0.000000 | 0 | | logging slow query | 0.000003 | 0.000000 | 0.000000 | 0 | | logging slow query | 0.000065 | 0.000000 | 0.000000 | 0 | | cleaning up | 0.000004 | 0.000000 | 0.000000 | 0 | +----------------------+-----------+----------+------------+-------+ 14 rows in set (0.00 sec)参考我以为我对Mysql索引很了解，直到我遇到了阿里的面试官-HollisChuang’s Blog]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5特性_CSS3基础_HTML5移动端基础_touch事件基础_touch多点触摸事件]]></title>
    <url>%2F2019%2F05%2F25%2Fhtml5-te-xing-css3-ji-chu-html5-yi-dong-duan-ji-chu-touch-shi-jian-ji-chu-touch-duo-dian-hong-mo-shi-jian%2F</url>
    <content type="text"><![CDATA[HTML5定位geolocation PC端,主要是获取IP地址进行定位，精度非常差 移动端，主要通过GPS定位，精度很高 geolocation getCurrentPosition 获取位置(1次) 坐标信息 res.coords watchPosition 不断获取位置 clearWatch 定位.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .bmap {width:600px; height:400px; border:1px solid black} &lt;/style> &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=1.2">&lt;/script> &lt;script> window.onload=function (){ var oBtn=document.getElementById('btn1'); oBtn.onclick=function (){ //getCurrentPosition(成功, 失败, 参数) navigator.geolocation.getCurrentPosition(function (res){ console.log(res.coords); alert('成功'); //创建和初始化地图函数： function initMap(){ createMap();//创建地图 setMapEvent();//设置地图事件 addMapControl();//向地图添加控件 addMapOverlay();//向地图添加覆盖物 } function createMap(){ map = new BMap.Map("bmap"); map.centerAndZoom(new BMap.Point(res.coords.longitude,res.coords.latitude),15); } function setMapEvent(){ map.enableScrollWheelZoom(); map.enableKeyboard(); map.enableDragging(); map.enableDoubleClickZoom() } function addClickHandler(target,window){ target.addEventListener("click",function(){ target.openInfoWindow(window); }); } function addMapOverlay(){ var markers = [ {content:"来找我啊",title:"我的位置",imageOffset: {width:0,height:3},position:{lat:res.coords.latitude,lng:res.coords.longitude}} ]; for(var index = 0; index &lt; markers.length; index++ ){ var point = new BMap.Point(markers[index].position.lng,markers[index].position.lat); var marker = new BMap.Marker(point,{icon:new BMap.Icon("http://api.map.baidu.com/lbsapi/createmap/images/icon.png",new BMap.Size(20,25),{ imageOffset: new BMap.Size(markers[index].imageOffset.width,markers[index].imageOffset.height) })}); var label = new BMap.Label(markers[index].title,{offset: new BMap.Size(25,5)}); var opts = { width: 200, title: markers[index].title, enableMessage: false }; var infoWindow = new BMap.InfoWindow(markers[index].content,opts); marker.setLabel(label); addClickHandler(marker,infoWindow); map.addOverlay(marker); }; } //向地图添加控件 function addMapControl(){ var scaleControl = new BMap.ScaleControl({anchor:BMAP_ANCHOR_BOTTOM_LEFT}); scaleControl.setUnit(BMAP_UNIT_IMPERIAL); map.addControl(scaleControl); var navControl = new BMap.NavigationControl({anchor:BMAP_ANCHOR_TOP_LEFT,type:BMAP_NAVIGATION_CONTROL_LARGE}); map.addControl(navControl); var overviewControl = new BMap.OverviewMapControl({anchor:BMAP_ANCHOR_BOTTOM_RIGHT,isOpen:true}); map.addControl(overviewControl); } var map; initMap(); }, function (err){ alert('失败'); }); }; }; &lt;/script> &lt;/head> &lt;body> &lt;input type="button" value="定位" id="btn1"> &lt;div class="bmap" id="bmap"> &lt;/div> &lt;/body> &lt;/html> 百度地图生成器 创建地图-百度地图生成器 定位中心点 设置地图 添加标注 获取代码 src=&quot;http://api.map.baidu.com/api?v=1.2&quot;版本用1.2，不然需要申请密钥，麻烦 bmap.html &lt;!DOCTYPE html> &lt;html xmlns="http://www.w3.org/1999/xhtml"> &lt;head> &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> &lt;meta name="keywords" content="百度地图,百度地图API，百度地图自定义工具，百度地图所见即所得工具" /> &lt;meta name="description" content="百度地图API自定义地图，帮助用户在可视化操作下生成百度地图" /> &lt;title>百度地图API自定义地图&lt;/title> &lt;!--引用百度地图API--> &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=1.2">&lt;/script> &lt;/head> &lt;body> &lt;!--百度地图容器--> &lt;div style="width:700px;height:550px;border:#ccc solid 1px;font-size:12px" id="map">&lt;/div> &lt;p style="color:red;font-weight:600">地图生成工具基于百度地图JS api v2.0版本开发，使用请申请密匙。 &lt;a href="http://developer.baidu.com/map/index.php?title=jspopular/guide/introduction" style="color:#2f83c7" target="_blank">了解如何申请密匙&lt;/a> &lt;a href="http://lbsyun.baidu.com/apiconsole/key?application=key" style="color:#2f83c7" target="_blank">申请密匙&lt;/a> &lt;/p> &lt;/body> &lt;script type="text/javascript"> //创建和初始化地图函数： function initMap(){ createMap();//创建地图 setMapEvent();//设置地图事件 addMapControl();//向地图添加控件 addMapOverlay();//向地图添加覆盖物 } function createMap(){ map = new BMap.Map("map"); map.centerAndZoom(new BMap.Point(116.403963,39.917167),15); } function setMapEvent(){ map.enableScrollWheelZoom(); map.enableKeyboard(); map.enableDragging(); map.enableDoubleClickZoom() } function addClickHandler(target,window){ target.addEventListener("click",function(){ target.openInfoWindow(window); }); } function addMapOverlay(){ var markers = [ {content:"来找我啊",title:"我的位置",imageOffset: {width:0,height:3},position:{lat:39.914898,lng:116.404035}} ]; for(var index = 0; index &lt; markers.length; index++ ){ var point = new BMap.Point(markers[index].position.lng,markers[index].position.lat); var marker = new BMap.Marker(point,{icon:new BMap.Icon("http://api.map.baidu.com/lbsapi/createmap/images/icon.png",new BMap.Size(20,25),{ imageOffset: new BMap.Size(markers[index].imageOffset.width,markers[index].imageOffset.height) })}); var label = new BMap.Label(markers[index].title,{offset: new BMap.Size(25,5)}); var opts = { width: 200, title: markers[index].title, enableMessage: false }; var infoWindow = new BMap.InfoWindow(markers[index].content,opts); marker.setLabel(label); addClickHandler(marker,infoWindow); map.addOverlay(marker); }; } //向地图添加控件 function addMapControl(){ var scaleControl = new BMap.ScaleControl({anchor:BMAP_ANCHOR_BOTTOM_LEFT}); scaleControl.setUnit(BMAP_UNIT_IMPERIAL); map.addControl(scaleControl); var navControl = new BMap.NavigationControl({anchor:BMAP_ANCHOR_TOP_LEFT,type:BMAP_NAVIGATION_CONTROL_LARGE}); map.addControl(navControl); var overviewControl = new BMap.OverviewMapControl({anchor:BMAP_ANCHOR_BOTTOM_RIGHT,isOpen:true}); map.addControl(overviewControl); } var map; initMap(); &lt;/script> &lt;/html> localStorage cookie 存储内容比较小，只有4K 浏览器和服务器共享 localStorage 存储内容比较大，有5M 永久存储 浏览器独享，存在跨域问题 主要用途：记录用户名、保存草稿 sessionStorage 会话期间存储，浏览器一关就没了 存和取localStorage.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> //localStorage.a=12; //存 //alert(localStorage.a); //取 console.log(localStorage); //localStorage.b=5; //localStorage.c=99; //遍历 /*for(let name in localStorage){ alert(`${name}: ${localStorage[name]}`); }*/ for(let i=0;i&lt;localStorage.length;i++){ let key=localStorage.key(i); alert(`${key}: ${localStorage[key]}`); } &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 删除localStorage2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> delete localStorage.a; &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> WebWorker 多进程，更充分发挥计算机资源（内存×、IO×、网络×、CPU√），这里指CPU 主进程也称为UI进程 子进程也称为工作进程，子进程不能再创建子进程 不能控制UI的东西，但是可以进行数据交互 也存在跨域问题 实现 发送数据oW.postMessage({n1: 25, n2: 99}) 接收数据oW.onmessage=function 1.js this.onmessage=function (ev){ let {n1, n2}=ev.data; let result=n1+n2; this.postMessage(result); }; webworker.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let oW=new Worker('1.js'); oW.onmessage=function (ev){ alert(ev.data); }; oW.postMessage({n1: 25, n2: 99}); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> webworker2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let oW=new Worker('1.js'); oW.onmessage=function (ev){ alert(ev.data); }; oW.postMessage(document); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> canvascanvas 位图,放大会失真 HTML5标准 SVG 矢量图，可以无限缩放 不是HTML5的东西，是一个独立标准 VML 矢量图，可以无限缩放 IE的矢量图，搭配SVG可以解决所有浏览器兼容 实现 路径操作,相当于PS的选区操作，没有效果，还需后续操作，需要闭合，一定要用closePath 边线 stroke() 填充fill() 版本一canvas.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> body {background: black; text-align:center;} #c1 {background:#fff;} &lt;/style> &lt;script> window.onload=function (){ let oC=document.getElementById('c1'); //图形上下文——接口：所有绘图方法、属性 let gd=oC.getContext('2d'); //路径操作——类似PS的选区 //起点 gd.moveTo(470, 81); gd.lineTo(778, 236); gd.lineTo(532, 411); gd.lineTo(312, 259); gd.lineTo(470, 81); //? gd.stroke(); //gd.fill(); }; &lt;/script> &lt;/head> &lt;body> &lt;canvas id="c1" width="800" height="600">&lt;/canvas> &lt;/body> &lt;/html> 版本二 手动闭合gd.lineTo(470, 81)，如果有线宽lineWidth的话，会导致闭合不完整，推荐使用自带的闭合方法closePath canvas2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> body {background: black; text-align:center;} #c1 {background:#fff;} &lt;/style> &lt;script> window.onload=function (){ let oC=document.getElementById('c1'); //图形上下文——接口：所有绘图方法、属性 let gd=oC.getContext('2d'); //路径操作——类似PS的选区 //起点 gd.moveTo(470, 81); gd.lineTo(778, 236); gd.lineTo(532, 411); gd.lineTo(312, 259); //gd.lineTo(470, 81); //? gd.closePath(); gd.lineWidth=20; gd.stroke(); //gd.fill(); }; &lt;/script> &lt;/head> &lt;body> &lt;canvas id="c1" width="800" height="600">&lt;/canvas> &lt;/body> &lt;/html> 版本三 线宽：lineWidth 线色：strokeStyle 填充颜色：fillStyle canvas3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> body {background: black; text-align:center;} #c1 {background:#fff;} &lt;/style> &lt;script> window.onload=function (){ let oC=document.getElementById('c1'); //图形上下文——接口：所有绘图方法、属性 let gd=oC.getContext('2d'); //路径操作——类似PS的选区 //起点 gd.moveTo(470, 81); gd.lineTo(778, 236); gd.lineTo(532, 411); gd.lineTo(312, 259); //gd.lineTo(470, 81); //? gd.closePath(); //gd.lineWidth=20; //gd.strokeStyle='green'; //gd.stroke(); gd.fillStyle='yellow'; gd.fill(); }; &lt;/script> &lt;/head> &lt;body> &lt;canvas id="c1" width="800" height="600">&lt;/canvas> &lt;/body> &lt;/html> CSS3基础圆角 CSS3圆角只需设置一个属性border-radius（含义是”边框半径”） 版本一 border-radius属性提供一个值，就能同时设置四个圆角的半径 圆角的”水平半径”（horizontal radius）和”垂直半径”（vertical radius）都设置为10px 圆角.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:300px; height:300px; background:#CCC; margin:10px auto 0; border-radius:10px;} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> &lt;/div> &lt;/body> &lt;/html> 版本二 4个角的水平半径是10px,垂直半径是50px 圆角2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:300px; height:300px; background:#CCC; margin:10px auto 0; border-radius:10px/50px;} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> &lt;/div> &lt;/body> &lt;/html> 版本三 用斜杠区分，第一组值表示水平半径，第二组值表示垂直半径 圆角3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:300px; height:300px; background:#CCC; margin:10px auto 0; border-radius:10px 50px 100px 200px/200px 100px 50px 10px;} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> &lt;/div> &lt;/body> &lt;/html> border-radius: 1em/5em; /* 等价于： */ border-top-left-radius: 1em 5em; border-top-right-radius: 1em 5em; border-bottom-right-radius: 1em 5em; border-bottom-left-radius: 1em 5em; border-radius: 4px 3px 6px / 2px 4px; /* 等价于： */ border-top-left-radius: 4px 2px; border-top-right-radius: 3px 4px; border-bottom-right-radius: 6px 2px; border-bottom-left-radius: 3px 4px;版本四 4个角，水平半径是宽度的50%和垂直半径是高度的50% 圆角4.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:300px; height:300px; background:#CCC; margin:10px auto 0; border-radius:50%;} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> &lt;/div> &lt;/body> &lt;/html> 阴影 文字阴影text-shadow 盒模型阴影box-shadow 版本一 文字阴影，text-shadow:5px 50px 1px red,水平5px,垂直50px,阴影程度1px,阴影颜色红色 阴影.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:300px; height:300px; background:#CCC; margin:10px auto 0; text-shadow:5px 50px 1px red} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 这是一些字 &lt;/div> &lt;/body> &lt;/html> 版本二 阴影类型 inset投影为内阴影，可选 X轴偏移量5px Y轴偏移量50px 阴影模糊半径5px 阴影扩展半径，可选 阴影颜色红色 阴影2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:300px; height:300px; background:#CCC; margin:10px auto 0; box-shadow:inset 5px 50px 5px red} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 这是一些字 &lt;/div> &lt;/body> &lt;/html> 版本三阴影3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:300px; height:300px; background:#CCC; margin:10px auto 0; box-shadow:2px 2px 2px black} .box:active {box-shadow:inset 2px 2px 2px black} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 这是一些字 &lt;/div> &lt;/body> &lt;/html> 版本四 box-shadow:2px 2px 20px 50px black，分别代表水平偏移2px,垂直偏移2px,阴影模糊度20px,阴影扩展半径50px，阴影颜色黑色 阴影4.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:300px; height:300px; background:#CCC; margin:10px auto 0; box-shadow:2px 2px 20px 50px black} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 这是一些字 &lt;/div> &lt;/body> &lt;/html> 渐变使用 CSS 渐变 - Web 开发者指南 | MDN 类型 线性渐变Linear Gradients 径向渐变Radial Gradients 圆锥渐变conic-gradient 渐变属于背景图片中的一种 版本一 要创建最基本的渐变类型，只需指定两种颜色即可。 这些被称为色标。 至少指定两个色标， 渐变.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:300px; height:300px; background:#CCC; margin:10px auto 0; background-image:-webkit-linear-gradient(red, green); } &lt;/style> &lt;/head> &lt;body> &lt;div class="box">&lt;/div> &lt;/body> &lt;/html> 版本二 使用多种颜色渐变，默认情况下，所设置颜色会均匀分布在渐变路径中 渐变2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:300px; height:300px; background:#CCC; margin:10px auto 0; background-image:-webkit-linear-gradient(red, green, yellow, black, blue, green); } &lt;/style> &lt;/head> &lt;body> &lt;div class="box">&lt;/div> &lt;/body> &lt;/html> 版本三 -webkit-linear-gradient(red 50%, green 50%)红色占50%，绿色占50%，即没有渐变效果 渐变3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:300px; height:300px; background:#CCC; margin:10px auto 0; background-image:-webkit-linear-gradient(red 50%, green 50%); } &lt;/style> &lt;/head> &lt;body> &lt;div class="box">&lt;/div> &lt;/body> &lt;/html> 版本四 径向渐变 一个中心点向外围进行颜色渐变 -webkit-radial-gradient(left top, 100px 100px, red 30%, green 30%)渐变中心点在left top 4.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:300px; height:300px; background:#CCC; margin:10px auto 0; background-image:-webkit-radial-gradient(left top, 100px 100px, red 30%, green 30%); } &lt;/style> &lt;/head> &lt;body> &lt;div class="box">&lt;/div> &lt;/body> &lt;/html> rgba rgba色彩模式与RGB相同，只是在GB模式上新增了Alpha透明度 R：红色值。正整数 0 - 255| 百分数0.0% - 100.0% G：绿色值 B：蓝色值 A：Alpha透明度,取值0~1之间。 rgba.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> body {background:#F0F} .box { width:300px; height:300px; background:rgba(0,0,0,0.1); margin:10px auto 0; color:white; } &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 放一些文字 &lt;/div> &lt;/body> &lt;/html> transform transform一定要加初始值 类型 translate 平移 rotate 旋转 scale 缩放 skew 倾斜 版本一 点击时，顺时针旋转90度 transform-rotate.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:300px; height:300px; background:#CCC; margin:100px auto 0; transition:1s all ease; transform:rotate(0deg); } .box:active{transform:rotate(90deg);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 放一些文字 &lt;/div> &lt;/body> &lt;/html> 版本二 点击时,元素在 X轴上拉伸2倍，在 Y轴上拉伸2部 transform-scale.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:300px; height:300px; background:#CCC; margin:100px auto 0; transition:1s all ease; transform:scale(1,1); } .box:active{transform:scale(2,2);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 放一些文字 &lt;/div> &lt;/body> &lt;/html> 版本三transform-scale2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:300px; height:300px; background:#CCC; margin:100px auto 0; transition:1s all ease; transform:scale(1,1); } .box:active{transform:scale(1,-1);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 放一些文字 &lt;/div> &lt;/body> &lt;/html> 版本四transform-scale3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:300px; height:300px; background:#CCC; margin:100px auto 0; transition:1s all ease; transform:scale(1,1); } .box:active{transform:scale(1,0);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 放一些文字 &lt;/div> &lt;/body> &lt;/html> 版本五 设置 X轴和 Y轴的倾斜角度 transform-skew.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:300px; height:300px; background:#CCC; margin:100px auto 0; transition:1s all ease; transform:skew(0,0); } .box:active{transform:skew(0,30deg);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 放一些文字 &lt;/div> &lt;/body> &lt;/html> 版本六 元素沿着 X轴正方向平移100px，沿着 Y轴正方向平移 200px transform-translate.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:300px; height:300px; background:#CCC; margin:100px auto 0; transition:1s all ease; transform:translate(0,0); } .box:active{transform:translate(100px,200px);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 放一些文字 &lt;/div> &lt;/body> &lt;/html> 版本七 CSS3的样式不改变盒模型 盒模型，物体占据的空间 CSS3样式(尤其是translate)不会引起重排、重绘，性能更高 DOM操作——越大越慢 重排 重绘 不改变盒模型.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> * {margin:0; padding:0; list-style:none} #ul1 li {float:left; width:200px; height:200px; background:#CCC; margin:10px; transition:1s all ease; transform:scale(1); border:1px solid black; box-shadow:0 0 5px 40px black;} #ul1 li:active {transform:scale(2)} &lt;/style> &lt;/head> &lt;body> &lt;ul id="ul1"> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;/ul> &lt;/body> &lt;/html> transform高级版本一 可以多个变换一起用，{transform:scale(2,1) rotate(45deg)}先旋转45度，再横向拉伸2倍，顺序是”反的”，看似是反的，其实是正的：矩阵乘法 多个变换一起用.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:200px; height:200px; background:#CCC; margin:100px auto 0; } .box:active {transform:scale(2,1) rotate(45deg)} &lt;/style> &lt;/head> &lt;body> &lt;div class="box">aaa&lt;/div> &lt;/body> &lt;/html> 版本二 2d rotate translate 3d rotateX/rotateY/rotateZ translateX/translateY/translateZ 景深/透视perspective,数值越小代表3d效果越明显 3d变换.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:200px; height:200px; background:#CCC; margin:100px auto 0; transition: 1s all ease; transform:perspective(10000px) rotateY(0); } .box:active {transform:perspective(10000px) rotateY(60deg);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box">aaa&lt;/div> &lt;/body> &lt;/html> 动画transition 使用 CSS transitions - CSS（层叠样式表） | MDN 简单、容易、方便，比较常用 版本一 transition:1s all ease时间、样式、形式 transition.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:200px; height:200px; background:#CCC; margin:100px auto 0; transition:1s all ease} /*.box:active {width:400px; height:400px; background:yellow; font-size:30px;}*/ &lt;/style> &lt;script> window.onload=function (){ let oBox=document.getElementsByClassName('box')[0]; oBox.onclick=function (){ this.style.width='400px'; }; }; &lt;/script> &lt;/head> &lt;body> &lt;div class="box"> sdfasdf &lt;/div> &lt;/body> &lt;/html> 版本二transition2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:200px; height:200px; background:#CCC; margin:100px auto 0; transition:1s all ease } .box:active {width:400px; height:400px; background:yellow; font-size:30px;} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> sdfasdf &lt;/div> &lt;/body> &lt;/html> 版本三transition3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:200px; height:200px; background:#CCC; margin:100px auto 0; transition:5s all ease } .box:active {width:400px; height:400px; background:yellow; font-size:30px;} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> sdfasdf &lt;/div> &lt;/body> &lt;/html> animation animation - CSS（层叠样式表） | MDN 强大、麻烦 ，复杂的链式动画 版本一 定义@keyframes aaa 调用 animation.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> @keyframes aaa { 0%{width:200px;height:200px;font-size:14px;background:#CCC} 25%{width:400px; height:200px; font-size:14px; background:#CCC;} 50%{width:400px; height:400px; font-size:14px; background:#CCC;} 75%{width:400px; height:400px; font-size:30px; background:#CCC;} 100%{width:400px; height:400px; font-size:30px; background:red;} } .box {width:200px; height:200px; background:#CCC; margin:100px auto 0;} .box:active { animation-name: aaa; animation-duration: 10s; animation-timing-function:ease; /* animation-fill-mode: ; animation-delay: ; animation-iteration-count: ; animation-direction: ; animation-play-state: ; */ } &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> sdfasdf &lt;/div> &lt;/body> &lt;/html> 版本二animation2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> @keyframes aaa { 0%{width:200px;height:200px;font-size:14px;background:#CCC} 25%{width:400px; height:200px; font-size:14px; background:#CCC;} 50%{width:400px; height:400px; font-size:14px; background:#CCC;} 75%{width:400px; height:400px; font-size:30px; background:#CCC;} 100%{width:400px; height:400px; font-size:30px; background:red;} } .box { width:200px; height:200px; background:#CCC; margin:100px auto 0; animation-name: aaa; animation-duration: 2s; animation-timing-function:ease; animation-fill-mode:forwards; animation-iteration-count:infinite; animation-direction:alternate; } .box:active { animation-play-state:paused; /* animation-delay: 2s; */ } &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> sdfasdf &lt;/div> &lt;/body> &lt;/html> 版本三animation3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> @keyframes aaa { 0%{transform:rotate(0)} 10%{transform:rotate(-20deg)} 20%{transform:rotate(20deg)} 30%{transform:rotate(0deg)} 70%{transform:rotate(360deg)} 80%{transform:rotate(340deg)} 90%{transform:rotate(380deg)} 100%{transform:rotate(360deg)} } .box { width:200px; height:200px; background:#CCC; margin:100px auto 0; } .box:hover { animation-name: aaa; animation-duration: 1s; animation-timing-function:ease; } &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> sdfasdf &lt;/div> &lt;/body> &lt;/html> 版本四animation4.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> @keyframes aaa { 0%{transform:rotate(0)} 10%{transform:rotate(-20deg)} 20%{transform:rotate(20deg)} 30%{transform:rotate(0deg)} 70%{transform:rotate(360deg)} 80%{transform:rotate(340deg)} 90%{transform:rotate(380deg)} 100%{transform:rotate(360deg)} } .box { width:200px; height:200px; background:#CCC; margin:100px auto 0; } .active { animation-name: aaa; animation-duration: 2s; animation-timing-function:ease; } &lt;/style> &lt;/head> &lt;body> &lt;div class="box" onclick="this.className='box active';"> sdfasdf &lt;/div> &lt;/body> &lt;/html> HTML5移动端基础transform 3D X/Y/Z坐标轴 透视 perspective,只需要给最外层(根父元素)加一次 preserve-3d添加在子元素的直接父元素，使得子元素可以脱离元素，每个需要自己出来的地方都得加 版本一 transform:perspective(700px) rotateZ(0deg);要有初始值 perspective(700px)要有透视，才能产生3d效果 Z轴旋转，圆圈顺时针旋转 坐标轴.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:200px; height:200px; background: #CCC; border:1px solid black; margin:100px auto 0; transition:1s all ease; transform:perspective(700px) rotateZ(0deg);} .box:active {transform:perspective(700px) rotateZ(90deg);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 文字 &lt;/div> &lt;/body> &lt;/html> 版本二 X轴旋转，前后旋转 坐标轴2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:200px; height:200px; background: #CCC; border:1px solid black; margin:100px auto 0; transition:1s all ease; transform:perspective(700px) rotateX(0deg);} .box:active {transform:perspective(700px) rotateX(90deg);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 文字 &lt;/div> &lt;/body> &lt;/html> 版本三 Y轴旋转，左右旋转 坐标轴3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:200px; height:200px; background: #CCC; border:1px solid black; margin:100px auto 0; transition:1s all ease; transform:perspective(700px) rotateY(0deg);} .box:active {transform:perspective(700px) rotateY(90deg);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> 文字 &lt;/div> &lt;/body> &lt;/html> 版本四 transform:perspective(700px) rotateX(60deg) rotateZ(40deg)只有用了transform,就必须指定初始值，点击前的transform和点击后的transform 父元素.box处于最外层，给自己加perspective(700px)景深,使得自己产生透视效果 为了让子元素脱离父元素产生3d效果，需要给父元素加上transform-style: preserve-3d;，因此.child元素为了脱离父元素.box,需要给父元素.box加上transform-style: preserve-3d;；同样，.child2元素为了脱离父元素.child元素，需要给父元素.child加上transform-style: preserve-3d;； 点击元素child向上平移100高度，.child:active {transform: translateZ(100px)} 点击元素child2向上平移50高度，.child:active {transform: translateZ(50px)} 坐标轴4.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:200px; height:200px; background: #CCC; border:1px solid black; margin:100px auto 0; transform:perspective(700px) rotateX(60deg) rotateZ(40deg); /*给父级去掉限制*/ transform-style: preserve-3d; } .child { width:100%; height:100%; background:yellow; transition:1s all ease; transform: translateZ(0px); transform-style: preserve-3d; } .child:active {transform: translateZ(100px)} .child2 { width:100%; height:50%; background:green; transition:1s all ease; transform: translateZ(0); } .child2:active {transform: translateZ(50px);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> &lt;div class="child"> &lt;div class="child2"> 文字 &lt;/div> &lt;/div> &lt;/div> &lt;/body> &lt;/html> 版本五3D盒子.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:200px; height:200px; position: relative; margin:150px auto 0; transition:5s all ease; transform: perspective(700px) rotateX(0deg) rotateY(0deg); transform-style: preserve-3d;} .box div {width:198px; height:198px; border:1px solid black; position:absolute; left:0; top:0; background:rgba(0,255,0,0.5)} .box:active {transform: perspective(700px) rotateX(360deg) rotateY(180deg);} .box div.front {transform: translateZ(100px);} .box div.back {transform: translateZ(-100px);} .box div.left {transform: rotateY(-90deg) translateZ(100px);} .box div.right {transform: rotateY(90deg) translateZ(100px);} .box div.top {transform: rotateX(90deg) translateZ(100px);} .box div.down {transform: rotateX(-90deg) translateZ(100px);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> &lt;div class="front">前&lt;/div> &lt;div class="back">后&lt;/div> &lt;div class="top">上&lt;/div> &lt;div class="down">下&lt;/div> &lt;div class="left">左&lt;/div> &lt;div class="right">右&lt;/div> &lt;/div> &lt;/body> &lt;/html> 版本六 点击元素.box盒子向右旋转180度transform:perspective(700px) rotateY(180deg); 元素.front向上平移transform:translateZ(1px);,使得该元素放置在上面transform:translateZ(1px); 元素.back向下平移transform:translateZ(-1px) scaleX(-1);，使得该元素放置在下面 翻转.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box { width:200px; height:300px; border:1px solid black; margin:100px auto 0; position: relative; transform-style: preserve-3d; transition:1s all ease; transform:perspective(700px) rotateY(0); } .box:active {transform:perspective(700px) rotateY(180deg);} .box div {position: absolute; left:0; top:0; width:100%; height:100%;} .box div.front {background:yellow; transform:translateZ(1px);} .box div.back {background:green; transform:translateZ(-1px) scaleX(-1);} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> &lt;div class="front">前&lt;/div> &lt;div class="back">后&lt;/div> &lt;/div> &lt;/body> &lt;/html> 版本七 第二页.child旋转中心轴靠左transform-origin:left; 点击第二页.child向左旋转180度transform:rotateY(-180deg) 翻书.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:600px; height:400px; margin:100px auto 0; position: relative; transform-style:preserve-3d; transform: perspective(700px) rotateX(20deg)} .box .page {width:298px; height:398px; background:white; border:1px solid black; position:absolute; top:0;} .box .page1 {left:0;} .box .page4 {right:0;} .box .child {width:300px; height:400px; position:absolute; left:50%; top:0; transform-style:preserve-3d; transform-origin:left;} .box .page2 {transform: translateZ(1px);} .box .page3 {transform: translateZ(-1px) scaleX(-1);} .box .child {transition:1s all ease; transform:rotateY(0deg)} .box:active .child {transform:rotateY(-180deg)} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> &lt;div class="page page1"> 3月5日，深圳市住房公积金管理中心公众号发文称，从2018年1月起，深圳市住建局联合市规划国土委推出六项维护公积金缴存职工购房权益的措施，在全市范围内开展专项整治行动，对拒绝职工使用公积金贷款购房的房地产开发商和中介机构依法查处。 &lt;/div> &lt;div class="child"> &lt;div class="page page2"> 据深圳市住房公积金管理中心介绍，从行动开始到3月初，全市有21个新建商品房项目到市公积金中心办理了公积金贷款房源入库工作，新建商品房项目入库率达到95%。 &lt;/div> &lt;div class="page page3"> 文中明确，开发商不得拒绝公积金贷款。深圳市规划国土委将加强市场监管，要求房地产开发企业在销售商品房时，提供不拒绝购房人使用公积金贷款的书面承诺，并在项目销售现场对外公示。 &lt;/div> &lt;/div> &lt;div class="page page4"> 与此同时，房地产开发企业和房屋销售中介机构拒绝公积金贷款，或者房地产开发企业未在楼盘销售现场公示不拒绝购房人使用公积金贷款书面承诺的，职工可电话举报违规楼盘。 &lt;/div> &lt;/div> &lt;/body> &lt;/html> 移动端开发 移动端适配：font-size设置的思考 - axl234 - 博客园 移动端适配版本一 viewport的宽度等于物理设备上的真实分辨率，不允许用户缩放 移动端页面.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no,maximum-scale=1.0,minimum-scale=1.0"> &lt;/head> &lt;body> &lt;input type="button" name="" value="按钮"> &lt;/body> &lt;/html> 盒模型 box-sizing - CSS（层叠样式表） | MDN box-sizing 属性, 默认,属性值是content-box,意味着该盒子是一个普通盒子,盒子的width=width + padding + border，如果你设置一个元素的宽为 100px，那么这个元素的内容区会有100px宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中 属性值是border-box ,告诉浏览器你设置的边框和内边距的值是包含在width内的 版本一盒模型.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:200px; height:200px; background:#CCC; box-sizing:border-box; padding:10px; border:10px solid black;} &lt;/style> &lt;/head> &lt;body> &lt;div class="box"> dfsdfdsf &lt;/div> &lt;/body> &lt;/html> 版本二 设置box-sizing:border-box;元素li不会被挤到第二排 border-box.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> * {margin:0; padding:0; list-style: none;} ul {overflow:hidden;} ul li {width:20%; float:left; box-sizing:border-box; border:5px solid black; padding:10px;} &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>aaa&lt;/li> &lt;li>bbb&lt;/li> &lt;li>ccc&lt;/li> &lt;li>ddd&lt;/li> &lt;li>eee&lt;/li> &lt;/ul> &lt;/body> &lt;/html> flex-弹性盒模型 具备border-box的能力 对border、padding和margin都好用,可以使得盒子根据比例自适应 浮动，可以使得元素排在一行，但是需要清除浮动 flex弹性盒模型可以使得元素排放置一行，自适应 跟max-width、min-width配合 版本一弹性盒模型.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> * {margin:0; padding:0; list-style:none} #ul1 {display:flex;} #ul1 li {flex:1; border:10px solid black; padding:10px; margin:20px;} &lt;/style> &lt;/head> &lt;body> &lt;ul id="ul1"> &lt;li>1&lt;/li> &lt;li>2&lt;/li> &lt;li>3&lt;/li> &lt;li>4&lt;/li> &lt;/ul> &lt;/body> &lt;/html> 版本二 第一个li设置style=&quot;min-width:400px;&quot;，屏幕缩小时，第一个li的最小宽度为400px 弹性盒模型2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> * {margin:0; padding:0; list-style:none} #ul1 {display:flex;} #ul1 li {flex:1; border:1px solid black;} &lt;/style> &lt;/head> &lt;body> &lt;ul id="ul1"> &lt;li style="min-width:400px;">1&lt;/li> &lt;li>2&lt;/li> &lt;/ul> &lt;/body> &lt;/html> 版本三 中间固定，两边自适应 弹性盒模型3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> * {margin:0; padding:0; list-style:none} #ul1 {display:flex;} #ul1 li {flex:1; border:1px solid black;} &lt;/style> &lt;/head> &lt;body> &lt;ul id="ul1"> &lt;li>1&lt;/li> &lt;li style="max-width:500px; min-width:500px;">2&lt;/li> &lt;li>3&lt;/li> &lt;/ul> &lt;/body> &lt;/html> rem px设置了多少就是多少 em相对于自身字体大小 rem相对于root字体大小即相对于html的font-size，在不同的屏幕尺寸下，只需要调整HTML元素的font-size 方便、性能高, 一切尺寸都用rem,推荐使用 touch事件基础 触摸事件 - Web API 接口参考 | MDN 移动端布局 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; flex 使用rem,绝对不要用px HTML5标签 有特殊作用无法替代的标签 canvas画图 video播放视频 input输入框 form表单，收集数据并提交到后台 其它的标签没啥区别，HTML5的大部分新标签仅仅只是为了更加的语义化，用合适的标签装合适的东西 新标签：section、header、footer、nav、aside、figure、legend div和section二者之间没啥区别，一个没有语义，一个有语义 CSS3实现slideUp版本一 点击按钮时，判断盒子.box是否包含.slideUp类名，有则取消，没有则添加 transition:0.5s all ease设置动画时间0.5s 1.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:200px; height:200px; background:#CCC; border:1px solid black; transition:0.5s all ease} .slideUp {height:0px;} &lt;/style> &lt;script> window.onload=function (){ let oBtn=document.getElementById('btn1'); let oDiv=document.getElementById('div1'); oBtn.onclick=function (){ if(Array.from(oDiv.classList).includes('slideUp')){ oDiv.className='box'; }else{ oDiv.className='box slideUp'; } }; }; &lt;/script> &lt;/head> &lt;body> &lt;input type="button" value="按钮" id="btn1"> &lt;div id="div1" class="box"> &lt;/div> &lt;/body> &lt;/html> touch事件手指触摸 PC端,主要有mouse事件，只能有一个，就算笔记本插入2个鼠标，移动也只有一个光标点 mousedown move up 移动端，主要是touch事件，支持多点触摸 touchstart touchmove touchend 版本一 Touch Event规范中的几个重要事件 touchstart 手指触摸屏幕时触发，即使已经有手指在屏幕上也会触发 touchmove手指在屏幕滑动时触发 touchend手指从屏幕时移开时触发。 每一个事件处理程序都有一个ev的参数对象,该对象描述了当前触摸的相关信息，通过这样一个对象，能够获取到当前触碰的坐标，触碰的手指个数等等 为了手指再屏幕滑动、移开时可以解绑，滑动、移开事件采用有名函数fnMove、fnEnd,而不是匿名函数 clientX：触摸目标在视口中的x坐标 clientY：触摸目标在视口中的y坐标。 touch事件.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta name="viewport" content="width=device-width"> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:200px; height:200px; background:#CCC; position:absolute; left:0; top:0;} &lt;/style> &lt;script> window.onload=function (){ let oBox=document.getElementsByClassName('box')[0]; oBox.addEventListener('touchstart', function (ev){ let disX=ev.targetTouches[0].clientX-oBox.offsetLeft; let disY=ev.targetTouches[0].clientY-oBox.offsetTop; function fnMove(ev){ oBox.style.left=ev.targetTouches[0].clientX-disX+'px'; oBox.style.top=ev.targetTouches[0].clientY-disY+'px'; } function fnEnd(){ oBox.removeEventListener('touchmove', fnMove, false); oBox.removeEventListener('touchend', fnEnd, false); } oBox.addEventListener('touchmove', fnMove, false); oBox.addEventListener('touchend', fnEnd, false); }, false); }; &lt;/script> &lt;/head> &lt;body> &lt;div class="box"> &lt;/div> &lt;/body> &lt;/html> 版本二 通过transform来获取手势移动时的横、纵坐标值，但是通过getComputedStyle(oBox, false).transform获取transform值是一个矩阵点的值，不利于计算，我们可以用一个变量来存横、纵坐标值oBox.style.transform=`translate(${x}px,${y}px) 获取transform.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {transform:translateX(100px) rotate(30deg);} &lt;/style> &lt;script> window.onload=function (){ let oBox=document.querySelector('.box'); //matrix(0.707107, 0.707107, -0.707107, 0.707107, 0, 0) alert(getComputedStyle(oBox, false).transform); }; &lt;/script> &lt;/head> &lt;body> &lt;div class="box"> &lt;/div> &lt;/body> &lt;/html> touch事件2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta name="viewport" content="width=device-width"> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:200px; height:200px; background:#CCC; transform:translate(0px,0px);} &lt;/style> &lt;script> window.onload=function (){ let oBox=document.getElementsByClassName('box')[0]; let x=0,y=0; oBox.addEventListener('touchstart', function (ev){ let disX=ev.targetTouches[0].clientX-x; let disY=ev.targetTouches[0].clientY-y; function fnMove(ev){ x=ev.targetTouches[0].clientX-disX; y=ev.targetTouches[0].clientY-disY; oBox.style.transform=`translate(${x}px,${y}px)`; } function fnEnd(){ oBox.removeEventListener('touchmove', fnMove, false); oBox.removeEventListener('touchend', fnEnd, false); } oBox.addEventListener('touchmove', fnMove, false); oBox.addEventListener('touchend', fnEnd, false); }, false); }; &lt;/script> &lt;/head> &lt;body> &lt;div class="box"> &lt;/div> &lt;/body> &lt;/html> 方向锁定 用户超出手势移动超过5px,确定方向 方向锁定.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta name="viewport" content="width=device-width"> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:200px; height:200px; background:#CCC; transform:translate(0px,0px);} &lt;/style> &lt;script> window.onload=function (){ let oBox=document.getElementsByClassName('box')[0]; let x=0,y=0; oBox.addEventListener('touchstart', function (ev){ let dir=''; let disX=ev.targetTouches[0].clientX-x; let disY=ev.targetTouches[0].clientY-y; let startX=ev.targetTouches[0].clientX; let startY=ev.targetTouches[0].clientY; function fnMove(ev){ if(dir==''){ //等待方向确定——用户超出5px if(Math.abs(ev.targetTouches[0].clientX-startX)>=5){ dir='x'; }else if(Math.abs(ev.targetTouches[0].clientY-startY)>=5){ dir='y'; } }else{ if(dir=='x'){ x=ev.targetTouches[0].clientX-disX; }else if(dir=='y'){ y=ev.targetTouches[0].clientY-disY; } oBox.style.transform=`translate(${x}px,${y}px)`; } } function fnEnd(){ oBox.removeEventListener('touchmove', fnMove, false); oBox.removeEventListener('touchend', fnEnd, false); } oBox.addEventListener('touchmove', fnMove, false); oBox.addEventListener('touchend', fnEnd, false); }, false); }; &lt;/script> &lt;/head> &lt;body> &lt;div class="box"> &lt;/div> &lt;/body> &lt;/html> 淘宝 rem值的确定，设计稿基准宽度/基准字体大小 假设，设计稿基准宽度：480px,基准字体大小：10px，即可得出header的width：48rem 移动端，不同的手机显示的字体大小是不一样的，那么该如何设置字体font-size的字体值rem呢 公式$$480/10=clientWidth/真实fontsize===》真实fontsize=clientWidth/48$$ 求绝对值Math.abs(x);函数返回指定数字 x的绝对值 版本一淘宝.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;meta name="viewport" content="width=device-width"> &lt;style media="screen"> * {margin:0; padding:0; list-style:none;} html {font-size:10px} header {width:48rem;height:5.5rem;background:#fe5400; overflow:hidden; position:relative; z-index:99;} header h1 {width:4.4rem; height:3.7rem; background:url(img/logo.png) no-repeat; text-indent:-9999rem; background-size:100% 100%; margin-left:0.6rem; margin-top:1rem;} /*banner*/ .banner {width:48rem; height:15rem; position:relative; overflow:hidden;} .banner ul {width:999rem; height:15rem; overflow:hidden; transform:translateX(0rem);} .banner ul li {width:48rem; height:15rem; float:left;} .banner ul li img {width:100%; height:100%;} .banner ol {position: absolute; right:0; bottom: 1.3rem;} .banner ol li {width:1rem; height:1rem; border:1px solid #333; background:white; border-radius:50%; margin:0 0.4rem; opacity:0.6; float:left;} .banner ol li.active {background:#ff5501; border:1px solid #d0a793; opacity:1} /**/ .page_content {background:white; position:relative; top:-5rem;} .load {height:5rem; line-height:5rem; text-align:center; font-size:2rem;} &lt;/style> &lt;script> window.onresize=function (){ document.documentElement.style.fontSize=document.documentElement.clientWidth/48+'px'; }; window.onresize(); window.onload=function (){ let oBanner=document.querySelector('.banner'); let oBannerUl=oBanner.children[0]; let oPageContent=document.querySelector('.page_content'); let x=0,y=0; oBanner.addEventListener('touchstart', function (ev){ let startX=ev.targetTouches[0].clientX; let startY=ev.targetTouches[0].clientY; let disX=startX-x; let disY=startY-y; let dir=''; function fnMove(ev){ if(dir==''){ if(Math.abs(ev.targetTouches[0].clientX-startX)>=5){ dir='x'; }else if(Math.abs(ev.targetTouches[0].clientY-startY)>=5){ dir='y'; } }else{ if(dir=='x'){ x=ev.targetTouches[0].clientX-disX; }else{ y=ev.targetTouches[0].clientY-disY; } oBannerUl.style.transform=`translateX(${x}px)`; if(y>0){ oPageContent.style.transform=`translateY(${y/3}px)`; }else{ oPageContent.style.transform=`translateY(${y}px)`; } } } function fnEnd(){ oBanner.removeEventListener('touchmove', fnMove, false); oBanner.removeEventListener('touchend', fnEnd, false); if(y>0){ y=0; oPageContent.style.transition='0.3s all ease'; oPageContent.style.transform=`translateY(0px)`; } } oBanner.addEventListener('touchmove', fnMove, false); oBanner.addEventListener('touchend', fnEnd, false); }, false); }; &lt;/script> &lt;/head> &lt;body> &lt;header> &lt;h1>淘宝网&lt;/h1> &lt;/header> &lt;div class="load"> 下拉刷新 &lt;/div> &lt;div class="page_content"> &lt;section class="banner"> &lt;ul> &lt;li>&lt;img src="img/banner1.jpg" />&lt;/li> &lt;li>&lt;img src="img/banner2.jpg" />&lt;/li> &lt;li>&lt;img src="img/banner1.jpg" />&lt;/li> &lt;li>&lt;img src="img/banner2.jpg" />&lt;/li> &lt;li>&lt;img src="img/banner1.jpg" />&lt;/li> &lt;li>&lt;img src="img/banner2.jpg" />&lt;/li> &lt;/ul> &lt;ol> &lt;li class="active">&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;/ol> &lt;/section> &lt;nav> &lt;/nav> &lt;/div> &lt;/body> &lt;/html> 版本二 为了实现轮播，尾巴追加第一个元素，头追加最后一个元素 oBannerUl.appendChildoBannerUl.insertBefore 淘宝2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;meta name="viewport" content="width=device-width"> &lt;style media="screen"> * {margin:0; padding:0; list-style:none;} html {font-size:10px} header {width:48rem;height:5.5rem;background:#fe5400; overflow:hidden; position:relative; z-index:99;} header h1 {width:4.4rem; height:3.7rem; background:url(img/logo.png) no-repeat; text-indent:-9999rem; background-size:100% 100%; margin-left:0.6rem; margin-top:1rem;} /*banner*/ .banner {width:48rem; height:15rem; position:relative; overflow:hidden;} .banner ul {width:999rem; height:15rem; overflow:hidden; transform:translateX(-48rem);} .banner ul li {width:48rem; height:15rem; float:left;} .banner ul li img {width:100%; height:100%;} .banner ol {position: absolute; right:0; bottom: 1.3rem;} .banner ol li {width:1rem; height:1rem; border:1px solid #333; background:white; border-radius:50%; margin:0 0.4rem; opacity:0.6; float:left;} .banner ol li.active {background:#ff5501; border:1px solid #d0a793; opacity:1} /**/ .page_content {background:white; position:relative; top:-5rem;} .load {height:5rem; line-height:5rem; text-align:center; font-size:2rem;} &lt;/style> &lt;script> window.onresize=function (){ document.documentElement.style.fontSize=document.documentElement.clientWidth/48+'px'; }; window.onresize(); window.onload=function (){ let oBanner=document.querySelector('.banner'); let oBannerUl=oBanner.children[0]; let oBannerUlLi=oBannerUl.children; let oPageContent=document.querySelector('.page_content'); let oLoad=document.querySelector('.load'); let aOlLi=document.querySelectorAll('.banner ol li'); // oBannerUl.appendChild(oBannerUlLi[0].cloneNode(true)); oBannerUl.insertBefore(oBannerUlLi[oBannerUlLi.length-2].cloneNode(true), oBannerUlLi[0]); let x=-oBannerUlLi[0].offsetWidth,y=0; oBanner.addEventListener('touchstart', function (ev){ oPageContent.style.transition='none'; oBannerUl.style.transition='none'; let startX=ev.targetTouches[0].clientX; let startY=ev.targetTouches[0].clientY; let disX=startX-x; let disY=startY-y; let dir=''; function fnMove(ev){ if(dir==''){ if(Math.abs(ev.targetTouches[0].clientX-startX)>=5){ dir='x'; }else if(Math.abs(ev.targetTouches[0].clientY-startY)>=5){ dir='y'; } }else{ if(dir=='x'){ x=ev.targetTouches[0].clientX-disX; }else{ y=ev.targetTouches[0].clientY-disY; } oBannerUl.style.transform=`translateX(${x}px)`; if(y>0){ oPageContent.style.transform=`translateY(${y/3}px)`; if(y>200){ oLoad.innerHTML='松手'; }else{ oLoad.innerHTML='下拉刷新'; } }else{ oPageContent.style.transform=`translateY(${y}px)`; } } } function fnEnd(){ oBanner.removeEventListener('touchmove', fnMove, false); oBanner.removeEventListener('touchend', fnEnd, false); if(y>0){ y=0; oPageContent.style.transition='0.3s all ease'; oPageContent.style.transform=`translateY(0px)`; } // let n=Math.round(-x/oBannerUl.children[0].offsetWidth); x=-n*oBannerUl.children[0].offsetWidth; console.log(n); oBannerUl.style.transition='0.3s all ease'; oBannerUl.style.transform=`translateX(${x}px)`; Array.from(aOlLi).forEach((li,index)=>{ li.className=index==n?'active':''; }) } oBanner.addEventListener('touchmove', fnMove, false); oBanner.addEventListener('touchend', fnEnd, false); }, false); }; &lt;/script> &lt;/head> &lt;body> &lt;header> &lt;h1>淘宝网&lt;/h1> &lt;/header> &lt;div class="load"> 下拉刷新 &lt;/div> &lt;div class="page_content"> &lt;section class="banner"> &lt;ul> &lt;li>&lt;img src="img/banner1.jpg" />&lt;/li> &lt;li>&lt;img src="img/banner2.jpg" />&lt;/li> &lt;li>&lt;img src="img/banner1.jpg" />&lt;/li> &lt;li>&lt;img src="img/banner2.jpg" />&lt;/li> &lt;li>&lt;img src="img/banner1.jpg" />&lt;/li> &lt;li>&lt;img src="img/banner2.jpg" />&lt;/li> &lt;/ul> &lt;ol> &lt;li class="active">&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;li>&lt;/li> &lt;/ol> &lt;/section> &lt;nav> &lt;/nav> &lt;/div> &lt;/body> &lt;/html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML5 CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[upload和FileReade]]></title>
    <url>%2F2019%2F05%2F24%2Fupload-he-filereade%2F</url>
    <content type="text"><![CDATA[上传进度前台版本一 HTML5标签自带的进度条标签&lt;meter&gt; 上传进度oAjax.upload.onprogress 上传进度.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> window.onload=function (){ let oF=document.getElementById('f1'); let oBtn=document.getElementById('btn1'); oBtn.onclick=function (){ let data=new FormData(); Array.from(oF.files).forEach(file=>{ data.append('f1', file); }); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.upload.onprogress=function (ev){ let oM=document.getElementById('m1'); oM.value=100*ev.loaded/ev.total; }; oAjax.send(data); /* oAjax.onreadystatechange=function (){ if(oAjax.readyState==4){ if(oAjax.status>=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304){ alert('成功'); }else{ alert('失败'); } } };*/ }; }; &lt;/script> &lt;/head> &lt;body> &lt;meter id="m1" value="" min="0" max="100" style="width:500px;">&lt;/meter>&lt;br> &lt;input type="file" id="f1" multiple />&lt;br> &lt;input type="button" value="提交" id="btn1"> &lt;/body> &lt;/html> 版本二 自己创建进度条标签 绑定事件监听oAjax.upload.addEventListener 上传进度2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .parent {width:500px; height:20px; border:1px solid black;} .child {width:0; height:100%; background:green;} &lt;/style> &lt;script> window.onload=function (){ let oF=document.getElementById('f1'); let oBtn=document.getElementById('btn1'); oBtn.onclick=function (){ let data=new FormData(); Array.from(oF.files).forEach(file=>{ data.append('f1', file); }); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); console.log(oAjax); oAjax.upload.addEventListener('progress', function (ev){ /*let oM=document.getElementById('m1'); oM.value=100*ev.loaded/ev.total;*/ let oChild=document.getElementsByClassName('child')[0]; oChild.style.width=100*ev.loaded/ev.total+'%'; }, false); oAjax.send(data); /* oAjax.onreadystatechange=function (){ if(oAjax.readyState==4){ if(oAjax.status>=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304){ alert('成功'); }else{ alert('失败'); } } };*/ }; }; &lt;/script> &lt;/head> &lt;body> &lt;div class="parent"> &lt;div class="child"> &lt;/div> &lt;/div> &lt;input type="file" id="f1" multiple />&lt;br> &lt;input type="button" value="提交" id="btn1"> &lt;/body> &lt;/html> 版本三 下载进度oAjax.onprogress 下载进度.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .parent {width:500px; height:20px; border:1px solid black;} .child {width:0; height:100%; background:green;} &lt;/style> &lt;script> window.onload=function (){ let oF=document.getElementById('f1'); let oBtn=document.getElementById('btn1'); oBtn.onclick=function (){ let data=new FormData(); Array.from(oF.files).forEach(file=>{ data.append('f1', file); }); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.onprogress=function (ev){ console.log(ev); }; oAjax.upload.addEventListener('progress', function (ev){ /*let oM=document.getElementById('m1'); oM.value=100*ev.loaded/ev.total;*/ let oChild=document.getElementsByClassName('child')[0]; oChild.style.width=100*ev.loaded/ev.total+'%'; }, false); oAjax.send(data); /* oAjax.onreadystatechange=function (){ if(oAjax.readyState==4){ if(oAjax.status>=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304){ alert('成功'); }else{ alert('失败'); } } };*/ }; }; &lt;/script> &lt;/head> &lt;body> &lt;div class="parent"> &lt;div class="child"> &lt;/div> &lt;/div> &lt;input type="file" id="f1" multiple />&lt;br> &lt;input type="button" value="提交" id="btn1"> &lt;/body> &lt;/html> 版本四 下载进度绑定事件监听document.addEventListener 下载进度2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .parent {width:500px; height:20px; border:1px solid black;} .child {width:0; height:100%; background:green;} &lt;/style> &lt;script> document.addEventListener('progress', function (){ console.log('a'); }, false); &lt;/script> &lt;/head> &lt;body> &lt;form id="form1" action="http://localhost:8080/api" method="post" enctype="multipart/form-data"> &lt;input type="file" multiple> &lt;input type="submit" value="上传"> &lt;/form> &lt;/body> &lt;/html> 后台 解决跨域，判断请求头中是否携带req.headers[&#39;origin&#39;]字段 express_server.js const express=require('express'); //主体 const body=require('body-parser'); //接收普通POST数据 const multer=require('multer'); //接收文件POST数据 const mysql=require('mysql'); let db=mysql.createPool({host: 'localhost', port: 3309, user: 'root', password: '', database: '20180208'}); let server=express(); server.listen(8080); //中间件 server.use(body.urlencoded({extended: false})); let multerObj=multer({dest: './upload/'}); server.use(multerObj.any()); //处理请求 server.use('/api', (req, res)=>{ if(req.headers['origin']=='null' || req.headers['origin'].startsWith('http://localhost')){ res.setHeader('Access-Control-Allow-Origin', '*'); } let arr=[]; req.files.forEach(file=>{ arr.push(`('${file.originalname}', '${file.filename}', ${Math.floor(Date.now()/1000)})`); }); let sql=`INSERT INTO image_table (originalname, filename, time) VALUES${arr.join(',')}`; //console.log(sql); db.query(sql, (err)=>{ if(err){ res.send('不OK'); }else{ res.send("OK"); } }); }); // server.use(express.static('./www/')); 上传进度条实现注意 oAjax.upload.onprogress必须放在oAjax.send(data)前面 服务器必须能处理OPTIONS请求，oAjax加了upload会发送OPTIONS和POST2次请求 对于通用服务器，我们不用担心，他们会自己进行处理 对于NodeJS服务，使用express框架，使用server.use 拖拽上传 拖拽松手事件drop 绑定事件监听阻止默认行为，ev.preventDefault() 按钮阻止默认行为，return false 获取文件ev.dataTransfer.files 数据封装，使用FormData封装文件数据 发送，oAjax.send(data) 文件拖拽.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> * {margin:0; padding:0} .box {width:400px; height:200px; background:#CCC; border:1px solid black; line-height:200px; position:absolute; left:50%; top:50%; margin-left:-200px; margin-top:-100px; text-align:center; display:none;} &lt;/style> &lt;script> window.onload=function (){ let oBox=document.querySelector('.box'); let timer; document.addEventListener('dragover', (ev)=>{ clearTimeout(timer); oBox.style.display='block'; timer=setTimeout(function (){ oBox.style.display='none'; }, 300); ev.preventDefault(); }, false); oBox.addEventListener('dragenter', ()=>{ oBox.innerHTML='请松手'; }, false); oBox.addEventListener('dragleave', ()=>{ oBox.innerHTML='请把文件拖到这儿'; }, false); oBox.addEventListener('drop', (ev)=>{ let data=new FormData(); Array.from(ev.dataTransfer.files).forEach(file=>{ data.append('f1', file); }); let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.upload.addEventListener('progress', function (ev){ let oM=document.querySelector('#m1'); oM.value=100*ev.loaded/ev.total; }, false); oAjax.send(data); ev.preventDefault(); oAjax.onreadystatechange=function (){ if(oAjax.readyState==4){ if(oAjax.status>=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304){ alert('成功'); }else{ alert('失败'); } } }; }, false); }; &lt;/script> &lt;/head> &lt;body> &lt;meter id="m1" min="0" max="100" style="width:100%;">&lt;/meter> &lt;div class="box"> 请把文件拖到这儿 &lt;/div> &lt;/body> &lt;/html> 读取文件FileReader前台版本一 文件读取 方法reader.readAsDataURL(file)可以将图片文件转换为base64编码 传输数据可以通过二进制和base64来传输 base64可以把二进制数据表现成字符串 只要能出现地址src的地方，都能用Base64 一般小图标不要引用地址，直接放个base64可以优化网络性能 维护麻烦，base64编码会把文件体积变大 当读取操作成功完成时调用reader.onload 读取文件.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> * {margin:0; padding:0} .box {width:400px; height:200px; background:#CCC; border:1px solid black; line-height:200px; position:absolute; left:50%; top:50%; margin-left:-200px; margin-top:-100px; text-align:center; display:none;} &lt;/style> &lt;script> window.onload=function (){ let oBox=document.querySelector('.box'); let timer; document.addEventListener('dragover', (ev)=>{ clearTimeout(timer); oBox.style.display='block'; timer=setTimeout(function (){ oBox.style.display='none'; }, 300); ev.preventDefault(); }, false); oBox.addEventListener('dragenter', ()=>{ oBox.innerHTML='请松手'; }, false); oBox.addEventListener('dragleave', ()=>{ oBox.innerHTML='请把文件拖到这儿'; }, false); oBox.addEventListener('drop', (ev)=>{ let file=ev.dataTransfer.files[0]; //读取文件 let reader=new FileReader(); reader.onload=function (){ document.write(reader.result); }; //base64 reader.readAsDataURL(file); ev.preventDefault(); }, false); }; &lt;/script> &lt;/head> &lt;body> &lt;div class="box"> 请把文件拖到这儿 &lt;/div> &lt;/body> &lt;/html> 版本二 判断文件类型，file.type.startsWith(&#39;image/&#39;) 读取文件2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> * {margin:0; padding:0; list-style: none} .box {width:400px; height:200px; background:#CCC; border:1px solid black; line-height:200px; position:absolute; left:50%; top:50%; margin-left:-200px; margin-top:-100px; text-align:center; display:none;} .img_list {overflow:hidden;} .img_list li {float:left; width:200px; height:200px; border:3px solid #666; margin:10px; position:relative;} .img_list li img {width:100%; height:100%;} .img_list li .del_btn {position:absolute; right:0; top:0;} &lt;/style> &lt;script> window.onload=function (){ let oUl=document.querySelector('.img_list'); let oBox=document.querySelector('.box'); let timer; document.addEventListener('dragover', (ev)=>{ clearTimeout(timer); oBox.style.display='block'; timer=setTimeout(function (){ oBox.style.display='none'; }, 300); ev.preventDefault(); }, false); oBox.addEventListener('dragenter', ()=>{ oBox.innerHTML='请松手'; }, false); oBox.addEventListener('dragleave', ()=>{ oBox.innerHTML='请把文件拖到这儿'; }, false); oBox.addEventListener('drop', (ev)=>{ Array.from(ev.dataTransfer.files).forEach(file=>{ if(!file.type.startsWith('image/')){ return; } let reader=new FileReader(); reader.onload=function (){ let oLi=document.createElement('li'); oLi.file=file; oLi.innerHTML='&lt;img src="a.png" alt="">&lt;a href="javascript:;" class="del_btn">删除&lt;/a>'; let oImg=oLi.children[0]; oImg.src=this.result; let oBtnDel=oLi.children[1]; oBtnDel.onclick=function (){ oUl.removeChild(oLi); }; oUl.appendChild(oLi); }; reader.readAsDataURL(file); }); ev.preventDefault(); }, false); //真的上传 let oBtnUpload=document.querySelector('#btn_upload'); oBtnUpload.onclick=function (){ let data=new FormData(); Array.from(oUl.children).forEach(li=>{ data.append('f1', li.file); }); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.send(data); oAjax.onreadystatechange=function (){ if(oAjax.readyState==4){ if(oAjax.status>=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304){ alert('成功'); }else{ alert('失败'); } } }; }; }; &lt;/script> &lt;/head> &lt;body> &lt;ul class="img_list"> &lt;!--&lt;li> &lt;img src="a.png" alt=""> &lt;a href="javascript:;" class="del_btn">删除&lt;/a> &lt;/li> &lt;li> &lt;img src="b.png" alt=""> &lt;a href="javascript:;" class="del_btn">删除&lt;/a> &lt;/li>--> &lt;/ul> &lt;input type="button" name="" value="上传" id="btn_upload"> &lt;div class="box"> 请把文件拖到这儿 &lt;/div> &lt;/body> &lt;/html> 版本三 以二进制数据的形式存储数据，reader.readAsArrayBuffer(file) 以字符串形式存储的二进制数据，readAsBinaryString 图片(以及其他二进制数据)，readAsDataURL 将文件读取为文本，readAsText 读取文件3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> * {margin:0; padding:0; list-style: none} .box {width:400px; height:200px; background:#CCC; border:1px solid black; line-height:200px; position:absolute; left:50%; top:50%; margin-left:-200px; margin-top:-100px; text-align:center; display:none;} .img_list {overflow:hidden;} .img_list li {float:left; width:200px; height:200px; border:3px solid #666; margin:10px; position:relative;} .img_list li img {width:100%; height:100%;} .img_list li .del_btn {position:absolute; right:0; top:0;} &lt;/style> &lt;script> window.onload=function (){ let oUl=document.querySelector('.img_list'); let oBox=document.querySelector('.box'); let timer; document.addEventListener('dragover', (ev)=>{ clearTimeout(timer); oBox.style.display='block'; timer=setTimeout(function (){ oBox.style.display='none'; }, 300); ev.preventDefault(); }, false); oBox.addEventListener('dragenter', ()=>{ oBox.innerHTML='请松手'; }, false); oBox.addEventListener('dragleave', ()=>{ oBox.innerHTML='请把文件拖到这儿'; }, false); oBox.addEventListener('drop', (ev)=>{ let file=ev.dataTransfer.files[0]; let reader=new FileReader(); console.log(reader); reader.onload=function (){ console.log(this.result); }; reader.readAsArrayBuffer(file); ev.preventDefault(); }, false); }; &lt;/script> &lt;/head> &lt;body> &lt;div class="box"> 请把文件拖到这儿 &lt;/div> &lt;/body> &lt;/html> 后台将读取的文件入库 连接数据库mysql.createPool 批量插入 express_server.js const express=require('express'); //主体 const body=require('body-parser'); //接收普通POST数据 const multer=require('multer'); //接收文件POST数据 const mysql=require('mysql'); let db=mysql.createPool({host: 'localhost', port: 3309, user: 'root', password: '', database: '20180208'}); let server=express(); server.listen(8080); //中间件 server.use(body.urlencoded({extended: false})); let multerObj=multer({dest: './upload/'}); server.use(multerObj.any()); //处理请求 server.use('/api', (req, res)=>{ if(req.headers['origin']=='null' || req.headers['origin'].startsWith('http://localhost')){ res.setHeader('Access-Control-Allow-Origin', '*'); } let arr=[]; req.files.forEach(file=>{ arr.push(`('${file.originalname}', '${file.filename}', ${Math.floor(Date.now()/1000)})`); }); let sql=`INSERT INTO image_table (originalname, filename, time) VALUES${arr.join(',')}`; //console.log(sql); db.query(sql, (err)=>{ if(err){ res.send('不OK'); }else{ res.send("OK"); } }); }); // server.use(express.static('./www/')); ajax版本 ajax2.0携带有oAjax.upload属性 ajax版本.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .parent {width:500px; height:20px; border:1px solid black;} .child {width:0; height:100%; background:green;} &lt;/style> &lt;script> window.onload=function (){ var oBtn=document.getElementById('btn1'); oBtn.onclick=function (){ var oAjax=new XMLHttpRequest(); if(oAjax.upload){ alert('2.0'); }else{ alert('1.0'); } }; }; &lt;/script> &lt;/head> &lt;body> &lt;input type="button" value="提交" id="btn1"> &lt;/body> &lt;/html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle11g安装_客户端工具管理oracle数据库]]></title>
    <url>%2F2019%2F05%2F20%2Foracle11g-an-zhuang-ke-hu-duan-gong-ju-guan-li-oracle-shu-ju-ku%2F</url>
    <content type="text"><![CDATA[oracle11g安装单机版集群版客户端工具管理oracle数据库web方式管理工具sql developer下载使用设置字体工具-&gt;首选项-&gt;代码编辑器-&gt;字体 设置日期工具-&gt;首选项-&gt;数据库-&gt;NLS-&gt;日期格式 工具默认的日期格式DD-MON-RR DD-MON-RR 修改为: YYYY-MM-DD HH24:MI:SS 代码格式化Ctrl+F7 运行F9或者Ctrl+Enter PL\SQL下载配置TNS]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk多版本设置]]></title>
    <url>%2F2019%2F05%2F19%2Fjdk-duo-ban-ben-she-zhi%2F</url>
    <content type="text"><![CDATA[jdk多版本设置Windows安装jdk1.6 jdk1.7 jdk1.8 删除或者重命名 C:\Windows\System32下的java.exe、javaw.exe、javaws.exe C:\Program Files (x86)\Common Files\Oracle\Java\javapath下的java.exe、javaw.exe、javaws.exe 配置自己的jdk环境变量 Linux]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax2.0的FormData和跨域Cors]]></title>
    <url>%2F2019%2F05%2F15%2Fajax2-0-de-formdata-he-kua-yu-cors%2F</url>
    <content type="text"><![CDATA[formdata前台浏览器ajax2.0的东西 入门 set(key, value) 会覆盖 append(key, value) 不覆盖 get(key)=&gt;value delete(key) 1.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let data=new FormData(); data.set('user', 'blue'); data.append('user', 'blue2'); console.log(data.getAll('user')); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 控制提交数据原生实现前台2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> window.onload=function (){ let oUser=document.getElementById('user'); let oPass=document.getElementById('pass'); let oBtn=document.getElementById('btn1'); oBtn.onclick=function (){ let data=new FormData(); data.set('user', oUser.value); data.set('pass', oPass.value); // let oAjax=new XMLHttpRequest(); //GET let arr=[]; data.forEach((value, key)=>{ arr.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`); }); oAjax.open('GET', `http://localhost:8080/api?${arr.join('&amp;')}`, true); oAjax.setRequestHeader('my-origin-blue', window.location.hostname); oAjax.send(); //POST /*oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); oAjax.send(data);*/ oAjax.onreadystatechange=function (){ if(oAjax.readyState==4){ if(oAjax.status>=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304){ alert('成功:'+oAjax.responseText); }else{ alert('失败'); } } }; }; }; &lt;/script> &lt;/head> &lt;body> 用户：&lt;input type="text" id="user" />&lt;br> 密码：&lt;input type="password" id="pass" />&lt;br> &lt;input type="button" value="提交" id="btn1"> &lt;/body> &lt;/html> 后台server.js const http=require('http'); const urlLib=require('url'); const querystring=require('querystring'); http.createServer((req, res)=>{ console.log(req.headers['my-origin-blue']); //if(req.headers['origin']=='null' || /^https?:\/\/(\w+\.)+abc\.com/.test(req.headers['origin'])){ if(req.headers['origin']=='null' || req.headers['origin'].startsWith('http://localhost')){ res.setHeader('Access-Control-Allow-Origin', '*'); } let {pathname: url, query: get}=urlLib.parse(req.url, true); let arr=[]; req.on('data', data=>{ arr.push(data); }); req.on('end', ()=>{ let post=querystring.parse(Buffer.concat(arr).toString()); console.log(url, get, post); res.write('asdfasdf'); res.end(); }); }).listen(8080); 文件上传express框架实现安装依赖package.json { "name": "2018-2-6", "version": "1.0.0", "description": "", "main": "1.js", "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "node server.js" }, "keywords": [], "author": "", "license": "ISC", "devDependencies": { "body-parser": "^1.18.2", "express": "^4.16.2", "multer": "^1.3.0" } } 前台3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> window.onload=function (){ let oUser=document.getElementById('user'); let oPass=document.getElementById('pass'); let oF=document.getElementById('f1'); let oBtn=document.getElementById('btn1'); oBtn.onclick=function (){ let data=new FormData(); data.set('user', oUser.value); data.set('pass', oPass.value); Array.from(oF.files).forEach(file=>{ data.append('f1', file); }); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.send(data); oAjax.onreadystatechange=function (){ if(oAjax.readyState==4){ if(oAjax.status>=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304){ alert('成功'); }else{ alert('失败'); } } }; }; }; &lt;/script> &lt;/head> &lt;body> 用户：&lt;input type="text" id="user" />&lt;br> 密码：&lt;input type="password" id="pass" />&lt;br> 头像：&lt;input type="file" id="f1" multiple />&lt;br> &lt;input type="button" value="提交" id="btn1"> &lt;/body> &lt;/html> 后台express_server.js const express=require('express'); //主体 const body=require('body-parser'); //接收普通POST数据 const multer=require('multer'); //接收文件POST数据 //let server=http.createServer((req, res)=>{}); //server.listen(8080); let server=express(); server.listen(8080); //中间件 server.use(body.urlencoded({extended: false})); let multerObj=multer({dest: './upload/'}); server.use(multerObj.any()); //处理请求 server.post('/api', (req, res)=>{ if(req.headers['origin']=='null' || req.headers['origin'].startsWith('http://localhost')){ res.setHeader('Access-Control-Allow-Origin', '*'); } res.send("OK"); console.log(req.body); //普通POST数据 console.log(req.files); //文件POST数据，req.files来自于multer }); // server.use(express.static('./www/')); cors跨域早期跨域解决方案是使用jsonp ajax1.0的时代，浏览器请求服务器的时候，请求头并不会携带origin,对于跨域的解决方案是使用其它的手段。 ajax2.0以后，浏览器请求服务器，请求头中会有origin ,服务器接到请求要验证请求头中的origin认不认识 认识的话则进行设置res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); 浏览器接收服务器的响应后，查看响应头中Access-Control-Allow-Origin是否进行了设置，如果设置了*，则表示允许本次请求后成功处理响应。 关键代码 文件拖拽 ondragenter 拖着东西进入 ondragleave 拖着东西离开 ondragover 悬停 ondrop 松手 代码&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> .box {width:400px; height:150px; border:1px solid black; background:#CCC; position: absolute; margin-left: -200px; margin-top: -75px; left:50%; top:50%; text-align:center; line-height:150px;} &lt;/style> &lt;script> window.onload=function (){ let oBox=document.querySelector('.box'); oBox.ondragenter=function (){ oBox.innerHTML='松手上传'; }; oBox.ondragleave=function (){ oBox.innerHTML='请拖到这里'; }; oBox.ondragover=function (){ //只要鼠标还没松手、并且还没离开，一直不停发生 console.log("aaaa"); //ondragover不阻止默认事件，ondrop不会触发 return false; }; oBox.ondrop=function (ev){ //alert('松手'); let data=new FormData(); Array.from(ev.dataTransfer.files).forEach(file=>{ data.append('f1', file); }); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.send(data); oAjax.onreadystatechange=function (){ if(oAjax.readyState==4){ if(oAjax.status>=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304){ alert('上传成功'); }else{ alert('上传失败'); } } }; return false; }; }; &lt;/script> &lt;/head> &lt;body> &lt;div class="box"> 请拖到这里 &lt;/div> &lt;/body> &lt;/html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ajax2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket原理]]></title>
    <url>%2F2019%2F05%2F12%2Fwebsocket-yuan-li%2F</url>
    <content type="text"><![CDATA[websocket 双向通信 性能高 WebSocket是前台的东西，是HTML5带的一种东西 只有前台有WebSocket这个东西 后台没有，后台有Socket 使用socket.io实现WebSocket引入依赖{ "name": "2018-2-3", "version": "1.0.0", "description": "", "main": "server.js", "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "node server.js" }, "author": "", "license": "ISC", "devDependencies": { "socket.io": "^2.0.4" } } 前台1.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> #ul1 {width:400px; height:300px; border:1px solid black; overflow:auto;} #ul1 li.me {color:green} .err_box {width:100%; height:20px; line-height: 20px; text-align:center; color:red; display:none} &lt;/style> &lt;script src="http://localhost:8080/socket.io/socket.io.js" charset="utf-8">&lt;/script> &lt;script> let sock=io.connect('ws://localhost:8080/'); sock.on('connect', ()=>{ console.log('已连接'); document.getElementsByClassName('err_box')[0].style.display='none'; }); sock.on('disconnect', ()=>{ console.log('已断开'); document.getElementsByClassName('err_box')[0].style.display='block'; }); //聊天室 window.onload=function (){ let oTxt=document.getElementById('txt1'); let oBtn=document.getElementById('btn1'); let oUl=document.getElementById('ul1'); oBtn.onclick=function (){ sock.emit('msg', oTxt.value); let oLi=document.createElement('li'); oLi.innerHTML=oTxt.value; oLi.className='me'; oTxt.value=''; oUl.appendChild(oLi); }; sock.on('msg', str=>{ let oLi=document.createElement('li'); oLi.innerHTML=str; oUl.appendChild(oLi); }); }; &lt;/script> &lt;/head> &lt;body> &lt;div class="err_box"> 无法连接到服务器，请检查网络 &lt;/div> &lt;ul id="ul1">&lt;/ul> &lt;textarea rows="4" cols="60" id="txt1">&lt;/textarea> &lt;input type="button" value="发送" id="btn1"> &lt;/body> &lt;/html> 后台server.js const http=require('http'); const io=require('socket.io'); let httpServer=http.createServer((req, res)=>{ }); httpServer.listen(8080); // let wsServer=io.listen(httpServer); let aSock=[]; wsServer.on('connection', sock=>{ aSock.push(sock); //断开连接 sock.on('disconnect', ()=>{ let n=aSock.indexOf(sock); if(n!=-1){ aSock.splice(n, 1); } }); sock.on('msg', str=>{ aSock.forEach(s=>{ if(s!=sock){ s.emit('msg', str); } }); }); }); setInterval(function (){ console.log(aSock.length); }, 500); 原生WebSocket实现前台raw_client.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let sock=new WebSocket('ws://localhost:8080/'); sock.emit=function (name, ...args){ alert(JSON.stringify({name, data: [...args]})); sock.send(JSON.stringify({name, data: [...args]})); }; //连上了 sock.onopen=function (){ alert('连接上了'); //发送数据 sock.emit('msg', 12, 5); }; //有数据 sock.onmessage=function (){ alert('有消息过来'); }; //断开了 sock.onclose=function (){ alert('断了'); }; &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 后台建立连接原始数据GET / HTTP/1.1 Host: localhost:8080 Connection: Upgrade Pragma: no-cache Cache-Control: no-cache Upgrade: websocket Origin: file:// Sec-WebSocket-Version: 13 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3315.4 Safari/537.36 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7,es;q=0.6,fr;q=0.5,pt;q=0.4 Sec-WebSocket-Key: +0jgXtYyVeG28Gn1CLUKIg== Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits分析原始数据 第一行删掉 Host: localhost:8080 Connection: Upgrade Pragma: no-cache Cache-Control: no-cache Upgrade: websocket Origin: file:// Sec-WebSocket-Version: 13 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3315.4 Safari/537.36 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7,es;q=0.6,fr;q=0.5,pt;q=0.4 Sec-WebSocket-Key: +0jgXtYyVeG28Gn1CLUKIg== Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits 舍弃第一行和最后两行 lines=lines.slice(1, lines.length-2); 每行数据用”: “切开 代码raw_server.js 引入net模块 const http=require('http'); const net=require('net'); //TCP 原生Socket const crypto=require('crypto'); /* let server=http.createServer((req, res)=>{ console.log('连接'); }); server.listen(8080); */ let server=net.createServer(sock=>{ console.log('连接'); //数据过来——握手只有一次 sock.once('data', data=>{ console.log('hand shake start...'); let str=data.toString(); let lines=str.split('\r\n'); //舍弃第一行和最后两行 lines=lines.slice(1, lines.length-2); //切开 let headers={}; lines.forEach(line=>{ let [key, val]=line.split(': '); headers[key.toLowerCase()]=val; }); //console.log(headers); if(headers['upgrade']!='websocket'){ console.log('其他协议', headers['upgrade']); sock.end(); }else if(headers['sec-websocket-version']!=13){ console.log('版本不对', headers['sec-websocket-version']); sock.end(); }else{ let key=headers['sec-websocket-key']; let mask='258EAFA5-E914-47DA-95CA-C5AB0DC85B11'; //sha1(key+mask)->base64=>client let hash=crypto.createHash('sha1'); hash.update(key+mask); let key2=hash.digest('base64'); sock.write(`HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: ${key2}\r\n\r\n`); console.log('hand shake end'); //真正的数据 sock.on('data', data=>{ console.log('有数据'); console.log(data); }); } }); //断开了 sock.on('end', ()=>{ console.log('客户端已断开'); }); }); server.listen(8080); 解析真正数据真正数据 81 9c 11 2d f8 bd 数据..... 10000001 10011100 00010001 00101101 11111000 10111101 11 2d f8 bd 6a 0f 96 dc 7c 48 da 87 33 40 8b da 33 01 da d9 70 59 99 9f 2b 76 c9 8f 3d 18 a5 c0 1 000 0001 1 0011100 00010001 00101101 11111000 10111101 F RSV opcode M payload masking-key I A 28个字 N S K帧结构 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+-------------------------------+ | Extended payload length continued, if payload len == 127 | +-------------------------------+-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------+-------------------------------+ | Payload Data continued ... | +---------------------------------------------------------------+ | Payload Data continued ... | +---------------------------------------------------------------+ FIN 1bit 是否最后一帧 RSV 3bit 预留 Opcode 4bit 帧类型 Mask 1bit 掩码，是否加密数据，默认必须置为1 Payload 7bit 长度 Masking-key 1 or 4 bit 掩码 Payload data (x + y) bytes 数据 Extension data x bytes 扩展数据 Application data y bytes 程序数据 传递数据单位1位(bit)8位等于1字节(byte) 代码raw_server2.js const http=require('http'); const net=require('net'); //TCP 原生Socket const crypto=require('crypto'); /* let server=http.createServer((req, res)=>{ console.log('连接'); }); server.listen(8080); */ let server=net.createServer(sock=>{ console.log('连接'); //数据过来——握手只有一次 sock.once('data', data=>{ console.log('hand shake start...'); let str=data.toString(); let lines=str.split('\r\n'); //舍弃第一行和最后两行 lines=lines.slice(1, lines.length-2); //切开 let headers={}; lines.forEach(line=>{ let [key, val]=line.split(': '); headers[key.toLowerCase()]=val; }); //console.log(headers); if(headers['upgrade']!='websocket'){ console.log('其他协议', headers['upgrade']); sock.end(); }else if(headers['sec-websocket-version']!=13){ console.log('版本不对', headers['sec-websocket-version']); sock.end(); }else{ let key=headers['sec-websocket-key']; let mask='258EAFA5-E914-47DA-95CA-C5AB0DC85B11'; //sha1(key+mask)->base64=>client let hash=crypto.createHash('sha1'); hash.update(key+mask); let key2=hash.digest('base64'); sock.write(`HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: ${key2}\r\n\r\n`); console.log('hand shake end'); //真正的数据 sock.on('data', data=>{ console.log('有数据'); let FIN=data[0]&amp;0x001; let opcode=data[0]&amp;0x0F0; let mask=data[1]&amp;0x001; let payload=data[1]&amp;0x0FE; console.log(FIN, opcode); console.log(mask, payload); }); } }); //断开了 sock.on('end', ()=>{ console.log('客户端已断开'); }); }); server.listen(8080); 总结流程引入net模块握手 客户端:version:13、sec-websocket-key:xxxxx、sha1(key+mask)=&gt;base64 服务端:101 Switching Protocols、sec-websocket-accept: base64客户端 onopen onmessage onclose 服务端 net.createServer(sock=&gt;{}); sock.once(‘data’, 握手); sock.on(‘data’, 数据请求); sock.on(‘end’); 数据帧解析参考WebSocket 实战 WebSocket - Wikipedia]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC多线程并发、JVM和GC]]></title>
    <url>%2F2019%2F05%2F07%2Fjuc-duo-xian-cheng-bing-fa-jvm-he-gc%2F</url>
    <content type="text"><![CDATA[Callable接口Runnable和Callable的区别 Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的 Callable规定的方法是call(),Runnable规定的方法是run() Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void) call方法可以抛出异常，run方法不可以 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。 Callable接口callable有个&lt;V&gt;,这个V就是call函数的返回值类型 package java.util.concurrent; /** * A task that returns a result and may throw an exception. * Implementors define a single method with no arguments called * {@code call}. * * &lt;p>The {@code Callable} interface is similar to {@link * java.lang.Runnable}, in that both are designed for classes whose * instances are potentially executed by another thread. A * {@code Runnable}, however, does not return a result and cannot * throw a checked exception. * * &lt;p>The {@link Executors} class contains utility methods to * convert from other common forms to {@code Callable} classes. * * @see Executor * @since 1.5 * @author Doug Lea * @param &lt;V> the result type of method {@code call} */ @FunctionalInterface public interface Callable&lt;V> { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception; } FutureTask类/** * A cancellable asynchronous computation. This class provides a base * implementation of {@link Future}, with methods to start and cancel * a computation, query to see if the computation is complete, and * retrieve the result of the computation. The result can only be * retrieved when the computation has completed; the {@code get} * methods will block if the computation has not yet completed. Once * the computation has completed, the computation cannot be restarted * or cancelled (unless the computation is invoked using * {@link #runAndReset}). * * &lt;p>A {@code FutureTask} can be used to wrap a {@link Callable} or * {@link Runnable} object. Because {@code FutureTask} implements * {@code Runnable}, a {@code FutureTask} can be submitted to an * {@link Executor} for execution. * * &lt;p>In addition to serving as a standalone class, this class provides * {@code protected} functionality that may be useful when creating * customized task classes. * * @since 1.5 * @author Doug Lea * @param &lt;V> The result type returned by this FutureTask's {@code get} methods */ public class FutureTask&lt;V> implements RunnableFuture&lt;V> /** * Creates a {@code FutureTask} that will, upon running, execute the * given {@code Callable}. * * @param callable the callable task * @throws NullPointerException if the callable is null */ public FutureTask(Callable callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable } RunnableFuture接口package java.util.concurrent; /** * A {@link Future} that is {@link Runnable}. Successful execution of * the {@code run} method causes completion of the {@code Future} * and allows access to its results. * @see FutureTask * @see Executor * @since 1.6 * @author Doug Lea * @param &lt;V> The result type returned by this Future's {@code get} method */ public interface RunnableFuture&lt;V> extends Runnable, Future&lt;V> { /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run(); } 测试public class CallableTest { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); FutureTask&lt;Integer> result = new FutureTask&lt;Integer>(mt); new Thread(result).start(); // 获取运算结果是同步过程，即 call 方法执行完成，才能获取结果 Integer sum = result.get(); System.out.println(sum); } } class MyThread implements Callable&lt;Integer> { @Override public Integer call() throws Exception { int sum = 0; for (int i = 1; i &lt;= 100; i++) { sum += i; } return sum; } } 当某个请求需要在后端完成 N 次统计结果时，我们就可以使用该方式创建 N 个线程进行（并行）统计，而不需要同步等待其他统计操作完成后才统计另一个结果。 线程池线程池3个常用方式Executors.newFixedThreadPool /** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue. At any point, at most * {@code nThreads} threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks. The threads in the pool will exist * until it is explicitly {@link ExecutorService#shutdown shutdown}. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if {@code nThreads &lt;= 0} */ public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable>()); } Executors.newSingleThreadExecutor /** * Creates an Executor that uses a single worker thread operating * off an unbounded queue. (Note however that if this single * thread terminates due to a failure during execution prior to * shutdown, a new one will take its place if needed to execute * subsequent tasks.) Tasks are guaranteed to execute * sequentially, and no more than one task will be active at any * given time. Unlike the otherwise equivalent * {@code newFixedThreadPool(1)} the returned executor is * guaranteed not to be reconfigurable to use additional threads. * * @return the newly created single-threaded Executor */ public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable>())); } Executors.newCachedThreadPool /** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available. These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to {@code execute} will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using {@link ThreadPoolExecutor} constructors. * * @return the newly created thread pool */ public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable>()); } 线程池7大参数Java 多线程开发之 Callable 与线程池（三） - 后端 - 掘金 int corePoolSize 线程池核心线程个数，默认线程池线程个数为 0，只有接到任务才新建线程 int maximumPoolSize 线程池最大线程数量 long keepAliveTime 线程池空闲时，线程存活的时间，当线程池中的线程数大于 corePoolSize 时才会起作用 TimeUnit unit 时间单位 BlockingQueue workQueue 阻塞队列，当达到线程数达到 corePoolSize 时，将任务放入队列等待线程处理 ThreadFactory threadFactory 线程工厂 RejectedExecutionHandler handler 线程拒绝策略，当队列满了并且线程个数达到 maximumPoolSize 后采取的策略 /** * Creates a new {@code ThreadPoolExecutor} with the given initial * parameters and default thread factory. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless {@code allowCoreThreadTimeOut} is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the {@code keepAliveTime} argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the {@code Runnable} * tasks submitted by the {@code execute} method. * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br> * {@code corePoolSize &lt; 0}&lt;br> * {@code keepAliveTime &lt; 0}&lt;br> * {@code maximumPoolSize &lt;= 0}&lt;br> * {@code maximumPoolSize &lt; corePoolSize} * @throws NullPointerException if {@code workQueue} * or {@code handler} is null */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable> workQueue, RejectedExecutionHandler handler) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler); } /** * Creates a new {@code ThreadPoolExecutor} with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless {@code allowCoreThreadTimeOut} is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the {@code keepAliveTime} argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the {@code Runnable} * tasks submitted by the {@code execute} method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br> * {@code corePoolSize &lt; 0}&lt;br> * {@code keepAliveTime &lt; 0}&lt;br> * {@code maximumPoolSize &lt;= 0}&lt;br> * {@code maximumPoolSize &lt; corePoolSize} * @throws NullPointerException if {@code workQueue} * or {@code threadFactory} or {@code handler} is null */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } 线程池的合理配置获取系统设备处理器核数Runtime.getRuntime().availableProcessors() 考虑因素CPU密集型线程数 = CPU可用核心数/(1 - 阻塞系数)，其中阻塞系数的取值在0和1之间 IO密集型线程池的工作原理 execute方法执行逻辑核心线程数如果当前运行的线程少于corePoolSize，则会创建新的线程来执行新的任务 加入阻塞队列如果运行的线程个数等于或者大于corePoolSize，则会将提交的任务存放到阻塞队列workQueue中 扩容如果当前workQueue队列已满的话，则会创建新的线程来执行任务 拒绝策略如果线程个数已经超过了maximumPoolSize，则会使用饱和策略RejectedExecutionHandler来进行处理 JVM常见故障StackOverflowErrorpublic class StackOverflowErrorDemo { public static void main(String[] args) { stackOverflowError(); } private static void stackOverflowError() { stackOverflowError(); } } 结果 Exception in thread &quot;main&quot; java.lang.StackOverflowError at StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:7) at StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:7) at StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:7)Java heap spaceimport java.util.Random; public class JavaHeapSpaceDemo { public static void main(String[] args) { String str = "abc"; while (true){ str+=str+new Random().nextInt(111111)+new Random().nextInt(222222); str.intern(); } } } 运行 配置参数 结果 Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448) at java.lang.StringBuilder.append(StringBuilder.java:136) at JavaHeapSpaceDemo.main(JavaHeapSpaceDemo.java:9)GC overhead limit exceededGC回收时间过长时会抛出OutOfMemoryError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存 连续多次GC都只回收了不到2%的极端情况下才会抛出。假如不抛出GC overhead limit 错误会发生什么情况呢？ 那就是GC清理的这么点内存很快会再次填满，迫使GC再次致谢，这样就形成了恶性循环，CPU使用率一直是100%，而GC却没有任何成果 import java.util.ArrayList; import java.util.List; public class GCOverheadDemo { public static void main(String[] args) { int i = 0; List&lt;String> list = new ArrayList&lt;>(); try { while (true) { list.add(String.valueOf(++i).intern()); } } catch (Exception e) { System.out.println("**************i:" + i); e.printStackTrace(); throw e; } } } 运行参数配置 结果 [GC (Allocation Failure) [PSYoungGen: 2048K-&gt;480K(2560K)] 2048K-&gt;916K(9728K), 0.0043924 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 2528K-&gt;480K(2560K)] 2964K-&gt;2709K(9728K), 0.0022096 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2528K-&gt;504K(2560K)] 4757K-&gt;4835K(9728K), 0.0028678 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2552K-&gt;488K(2560K)] 6883K-&gt;6764K(9728K), 0.0032660 secs] [Times: user=0.06 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 488K-&gt;0K(2560K)] [ParOldGen: 6276K-&gt;6188K(7168K)] 6764K-&gt;6188K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0784031 secs] [Times: user=0.25 sys=0.00, real=0.08 secs] [Full GC (Ergonomics) [PSYoungGen: 2048K-&gt;738K(2560K)] [ParOldGen: 6188K-&gt;7039K(7168K)] 8236K-&gt;7777K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0437521 secs] [Times: user=0.19 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2048K-&gt;2046K(2560K)] [ParOldGen: 7039K-&gt;7039K(7168K)] 9087K-&gt;9086K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0405225 secs] [Times: user=0.28 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2048K-&gt;2047K(2560K)] [ParOldGen: 7039K-&gt;7039K(7168K)] 9087K-&gt;9087K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0315932 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7039K-&gt;7039K(7168K)] 9087K-&gt;9087K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0350043 secs] [Times: user=0.23 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7041K-&gt;7041K(7168K)] 9089K-&gt;9089K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0343159 secs] [Times: user=0.25 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7043K-&gt;7043K(7168K)] 9091K-&gt;9091K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0335877 secs] [Times: user=0.33 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7044K-&gt;7044K(7168K)] 9092K-&gt;9092K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0324352 secs] [Times: user=0.20 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7046K-&gt;7046K(7168K)] 9094K-&gt;9094K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0329995 secs] [Times: user=0.20 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7048K-&gt;7048K(7168K)] 9096K-&gt;9096K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0342704 secs] [Times: user=0.14 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7050K-&gt;7050K(7168K)] 9098K-&gt;9098K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0336287 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7051K-&gt;7051K(7168K)] 9099K-&gt;9099K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0324847 secs] [Times: user=0.22 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7053K-&gt;7053K(7168K)] 9101K-&gt;9101K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0342784 secs] [Times: user=0.22 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7055K-&gt;7055K(7168K)] 9103K-&gt;9103K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0334541 secs] [Times: user=0.33 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7057K-&gt;7057K(7168K)] 9105K-&gt;9105K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0341891 secs] [Times: user=0.22 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7058K-&gt;7058K(7168K)] 9106K-&gt;9106K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0302677 secs] [Times: user=0.19 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7060K-&gt;7060K(7168K)] 9108K-&gt;9108K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0326491 secs] [Times: user=0.19 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7062K-&gt;7062K(7168K)] 9110K-&gt;9110K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0327378 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7064K-&gt;7064K(7168K)] 9112K-&gt;9112K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0325700 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7065K-&gt;7065K(7168K)] 9113K-&gt;9113K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0322844 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7067K-&gt;7067K(7168K)] 9115K-&gt;9115K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0269232 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7069K-&gt;7069K(7168K)] 9117K-&gt;9117K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0343916 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7071K-&gt;7071K(7168K)] 9119K-&gt;9119K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0329739 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7072K-&gt;7072K(7168K)] 9120K-&gt;9120K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0311813 secs] [Times: user=0.05 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7074K-&gt;7074K(7168K)] 9122K-&gt;9122K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0385086 secs] [Times: user=0.05 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7078K-&gt;7058K(7168K)] 9126K-&gt;9106K(9728K), [Metaspace: 3228K-&gt;3228K(1056768K)], 0.0489022 secs] [Times: user=0.17 sys=0.00, real=0.05 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7060K-&gt;7060K(7168K)] 9108K-&gt;9108K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0297955 secs] [Times: user=0.14 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7061K-&gt;7061K(7168K)] 9109K-&gt;9109K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0277327 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7063K-&gt;7063K(7168K)] 9111K-&gt;9111K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0337749 secs] [Times: user=0.25 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7065K-&gt;7065K(7168K)] 9113K-&gt;9113K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0274153 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7067K-&gt;7067K(7168K)] 9115K-&gt;9115K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0325819 secs] [Times: user=0.16 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7069K-&gt;7069K(7168K)] 9117K-&gt;9117K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0353046 secs] [Times: user=0.19 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7070K-&gt;7070K(7168K)] 9118K-&gt;9118K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0310516 secs] [Times: user=0.22 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7072K-&gt;7072K(7168K)] 9120K-&gt;9120K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0344718 secs] [Times: user=0.13 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7074K-&gt;7074K(7168K)] 9122K-&gt;9122K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0291248 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7076K-&gt;7076K(7168K)] 9124K-&gt;9124K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0330405 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7078K-&gt;7078K(7168K)] 9126K-&gt;9126K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0394979 secs] [Times: user=0.16 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7079K-&gt;7079K(7168K)] 9127K-&gt;9127K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0327822 secs] [Times: user=0.16 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7083K-&gt;7081K(7168K)] 9131K-&gt;9129K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0320142 secs] [Times: user=0.17 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7083K-&gt;7083K(7168K)] 9131K-&gt;9131K(9728K), [Metaspace: 3234K-&gt;3234K(1056768K)], 0.0321638 secs] [Times: user=0.19 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7088K-&gt;7088K(7168K)] 9136K-&gt;9136K(9728K), [Metaspace: 3234K-&gt;3234K(1056768K)], 0.0324113 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7090K-&gt;7090K(7168K)] 9138K-&gt;9138K(9728K), [Metaspace: 3234K-&gt;3234K(1056768K)], 0.0362137 secs] [Times: user=0.11 sys=0.00, real=0.04 secs] Exception in thread &quot;main&quot; [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;0K(2560K)] [ParOldGen: 7112K-&gt;633K(7168K)] 9160K-&gt;633K(9728K), [Metaspace: 3269K-&gt;3269K(1056768K)], 0.0058288 secs] [Times: user=0.11 sys=0.00, real=0.01 secs] java.lang.OutOfMemoryError: GC overhead limit exceeded at java.lang.Integer.toString(Integer.java:403) at java.lang.String.valueOf(String.java:3099) at GCOverheadDemo.main(GCOverheadDemo.java:13) Heap PSYoungGen total 2560K, used 126K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000) eden space 2048K, 6% used [0x00000000ffd00000,0x00000000ffd1fa60,0x00000000fff00000) from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) to space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen total 7168K, used 633K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000) object space 7168K, 8% used [0x00000000ff600000,0x00000000ff69e6f8,0x00000000ffd00000) Metaspace used 3334K, capacity 4500K, committed 4864K, reserved 1056768K class space used 360K, capacity 388K, committed 512K, reserved 1048576KDirect buffer memory元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 写NIO程序经常使用ByteBuffer来读取或者写入数据，这是一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后统一一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一下场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 ByteBuffer.allocate(capability)第一种方式分配JVM堆内存，属于GC管辖范围，由于需要拷贝索引速度相对较慢。 ByteBuffer.allocateDirect(capability)第二种方式是分配OS本地内存，不属于GC管辖范围，由于不需要内存拷贝索引速度相对较快。 但如果不断分配本地内存，堆内存很少使用，那么JVM久不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemory，那程序就直接崩溃了。 import java.nio.ByteBuffer; public class DriectBufferMemoryDemo { public static void main(String[] args) { System.out.println("配置的maxDirectMemory:"+sun.misc.VM.maxDirectMemory()/(double)1024/1024+"MB"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } ByteBuffer buffer = ByteBuffer.allocateDirect(6 * 1024 * 1024); } } 运行参数配置 -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m结果 配置的maxDirectMemory:5.0MB [GC (Allocation Failure) [PSYoungGen: 2048K-&gt;488K(2560K)] 2048K-&gt;892K(9728K), 0.0008431 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (System.gc()) [PSYoungGen: 1269K-&gt;504K(2560K)] 1673K-&gt;1132K(9728K), 0.0010115 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 504K-&gt;0K(2560K)] [ParOldGen: 628K-&gt;1028K(7168K)] 1132K-&gt;1028K(9728K), [Metaspace: 3741K-&gt;3741K(1056768K)], 0.0091449 secs] [Times: user=0.13 sys=0.00, real=0.01 secs] Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:694) at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311) at DriectBufferMemoryDemo.main(DriectBufferMemoryDemo.java:11) Heap PSYoungGen total 2560K, used 49K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000) eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0c5d0,0x00000000fff00000) from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) to space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen total 7168K, used 1028K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000) object space 7168K, 14% used [0x00000000ff600000,0x00000000ff7011b0,0x00000000ffd00000) Metaspace used 3772K, capacity 4536K, committed 4864K, reserved 1056768K class space used 414K, capacity 428K, committed 512K, reserved 1048576Kunable to create new native thread高并发请求服务器时，经常出现如下异常： java.lang.OutOfMemoryError: unable to create new native thread，准确地讲该native thread异常与对应的平台有关 导致原因： 你的应用创建了太多线程了，一个应用进程创建多个线程，超过系统承载极限 你的应用创建超过这个数量，就会报java.lang.OutOfMemoryError: unable to create new native thread 解决办法： 想办法降低你应用程序创建线程的数量，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低 对于有的应用，确实需要创建很多线程，远超过Linux系统的默认1024个线程的限制，可以通过修改Linux服务器配置，扩大Linux默认限制 public class UnableCreateNewThreadDemo { public static void main(String[] args) { for(int i = 1;;i++){ System.out.println("********** i = "+i); new Thread(()->{ try { Thread.sleep(Integer.MAX_VALUE); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } } 编译运行 [es@192 tmp]$ javac -d . UnableCreateNewThreadDemo.java [es@192 tmp]$ java UnableCreateNewThreadDemo ********** i = 4075 ********** i = 4076 Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread at java.lang.Thread.start0(Native Method) at java.lang.Thread.start(Thread.java:717) at UnableCreateNewThreadDemo.main(UnableCreateNewThreadDemo.java:11) ^CJava HotSpot(TM) 64-Bit Server VM warning: Exception java.lang.OutOfMemoryError occurred dispatching signal SIGINT to handler- the VM may need to be forcibly terminated ^CJava HotSpot(TM) 64-Bit Server VM warning: Exception java.lang.OutOfMemoryError occurred dispatching signal SIGINT to handler- the VM may need to be forcibly terminated Java HotSpot(TM) 64-Bit Server VM warning: Exception java.lang.OutOfMemoryError occurred dispatching signal SIGTERM to handler- the VM may need to be forcibly terminated ^CJava HotSpot(TM) 64-Bit Server VM warning: Exception java.lang.OutOfMemoryError occurred dispatching signal SIGINT to handler- the VM may need to be forcibly terminated Killed 以root用户登录开启另外一个终端 [root@192 ~]# jps 8257 Jps 4120 UnableCreateNewThreadDemo [root@192 ~]# kill -9 4120修改用户线程数 [root@192 ~]# ulimit -u 4096 [root@192 ~]# vim /etc/security/limits.d/90-nproc.conf MetaspaceJava8及之后的版本使用Metaspace来替代永久代。 Metaspace是方法区在HotSpot的实现，它与永久代最大的区别在于：Metaspace并不在虚拟机内存中而是使用本地内存，也即在java8中，classe metadata（the virtual machines internal presentation of java class），被存储在叫做Metaspace的native memory 永久代（java8后被元空间Metaspace取代了）存放了一下信息： 虚拟机加载类信息 常量池 静态变量 即时编译后的代码 模拟Metaspace空间溢出，我们不断生成类往元空间灌，类占据的空间总是会超过Metaspace指定的空间大小的 import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class MetaspaceOOMTest { public static void main(String[] args) { int i = 0; try { while (true) { i++; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMTest.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { return methodProxy.invokeSuper(o, args); } }); enhancer.create(); } } catch (Exception e) { System.out.println("*************多少次后发生了异常：" + i); e.printStackTrace(); } } static class OOMTest { } } 运行配置参数 -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8深入剖析与实战]]></title>
    <url>%2F2019%2F05%2F04%2Fjava8-shen-ru-pou-xi-yu-shi-zhan%2F</url>
    <content type="text"><![CDATA[函数式接口 定义 如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口 如果在某个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口 如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看作是函数式接口 /* * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * * */ package java.lang; import java.lang.annotation.*; /** * An informative annotation type used to indicate that an interface * type declaration is intended to be a &lt;i>functional interface&lt;/i> as * defined by the Java Language Specification. * * Conceptually, a functional interface has exactly one abstract * method. Since {@linkplain java.lang.reflect.Method#isDefault() * default methods} have an implementation, they are not abstract. If * an interface declares an abstract method overriding one of the * public methods of {@code java.lang.Object}, that also does * &lt;em>not&lt;/em> count toward the interface's abstract method count * since any implementation of the interface will have an * implementation from {@code java.lang.Object} or elsewhere. * * &lt;p>Note that instances of functional interfaces can be created with * lambda expressions, method references, or constructor references. * * &lt;p>If a type is annotated with this annotation type, compilers are * required to generate an error message unless: * * &lt;ul> * &lt;li> The type is an interface type and not an annotation type, enum, or class. * &lt;li> The annotated type satisfies the requirements of a functional interface. * &lt;/ul> * * &lt;p>However, the compiler will treat any interface meeting the * definition of a functional interface as a functional interface * regardless of whether or not a {@code FunctionalInterface} * annotation is present on the interface declaration. * * @jls 4.3.2. The Class Object * @jls 9.8 Functional Interfaces * @jls 9.4.3 Interface Method Body * @since 1.8 */ @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface FunctionalInterface {} Runnable接口 函数式接口的创建 lambda表达式、方法引用、构造函数引用 Note that instances of functional interfaces can be created withlambda expressions, method references, or constructor references. Stream流 /* * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * * */ package java.util.stream; import java.nio.charset.Charset; import java.nio.file.Files; import java.nio.file.Path; import java.util.Arrays; import java.util.Collection; import java.util.Comparator; import java.util.Iterator; import java.util.Objects; import java.util.Optional; import java.util.Spliterator; import java.util.Spliterators; import java.util.concurrent.ConcurrentHashMap; import java.util.function.BiConsumer; import java.util.function.BiFunction; import java.util.function.BinaryOperator; import java.util.function.Consumer; import java.util.function.Function; import java.util.function.IntFunction; import java.util.function.Predicate; import java.util.function.Supplier; import java.util.function.ToDoubleFunction; import java.util.function.ToIntFunction; import java.util.function.ToLongFunction; import java.util.function.UnaryOperator; /** * A sequence of elements supporting sequential and parallel aggregate * operations. The following example illustrates an aggregate operation using * {@link Stream} and {@link IntStream}: * * &lt;pre>{@code * int sum = widgets.stream() * .filter(w -> w.getColor() == RED) * .mapToInt(w -> w.getWeight()) * .sum(); * }&lt;/pre> * * In this example, {@code widgets} is a {@code Collection&lt;Widget>}. We create * a stream of {@code Widget} objects via {@link Collection#stream Collection.stream()}, * filter it to produce a stream containing only the red widgets, and then * transform it into a stream of {@code int} values representing the weight of * each red widget. Then this stream is summed to produce a total weight. * * &lt;p>In addition to {@code Stream}, which is a stream of object references, * there are primitive specializations for {@link IntStream}, {@link LongStream}, * and {@link DoubleStream}, all of which are referred to as "streams" and * conform to the characteristics and restrictions described here. * * &lt;p>To perform a computation, stream * &lt;a href="package-summary.html#StreamOps">operations&lt;/a> are composed into a * &lt;em>stream pipeline&lt;/em>. A stream pipeline consists of a source (which * might be an array, a collection, a generator function, an I/O channel, * etc), zero or more &lt;em>intermediate operations&lt;/em> (which transform a * stream into another stream, such as {@link Stream#filter(Predicate)}), and a * &lt;em>terminal operation&lt;/em> (which produces a result or side-effect, such * as {@link Stream#count()} or {@link Stream#forEach(Consumer)}). * Streams are lazy; computation on the source data is only performed when the * terminal operation is initiated, and source elements are consumed only * as needed. * * &lt;p>Collections and streams, while bearing some superficial similarities, * have different goals. Collections are primarily concerned with the efficient * management of, and access to, their elements. By contrast, streams do not * provide a means to directly access or manipulate their elements, and are * instead concerned with declaratively describing their source and the * computational operations which will be performed in aggregate on that source. * However, if the provided stream operations do not offer the desired * functionality, the {@link #iterator()} and {@link #spliterator()} operations * can be used to perform a controlled traversal. * * &lt;p>A stream pipeline, like the "widgets" example above, can be viewed as * a &lt;em>query&lt;/em> on the stream source. Unless the source was explicitly * designed for concurrent modification (such as a {@link ConcurrentHashMap}), * unpredictable or erroneous behavior may result from modifying the stream * source while it is being queried. * * &lt;p>Most stream operations accept parameters that describe user-specified * behavior, such as the lambda expression {@code w -> w.getWeight()} passed to * {@code mapToInt} in the example above. To preserve correct behavior, * these &lt;em>behavioral parameters&lt;/em>: * &lt;ul> * &lt;li>must be &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a> * (they do not modify the stream source); and&lt;/li> * &lt;li>in most cases must be &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * (their result should not depend on any state that might change during execution * of the stream pipeline).&lt;/li> * &lt;/ul> * * &lt;p>Such parameters are always instances of a * &lt;a href="../function/package-summary.html">functional interface&lt;/a> such * as {@link java.util.function.Function}, and are often lambda expressions or * method references. Unless otherwise specified these parameters must be * &lt;em>non-null&lt;/em>. * * &lt;p>A stream should be operated on (invoking an intermediate or terminal stream * operation) only once. This rules out, for example, "forked" streams, where * the same source feeds two or more pipelines, or multiple traversals of the * same stream. A stream implementation may throw {@link IllegalStateException} * if it detects that the stream is being reused. However, since some stream * operations may return their receiver rather than a new stream object, it may * not be possible to detect reuse in all cases. * * &lt;p>Streams have a {@link #close()} method and implement {@link AutoCloseable}, * but nearly all stream instances do not actually need to be closed after use. * Generally, only streams whose source is an IO channel (such as those returned * by {@link Files#lines(Path, Charset)}) will require closing. Most streams * are backed by collections, arrays, or generating functions, which require no * special resource management. (If a stream does require closing, it can be * declared as a resource in a {@code try}-with-resources statement.) * * &lt;p>Stream pipelines may execute either sequentially or in * &lt;a href="package-summary.html#Parallelism">parallel&lt;/a>. This * execution mode is a property of the stream. Streams are created * with an initial choice of sequential or parallel execution. (For example, * {@link Collection#stream() Collection.stream()} creates a sequential stream, * and {@link Collection#parallelStream() Collection.parallelStream()} creates * a parallel one.) This choice of execution mode may be modified by the * {@link #sequential()} or {@link #parallel()} methods, and may be queried with * the {@link #isParallel()} method. * * @param &lt;T> the type of the stream elements * @since 1.8 * @see IntStream * @see LongStream * @see DoubleStream * @see &lt;a href="package-summary.html">java.util.stream&lt;/a> */ public interface Stream&lt;T> extends BaseStream&lt;T, Stream&lt;T>> { /** * Returns a stream consisting of the elements of this stream that match * the given predicate. * * &lt;p>This is an &lt;a href="package-summary.html#StreamOps">intermediate * operation&lt;/a>. * * @param predicate a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * predicate to apply to each element to determine if it * should be included * @return the new stream */ Stream&lt;T> filter(Predicate&lt;? super T> predicate); /** * Returns a stream consisting of the results of applying the given * function to the elements of this stream. * * &lt;p>This is an &lt;a href="package-summary.html#StreamOps">intermediate * operation&lt;/a>. * * @param &lt;R> The element type of the new stream * @param mapper a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function to apply to each element * @return the new stream */ &lt;R> Stream&lt;R> map(Function&lt;? super T, ? extends R> mapper); /** * Returns an {@code IntStream} consisting of the results of applying the * given function to the elements of this stream. * * &lt;p>This is an &lt;a href="package-summary.html#StreamOps"> * intermediate operation&lt;/a>. * * @param mapper a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function to apply to each element * @return the new stream */ IntStream mapToInt(ToIntFunction&lt;? super T> mapper); /** * Returns a {@code LongStream} consisting of the results of applying the * given function to the elements of this stream. * * &lt;p>This is an &lt;a href="package-summary.html#StreamOps">intermediate * operation&lt;/a>. * * @param mapper a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function to apply to each element * @return the new stream */ LongStream mapToLong(ToLongFunction&lt;? super T> mapper); /** * Returns a {@code DoubleStream} consisting of the results of applying the * given function to the elements of this stream. * * &lt;p>This is an &lt;a href="package-summary.html#StreamOps">intermediate * operation&lt;/a>. * * @param mapper a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function to apply to each element * @return the new stream */ DoubleStream mapToDouble(ToDoubleFunction&lt;? super T> mapper); /** * Returns a stream consisting of the results of replacing each element of * this stream with the contents of a mapped stream produced by applying * the provided mapping function to each element. Each mapped stream is * {@link java.util.stream.BaseStream#close() closed} after its contents * have been placed into this stream. (If a mapped stream is {@code null} * an empty stream is used, instead.) * * &lt;p>This is an &lt;a href="package-summary.html#StreamOps">intermediate * operation&lt;/a>. * * @apiNote * The {@code flatMap()} operation has the effect of applying a one-to-many * transformation to the elements of the stream, and then flattening the * resulting elements into a new stream. * * &lt;p>&lt;b>Examples.&lt;/b> * * &lt;p>If {@code orders} is a stream of purchase orders, and each purchase * order contains a collection of line items, then the following produces a * stream containing all the line items in all the orders: * &lt;pre>{@code * orders.flatMap(order -> order.getLineItems().stream())... * }&lt;/pre> * * &lt;p>If {@code path} is the path to a file, then the following produces a * stream of the {@code words} contained in that file: * &lt;pre>{@code * Stream&lt;String> lines = Files.lines(path, StandardCharsets.UTF_8); * Stream&lt;String> words = lines.flatMap(line -> Stream.of(line.split(" +"))); * }&lt;/pre> * The {@code mapper} function passed to {@code flatMap} splits a line, * using a simple regular expression, into an array of words, and then * creates a stream of words from that array. * * @param &lt;R> The element type of the new stream * @param mapper a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function to apply to each element which produces a stream * of new values * @return the new stream */ &lt;R> Stream&lt;R> flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R>> mapper); /** * Returns an {@code IntStream} consisting of the results of replacing each * element of this stream with the contents of a mapped stream produced by * applying the provided mapping function to each element. Each mapped * stream is {@link java.util.stream.BaseStream#close() closed} after its * contents have been placed into this stream. (If a mapped stream is * {@code null} an empty stream is used, instead.) * * &lt;p>This is an &lt;a href="package-summary.html#StreamOps">intermediate * operation&lt;/a>. * * @param mapper a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function to apply to each element which produces a stream * of new values * @return the new stream * @see #flatMap(Function) */ IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream> mapper); /** * Returns an {@code LongStream} consisting of the results of replacing each * element of this stream with the contents of a mapped stream produced by * applying the provided mapping function to each element. Each mapped * stream is {@link java.util.stream.BaseStream#close() closed} after its * contents have been placed into this stream. (If a mapped stream is * {@code null} an empty stream is used, instead.) * * &lt;p>This is an &lt;a href="package-summary.html#StreamOps">intermediate * operation&lt;/a>. * * @param mapper a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function to apply to each element which produces a stream * of new values * @return the new stream * @see #flatMap(Function) */ LongStream flatMapToLong(Function&lt;? super T, ? extends LongStream> mapper); /** * Returns an {@code DoubleStream} consisting of the results of replacing * each element of this stream with the contents of a mapped stream produced * by applying the provided mapping function to each element. Each mapped * stream is {@link java.util.stream.BaseStream#close() closed} after its * contents have placed been into this stream. (If a mapped stream is * {@code null} an empty stream is used, instead.) * * &lt;p>This is an &lt;a href="package-summary.html#StreamOps">intermediate * operation&lt;/a>. * * @param mapper a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function to apply to each element which produces a stream * of new values * @return the new stream * @see #flatMap(Function) */ DoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream> mapper); /** * Returns a stream consisting of the distinct elements (according to * {@link Object#equals(Object)}) of this stream. * * &lt;p>For ordered streams, the selection of distinct elements is stable * (for duplicated elements, the element appearing first in the encounter * order is preserved.) For unordered streams, no stability guarantees * are made. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">stateful * intermediate operation&lt;/a>. * * @apiNote * Preserving stability for {@code distinct()} in parallel pipelines is * relatively expensive (requires that the operation act as a full barrier, * with substantial buffering overhead), and stability is often not needed. * Using an unordered stream source (such as {@link #generate(Supplier)}) * or removing the ordering constraint with {@link #unordered()} may result * in significantly more efficient execution for {@code distinct()} in parallel * pipelines, if the semantics of your situation permit. If consistency * with encounter order is required, and you are experiencing poor performance * or memory utilization with {@code distinct()} in parallel pipelines, * switching to sequential execution with {@link #sequential()} may improve * performance. * * @return the new stream */ Stream&lt;T> distinct(); /** * Returns a stream consisting of the elements of this stream, sorted * according to natural order. If the elements of this stream are not * {@code Comparable}, a {@code java.lang.ClassCastException} may be thrown * when the terminal operation is executed. * * &lt;p>For ordered streams, the sort is stable. For unordered streams, no * stability guarantees are made. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">stateful * intermediate operation&lt;/a>. * * @return the new stream */ Stream&lt;T> sorted(); /** * Returns a stream consisting of the elements of this stream, sorted * according to the provided {@code Comparator}. * * &lt;p>For ordered streams, the sort is stable. For unordered streams, no * stability guarantees are made. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">stateful * intermediate operation&lt;/a>. * * @param comparator a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * {@code Comparator} to be used to compare stream elements * @return the new stream */ Stream&lt;T> sorted(Comparator&lt;? super T> comparator); /** * Returns a stream consisting of the elements of this stream, additionally * performing the provided action on each element as elements are consumed * from the resulting stream. * * &lt;p>This is an &lt;a href="package-summary.html#StreamOps">intermediate * operation&lt;/a>. * * &lt;p>For parallel stream pipelines, the action may be called at * whatever time and in whatever thread the element is made available by the * upstream operation. If the action modifies shared state, * it is responsible for providing the required synchronization. * * @apiNote This method exists mainly to support debugging, where you want * to see the elements as they flow past a certain point in a pipeline: * &lt;pre>{@code * Stream.of("one", "two", "three", "four") * .filter(e -> e.length() > 3) * .peek(e -> System.out.println("Filtered value: " + e)) * .map(String::toUpperCase) * .peek(e -> System.out.println("Mapped value: " + e)) * .collect(Collectors.toList()); * }&lt;/pre> * * @param action a &lt;a href="package-summary.html#NonInterference"> * non-interfering&lt;/a> action to perform on the elements as * they are consumed from the stream * @return the new stream */ Stream&lt;T> peek(Consumer&lt;? super T> action); /** * Returns a stream consisting of the elements of this stream, truncated * to be no longer than {@code maxSize} in length. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">short-circuiting * stateful intermediate operation&lt;/a>. * * @apiNote * While {@code limit()} is generally a cheap operation on sequential * stream pipelines, it can be quite expensive on ordered parallel pipelines, * especially for large values of {@code maxSize}, since {@code limit(n)} * is constrained to return not just any &lt;em>n&lt;/em> elements, but the * &lt;em>first n&lt;/em> elements in the encounter order. Using an unordered * stream source (such as {@link #generate(Supplier)}) or removing the * ordering constraint with {@link #unordered()} may result in significant * speedups of {@code limit()} in parallel pipelines, if the semantics of * your situation permit. If consistency with encounter order is required, * and you are experiencing poor performance or memory utilization with * {@code limit()} in parallel pipelines, switching to sequential execution * with {@link #sequential()} may improve performance. * * @param maxSize the number of elements the stream should be limited to * @return the new stream * @throws IllegalArgumentException if {@code maxSize} is negative */ Stream&lt;T> limit(long maxSize); /** * Returns a stream consisting of the remaining elements of this stream * after discarding the first {@code n} elements of the stream. * If this stream contains fewer than {@code n} elements then an * empty stream will be returned. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">stateful * intermediate operation&lt;/a>. * * @apiNote * While {@code skip()} is generally a cheap operation on sequential * stream pipelines, it can be quite expensive on ordered parallel pipelines, * especially for large values of {@code n}, since {@code skip(n)} * is constrained to skip not just any &lt;em>n&lt;/em> elements, but the * &lt;em>first n&lt;/em> elements in the encounter order. Using an unordered * stream source (such as {@link #generate(Supplier)}) or removing the * ordering constraint with {@link #unordered()} may result in significant * speedups of {@code skip()} in parallel pipelines, if the semantics of * your situation permit. If consistency with encounter order is required, * and you are experiencing poor performance or memory utilization with * {@code skip()} in parallel pipelines, switching to sequential execution * with {@link #sequential()} may improve performance. * * @param n the number of leading elements to skip * @return the new stream * @throws IllegalArgumentException if {@code n} is negative */ Stream&lt;T> skip(long n); /** * Performs an action for each element of this stream. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">terminal * operation&lt;/a>. * * &lt;p>The behavior of this operation is explicitly nondeterministic. * For parallel stream pipelines, this operation does &lt;em>not&lt;/em> * guarantee to respect the encounter order of the stream, as doing so * would sacrifice the benefit of parallelism. For any given element, the * action may be performed at whatever time and in whatever thread the * library chooses. If the action accesses shared state, it is * responsible for providing the required synchronization. * * @param action a &lt;a href="package-summary.html#NonInterference"> * non-interfering&lt;/a> action to perform on the elements */ void forEach(Consumer&lt;? super T> action); /** * Performs an action for each element of this stream, in the encounter * order of the stream if the stream has a defined encounter order. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">terminal * operation&lt;/a>. * * &lt;p>This operation processes the elements one at a time, in encounter * order if one exists. Performing the action for one element * &lt;a href="../concurrent/package-summary.html#MemoryVisibility">&lt;i>happens-before&lt;/i>&lt;/a> * performing the action for subsequent elements, but for any given element, * the action may be performed in whatever thread the library chooses. * * @param action a &lt;a href="package-summary.html#NonInterference"> * non-interfering&lt;/a> action to perform on the elements * @see #forEach(Consumer) */ void forEachOrdered(Consumer&lt;? super T> action); /** * Returns an array containing the elements of this stream. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">terminal * operation&lt;/a>. * * @return an array containing the elements of this stream */ Object[] toArray(); /** * Returns an array containing the elements of this stream, using the * provided {@code generator} function to allocate the returned array, as * well as any additional arrays that might be required for a partitioned * execution or for resizing. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">terminal * operation&lt;/a>. * * @apiNote * The generator function takes an integer, which is the size of the * desired array, and produces an array of the desired size. This can be * concisely expressed with an array constructor reference: * &lt;pre>{@code * Person[] men = people.stream() * .filter(p -> p.getGender() == MALE) * .toArray(Person[]::new); * }&lt;/pre> * * @param &lt;A> the element type of the resulting array * @param generator a function which produces a new array of the desired * type and the provided length * @return an array containing the elements in this stream * @throws ArrayStoreException if the runtime type of the array returned * from the array generator is not a supertype of the runtime type of every * element in this stream */ &lt;A> A[] toArray(IntFunction&lt;A[]> generator); /** * Performs a &lt;a href="package-summary.html#Reduction">reduction&lt;/a> on the * elements of this stream, using the provided identity value and an * &lt;a href="package-summary.html#Associativity">associative&lt;/a> * accumulation function, and returns the reduced value. This is equivalent * to: * &lt;pre>{@code * T result = identity; * for (T element : this stream) * result = accumulator.apply(result, element) * return result; * }&lt;/pre> * * but is not constrained to execute sequentially. * * &lt;p>The {@code identity} value must be an identity for the accumulator * function. This means that for all {@code t}, * {@code accumulator.apply(identity, t)} is equal to {@code t}. * The {@code accumulator} function must be an * &lt;a href="package-summary.html#Associativity">associative&lt;/a> function. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">terminal * operation&lt;/a>. * * @apiNote Sum, min, max, average, and string concatenation are all special * cases of reduction. Summing a stream of numbers can be expressed as: * * &lt;pre>{@code * Integer sum = integers.reduce(0, (a, b) -> a+b); * }&lt;/pre> * * or: * * &lt;pre>{@code * Integer sum = integers.reduce(0, Integer::sum); * }&lt;/pre> * * &lt;p>While this may seem a more roundabout way to perform an aggregation * compared to simply mutating a running total in a loop, reduction * operations parallelize more gracefully, without needing additional * synchronization and with greatly reduced risk of data races. * * @param identity the identity value for the accumulating function * @param accumulator an &lt;a href="package-summary.html#Associativity">associative&lt;/a>, * &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function for combining two values * @return the result of the reduction */ T reduce(T identity, BinaryOperator&lt;T> accumulator); /** * Performs a &lt;a href="package-summary.html#Reduction">reduction&lt;/a> on the * elements of this stream, using an * &lt;a href="package-summary.html#Associativity">associative&lt;/a> accumulation * function, and returns an {@code Optional} describing the reduced value, * if any. This is equivalent to: * &lt;pre>{@code * boolean foundAny = false; * T result = null; * for (T element : this stream) { * if (!foundAny) { * foundAny = true; * result = element; * } * else * result = accumulator.apply(result, element); * } * return foundAny ? Optional.of(result) : Optional.empty(); * }&lt;/pre> * * but is not constrained to execute sequentially. * * &lt;p>The {@code accumulator} function must be an * &lt;a href="package-summary.html#Associativity">associative&lt;/a> function. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">terminal * operation&lt;/a>. * * @param accumulator an &lt;a href="package-summary.html#Associativity">associative&lt;/a>, * &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function for combining two values * @return an {@link Optional} describing the result of the reduction * @throws NullPointerException if the result of the reduction is null * @see #reduce(Object, BinaryOperator) * @see #min(Comparator) * @see #max(Comparator) */ Optional&lt;T> reduce(BinaryOperator&lt;T> accumulator); /** * Performs a &lt;a href="package-summary.html#Reduction">reduction&lt;/a> on the * elements of this stream, using the provided identity, accumulation and * combining functions. This is equivalent to: * &lt;pre>{@code * U result = identity; * for (T element : this stream) * result = accumulator.apply(result, element) * return result; * }&lt;/pre> * * but is not constrained to execute sequentially. * * &lt;p>The {@code identity} value must be an identity for the combiner * function. This means that for all {@code u}, {@code combiner(identity, u)} * is equal to {@code u}. Additionally, the {@code combiner} function * must be compatible with the {@code accumulator} function; for all * {@code u} and {@code t}, the following must hold: * &lt;pre>{@code * combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t) * }&lt;/pre> * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">terminal * operation&lt;/a>. * * @apiNote Many reductions using this form can be represented more simply * by an explicit combination of {@code map} and {@code reduce} operations. * The {@code accumulator} function acts as a fused mapper and accumulator, * which can sometimes be more efficient than separate mapping and reduction, * such as when knowing the previously reduced value allows you to avoid * some computation. * * @param &lt;U> The type of the result * @param identity the identity value for the combiner function * @param accumulator an &lt;a href="package-summary.html#Associativity">associative&lt;/a>, * &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function for incorporating an additional element into a result * @param combiner an &lt;a href="package-summary.html#Associativity">associative&lt;/a>, * &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function for combining two values, which must be * compatible with the accumulator function * @return the result of the reduction * @see #reduce(BinaryOperator) * @see #reduce(Object, BinaryOperator) */ &lt;U> U reduce(U identity, BiFunction&lt;U, ? super T, U> accumulator, BinaryOperator&lt;U> combiner); /** * Performs a &lt;a href="package-summary.html#MutableReduction">mutable * reduction&lt;/a> operation on the elements of this stream. A mutable * reduction is one in which the reduced value is a mutable result container, * such as an {@code ArrayList}, and elements are incorporated by updating * the state of the result rather than by replacing the result. This * produces a result equivalent to: * &lt;pre>{@code * R result = supplier.get(); * for (T element : this stream) * accumulator.accept(result, element); * return result; * }&lt;/pre> * * &lt;p>Like {@link #reduce(Object, BinaryOperator)}, {@code collect} operations * can be parallelized without requiring additional synchronization. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">terminal * operation&lt;/a>. * * @apiNote There are many existing classes in the JDK whose signatures are * well-suited for use with method references as arguments to {@code collect()}. * For example, the following will accumulate strings into an {@code ArrayList}: * &lt;pre>{@code * List&lt;String> asList = stringStream.collect(ArrayList::new, ArrayList::add, * ArrayList::addAll); * }&lt;/pre> * * &lt;p>The following will take a stream of strings and concatenates them into a * single string: * &lt;pre>{@code * String concat = stringStream.collect(StringBuilder::new, StringBuilder::append, * StringBuilder::append) * .toString(); * }&lt;/pre> * * @param &lt;R> type of the result * @param supplier a function that creates a new result container. For a * parallel execution, this function may be called * multiple times and must return a fresh value each time. * @param accumulator an &lt;a href="package-summary.html#Associativity">associative&lt;/a>, * &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function for incorporating an additional element into a result * @param combiner an &lt;a href="package-summary.html#Associativity">associative&lt;/a>, * &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * function for combining two values, which must be * compatible with the accumulator function * @return the result of the reduction */ &lt;R> R collect(Supplier&lt;R> supplier, BiConsumer&lt;R, ? super T> accumulator, BiConsumer&lt;R, R> combiner); /** * Performs a &lt;a href="package-summary.html#MutableReduction">mutable * reduction&lt;/a> operation on the elements of this stream using a * {@code Collector}. A {@code Collector} * encapsulates the functions used as arguments to * {@link #collect(Supplier, BiConsumer, BiConsumer)}, allowing for reuse of * collection strategies and composition of collect operations such as * multiple-level grouping or partitioning. * * &lt;p>If the stream is parallel, and the {@code Collector} * is {@link Collector.Characteristics#CONCURRENT concurrent}, and * either the stream is unordered or the collector is * {@link Collector.Characteristics#UNORDERED unordered}, * then a concurrent reduction will be performed (see {@link Collector} for * details on concurrent reduction.) * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">terminal * operation&lt;/a>. * * &lt;p>When executed in parallel, multiple intermediate results may be * instantiated, populated, and merged so as to maintain isolation of * mutable data structures. Therefore, even when executed in parallel * with non-thread-safe data structures (such as {@code ArrayList}), no * additional synchronization is needed for a parallel reduction. * * @apiNote * The following will accumulate strings into an ArrayList: * &lt;pre>{@code * List&lt;String> asList = stringStream.collect(Collectors.toList()); * }&lt;/pre> * * &lt;p>The following will classify {@code Person} objects by city: * &lt;pre>{@code * Map&lt;String, List&lt;Person>> peopleByCity * = personStream.collect(Collectors.groupingBy(Person::getCity)); * }&lt;/pre> * * &lt;p>The following will classify {@code Person} objects by state and city, * cascading two {@code Collector}s together: * &lt;pre>{@code * Map&lt;String, Map&lt;String, List&lt;Person>>> peopleByStateAndCity * = personStream.collect(Collectors.groupingBy(Person::getState, * Collectors.groupingBy(Person::getCity))); * }&lt;/pre> * * @param &lt;R> the type of the result * @param &lt;A> the intermediate accumulation type of the {@code Collector} * @param collector the {@code Collector} describing the reduction * @return the result of the reduction * @see #collect(Supplier, BiConsumer, BiConsumer) * @see Collectors */ &lt;R, A> R collect(Collector&lt;? super T, A, R> collector); /** * Returns the minimum element of this stream according to the provided * {@code Comparator}. This is a special case of a * &lt;a href="package-summary.html#Reduction">reduction&lt;/a>. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">terminal operation&lt;/a>. * * @param comparator a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * {@code Comparator} to compare elements of this stream * @return an {@code Optional} describing the minimum element of this stream, * or an empty {@code Optional} if the stream is empty * @throws NullPointerException if the minimum element is null */ Optional&lt;T> min(Comparator&lt;? super T> comparator); /** * Returns the maximum element of this stream according to the provided * {@code Comparator}. This is a special case of a * &lt;a href="package-summary.html#Reduction">reduction&lt;/a>. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">terminal * operation&lt;/a>. * * @param comparator a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * {@code Comparator} to compare elements of this stream * @return an {@code Optional} describing the maximum element of this stream, * or an empty {@code Optional} if the stream is empty * @throws NullPointerException if the maximum element is null */ Optional&lt;T> max(Comparator&lt;? super T> comparator); /** * Returns the count of elements in this stream. This is a special case of * a &lt;a href="package-summary.html#Reduction">reduction&lt;/a> and is * equivalent to: * &lt;pre>{@code * return mapToLong(e -> 1L).sum(); * }&lt;/pre> * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">terminal operation&lt;/a>. * * @return the count of elements in this stream */ long count(); /** * Returns whether any elements of this stream match the provided * predicate. May not evaluate the predicate on all elements if not * necessary for determining the result. If the stream is empty then * {@code false} is returned and the predicate is not evaluated. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">short-circuiting * terminal operation&lt;/a>. * * @apiNote * This method evaluates the &lt;em>existential quantification&lt;/em> of the * predicate over the elements of the stream (for some x P(x)). * * @param predicate a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * predicate to apply to elements of this stream * @return {@code true} if any elements of the stream match the provided * predicate, otherwise {@code false} */ boolean anyMatch(Predicate&lt;? super T> predicate); /** * Returns whether all elements of this stream match the provided predicate. * May not evaluate the predicate on all elements if not necessary for * determining the result. If the stream is empty then {@code true} is * returned and the predicate is not evaluated. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">short-circuiting * terminal operation&lt;/a>. * * @apiNote * This method evaluates the &lt;em>universal quantification&lt;/em> of the * predicate over the elements of the stream (for all x P(x)). If the * stream is empty, the quantification is said to be &lt;em>vacuously * satisfied&lt;/em> and is always {@code true} (regardless of P(x)). * * @param predicate a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * predicate to apply to elements of this stream * @return {@code true} if either all elements of the stream match the * provided predicate or the stream is empty, otherwise {@code false} */ boolean allMatch(Predicate&lt;? super T> predicate); /** * Returns whether no elements of this stream match the provided predicate. * May not evaluate the predicate on all elements if not necessary for * determining the result. If the stream is empty then {@code true} is * returned and the predicate is not evaluated. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">short-circuiting * terminal operation&lt;/a>. * * @apiNote * This method evaluates the &lt;em>universal quantification&lt;/em> of the * negated predicate over the elements of the stream (for all x ~P(x)). If * the stream is empty, the quantification is said to be vacuously satisfied * and is always {@code true}, regardless of P(x). * * @param predicate a &lt;a href="package-summary.html#NonInterference">non-interfering&lt;/a>, * &lt;a href="package-summary.html#Statelessness">stateless&lt;/a> * predicate to apply to elements of this stream * @return {@code true} if either no elements of the stream match the * provided predicate or the stream is empty, otherwise {@code false} */ boolean noneMatch(Predicate&lt;? super T> predicate); /** * Returns an {@link Optional} describing the first element of this stream, * or an empty {@code Optional} if the stream is empty. If the stream has * no encounter order, then any element may be returned. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">short-circuiting * terminal operation&lt;/a>. * * @return an {@code Optional} describing the first element of this stream, * or an empty {@code Optional} if the stream is empty * @throws NullPointerException if the element selected is null */ Optional&lt;T> findFirst(); /** * Returns an {@link Optional} describing some element of the stream, or an * empty {@code Optional} if the stream is empty. * * &lt;p>This is a &lt;a href="package-summary.html#StreamOps">short-circuiting * terminal operation&lt;/a>. * * &lt;p>The behavior of this operation is explicitly nondeterministic; it is * free to select any element in the stream. This is to allow for maximal * performance in parallel operations; the cost is that multiple invocations * on the same source may not return the same result. (If a stable result * is desired, use {@link #findFirst()} instead.) * * @return an {@code Optional} describing some element of this stream, or an * empty {@code Optional} if the stream is empty * @throws NullPointerException if the element selected is null * @see #findFirst() */ Optional&lt;T> findAny(); // Static factories /** * Returns a builder for a {@code Stream}. * * @param &lt;T> type of elements * @return a stream builder */ public static&lt;T> Builder&lt;T> builder() { return new Streams.StreamBuilderImpl&lt;>(); } /** * Returns an empty sequential {@code Stream}. * * @param &lt;T> the type of stream elements * @return an empty sequential stream */ public static&lt;T> Stream&lt;T> empty() { return StreamSupport.stream(Spliterators.&lt;T>emptySpliterator(), false); } /** * Returns a sequential {@code Stream} containing a single element. * * @param t the single element * @param &lt;T> the type of stream elements * @return a singleton sequential stream */ public static&lt;T> Stream&lt;T> of(T t) { return StreamSupport.stream(new Streams.StreamBuilderImpl&lt;>(t), false); } /** * Returns a sequential ordered stream whose elements are the specified values. * * @param &lt;T> the type of stream elements * @param values the elements of the new stream * @return the new stream */ @SafeVarargs @SuppressWarnings("varargs") // Creating a stream from an array is safe public static&lt;T> Stream&lt;T> of(T... values) { return Arrays.stream(values); } /** * Returns an infinite sequential ordered {@code Stream} produced by iterative * application of a function {@code f} to an initial element {@code seed}, * producing a {@code Stream} consisting of {@code seed}, {@code f(seed)}, * {@code f(f(seed))}, etc. * * &lt;p>The first element (position {@code 0}) in the {@code Stream} will be * the provided {@code seed}. For {@code n > 0}, the element at position * {@code n}, will be the result of applying the function {@code f} to the * element at position {@code n - 1}. * * @param &lt;T> the type of stream elements * @param seed the initial element * @param f a function to be applied to to the previous element to produce * a new element * @return a new sequential {@code Stream} */ public static&lt;T> Stream&lt;T> iterate(final T seed, final UnaryOperator&lt;T> f) { Objects.requireNonNull(f); final Iterator&lt;T> iterator = new Iterator&lt;T>() { @SuppressWarnings("unchecked") T t = (T) Streams.NONE; @Override public boolean hasNext() { return true; } @Override public T next() { return t = (t == Streams.NONE) ? seed : f.apply(t); } }; return StreamSupport.stream(Spliterators.spliteratorUnknownSize( iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE), false); } /** * Returns an infinite sequential unordered stream where each element is * generated by the provided {@code Supplier}. This is suitable for * generating constant streams, streams of random elements, etc. * * @param &lt;T> the type of stream elements * @param s the {@code Supplier} of generated elements * @return a new infinite sequential unordered {@code Stream} */ public static&lt;T> Stream&lt;T> generate(Supplier&lt;T> s) { Objects.requireNonNull(s); return StreamSupport.stream( new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;>(Long.MAX_VALUE, s), false); } /** * Creates a lazily concatenated stream whose elements are all the * elements of the first stream followed by all the elements of the * second stream. The resulting stream is ordered if both * of the input streams are ordered, and parallel if either of the input * streams is parallel. When the resulting stream is closed, the close * handlers for both input streams are invoked. * * @implNote * Use caution when constructing streams from repeated concatenation. * Accessing an element of a deeply concatenated stream can result in deep * call chains, or even {@code StackOverflowException}. * * @param &lt;T> The type of stream elements * @param a the first stream * @param b the second stream * @return the concatenation of the two input streams */ public static &lt;T> Stream&lt;T> concat(Stream&lt;? extends T> a, Stream&lt;? extends T> b) { Objects.requireNonNull(a); Objects.requireNonNull(b); @SuppressWarnings("unchecked") Spliterator&lt;T> split = new Streams.ConcatSpliterator.OfRef&lt;>( (Spliterator&lt;T>) a.spliterator(), (Spliterator&lt;T>) b.spliterator()); Stream&lt;T> stream = StreamSupport.stream(split, a.isParallel() || b.isParallel()); return stream.onClose(Streams.composedClose(a, b)); } /** * A mutable builder for a {@code Stream}. This allows the creation of a * {@code Stream} by generating elements individually and adding them to the * {@code Builder} (without the copying overhead that comes from using * an {@code ArrayList} as a temporary buffer.) * * &lt;p>A stream builder has a lifecycle, which starts in a building * phase, during which elements can be added, and then transitions to a built * phase, after which elements may not be added. The built phase begins * when the {@link #build()} method is called, which creates an ordered * {@code Stream} whose elements are the elements that were added to the stream * builder, in the order they were added. * * @param &lt;T> the type of stream elements * @see Stream#builder() * @since 1.8 */ public interface Builder&lt;T> extends Consumer&lt;T> { /** * Adds an element to the stream being built. * * @throws IllegalStateException if the builder has already transitioned to * the built state */ @Override void accept(T t); /** * Adds an element to the stream being built. * * @implSpec * The default implementation behaves as if: * &lt;pre>{@code * accept(t) * return this; * }&lt;/pre> * * @param t the element to add * @return {@code this} builder * @throws IllegalStateException if the builder has already transitioned to * the built state */ default Builder&lt;T> add(T t) { accept(t); return this; } /** * Builds the stream, transitioning this builder to the built state. * An {@code IllegalStateException} is thrown if there are further attempts * to operate on the builder after it has entered the built state. * * @return the built stream * @throws IllegalStateException if the builder has already transitioned to * the built state */ Stream&lt;T> build(); } } 串行流、并行流 Collection接口 /** * Returns a sequential {@code Stream} with this collection as its source. * * &lt;p>This method should be overridden when the {@link #spliterator()} * method cannot return a spliterator that is {@code IMMUTABLE}, * {@code CONCURRENT}, or &lt;em>late-binding&lt;/em>. (See {@link #spliterator()} * for details.) * * @implSpec * The default implementation creates a sequential {@code Stream} from the * collection's {@code Spliterator}. * * @return a sequential {@code Stream} over the elements in this collection * @since 1.8 */ default Stream&lt;E> stream() { return StreamSupport.stream(spliterator(), false); } /** * Returns a possibly parallel {@code Stream} with this collection as its * source. It is allowable for this method to return a sequential stream. * * &lt;p>This method should be overridden when the {@link #spliterator()} * method cannot return a spliterator that is {@code IMMUTABLE}, * {@code CONCURRENT}, or &lt;em>late-binding&lt;/em>. (See {@link #spliterator()} * for details.) * * @implSpec * The default implementation creates a parallel {@code Stream} from the * collection's {@code Spliterator}. * * @return a possibly parallel {@code Stream} over the elements in this * collection * @since 1.8 */ default Stream&lt;E> parallelStream() { return StreamSupport.stream(spliterator(), true); } Function接口 /* * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * */ package java.util.function; import java.util.Objects; /** * Represents a function that accepts one argument and produces a result. * * &lt;p>This is a &lt;a href="package-summary.html">functional interface&lt;/a> * whose functional method is {@link #apply(Object)}. * * @param &lt;T> the type of the input to the function * @param &lt;R> the type of the result of the function * * @since 1.8 */ @FunctionalInterface public interface Function&lt;T, R> { /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); /** * Returns a composed function that first applies the {@code before} * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V> the type of input to the {@code before} function, and to the * composed function * @param before the function to apply before this function is applied * @return a composed function that first applies the {@code before} * function and then applies this function * @throws NullPointerException if before is null * * @see #andThen(Function) */ default &lt;V> Function&lt;V, R> compose(Function&lt;? super V, ? extends T> before) { Objects.requireNonNull(before); return (V v) -> apply(before.apply(v)); } /** * Returns a composed function that first applies this function to * its input, and then applies the {@code after} function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V> the type of output of the {@code after} function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the {@code after} function * @throws NullPointerException if after is null * * @see #compose(Function) */ default &lt;V> Function&lt;T, V> andThen(Function&lt;? super R, ? extends V> after) { Objects.requireNonNull(after); return (T t) -> after.apply(apply(t)); } /** * Returns a function that always returns its input argument. * * @param &lt;T> the type of the input and output objects to the function * @return a function that always returns its input argument */ static &lt;T> Function&lt;T, T> identity() { return t -> t; } }]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引库]]></title>
    <url>%2F2019%2F05%2F02%2Fsuo-yin-ku%2F</url>
    <content type="text"><![CDATA[work课程Coursera | Online Courses &amp; Credentials by Top Educators. Join for Free technologygitWorld Hello - WorldHello Pro Git（中文版） Git 完整教程–idea使用git进行项目管理 - it技术专业户 - 博客园 Git教程 - 廖雪峰的官方网站 Git 使用规范流程_慕课手记 Git - Book 使用webstorm操作git - 金广国 - 博客园 (9+条消息)Git/GitHub教程2-与本地和GitHub上删除repository和folder相关 - ljsnail的博客 - CSDN博客 如何撰写 Git 提交信息 - 囧克斯 Plugin ANZEclipse 安装 SVN 在线插件教程_java_脚本之家 Mysql5.7.14安装配置方法操作图文教程(密码问题解决办法)_Mysql_脚本之家 ideaIntelliJ_13书签 - 扯 - 博客园 Intellij IDEA 快捷键大全 - IntelliJ IDEA - 开发语言与工具 - 深度开源 介绍 - IntelliJ IDEA 使用教程 - 极客学院Wiki IDEA中对应eclipse ctrl + 2 + L的快捷键 是哪个 IDEA中对应eclipse ctrl + 2 + L的快捷键 是哪个？ - 知乎 IntelliJ IDEA 使用心得与常用快捷键 - 码农往事 - BlogJava IDEA 2018 激活 IDEA 2018.3激活教程 最新的（三种）—2018.11.26亲测 - HALEN的博客 - CSDN博客 IntelliJ IDEA 注册码 IDEA插件JRebel安装配置与破解激活详细教程 - Zephyrus007 - 博客园 Intellij IDEA 安装jrebel插件 - CSDN博客 Intellij IDEA神器居然还有这些小技巧 - CSDN博客 IDEA 主题样式 idea翻译插件Translation的安装与使用 - 简书 (9条消息)两分钟解决IntelliJ IDEA中文乱码问题 - 一生伏首拜阳明 - CSDN博客 IntelliJ IDEA 14.1 导入MyEclipse2015工程的过程及所遇问题整理 - 综合编程类其他综合 - 红黑联盟 (9条消息)idea项目全局去掉严格的语法校验 - 坚持积累坚持记录 - CSDN博客 goole赛风 | 下载 Android 应用和 Windows 客户端 如何安装CRX格式？Chrome插件离线安装，CRX格式安装方法 - Chrome插件网 Chrome 浏览器 必知必会的小技巧 你不知道的Chrome DevTools（2）：那些debug的技巧 - civerzhu - SegmentFault 思否 Javascript调试命令——你只会Console.log() ? - 前端小记 - SegmentFault 思否 必备的JS调试技巧汇总_javascript技巧_脚本之家 Google Chrome 网络浏览器 chrome开发者工具各种骚技巧 - 掘金 自建ss服务器教程 · Alvin9999/new-pac Wiki · GitHub ss免费账号 · Alvin9999/new-pac Wiki · GitHub Vultr充值送50美元，2019年大促-Vultr VPS My Subscriptions - Vultr.com chrome://net-internals/#hsts chrome浏览器不安全提示NET::ERR_CERT_COMMON_NAME_INVALID解决方法 | 小冷博客 Google 的升级版 Google Drive 工具，让你备份电脑数据更轻松 - 少数派 gradleGradle - Help | IntelliJ IDEA 慕课网_《新一代构建工具gradle》学习总结 - study - SegmentFault 思否 Gradle用户指南官方文档中文版_Gradle 教程_Gradle_极客学院 Wiki (9+条消息)IDEA 及 Gradle 使用总结 - cluzax的专栏 - CSDN博客 TomcatTomcat源码分析(一)之源码下载与导入IDEA - 宸明 cssCSS-Secrets/notes at master · cssmagic/CSS-Secrets CSS森林(CSS Forest) - 标签 学习CSS布局 关于css水平垂直居中的总结 · Issue #12 · hawx1993/tech-blog 个人总结（css3新特性） - 守候书阁 - SegmentFault 思否 关于「圣杯布局」 - 天道酬勤 - SegmentFault 思否 CSS3 动画 | 菜鸟教程 A Complete Guide to Flexbox | CSS-Tricks 浅谈display:flex - love星期六 - 博客园 Can I use… Support tables for HTML5, CSS3, etc 使用 CSS 渐变 - Web 开发者指南 | MDN jsVS Code - Debugger for Chrome调试JavaScript的两种方式 - SolidMango - 博客园 Understanding JavaScript’s async await 【JS实用技巧】优化动态创建元素的方式，让代码更加优雅且利于维护 - Web开发之路 - SegmentFault 思否 JavaScript如何一次性展示几万条数据 - 陈宏鸿 - 博客园 JavaScript 运行机制–Event Loop详解 - 掘金 跟着9张思维导图学习Javascript - ChokCoco - 博客园 JavaScript性能优化小窍门实例汇总 - 性能优化 - 开发语言与工具 - 深度开源 45个有用的JavaScript技巧，窍门和最佳实践 - 掘金 JavaScript深入系列15篇正式完结！ - 掘金 JavaScript性能优化小窍门实例汇总 - 性能优化 - 开发语言与工具 - 深度开源 pythonPython爬虫入门 | Linux运维部落 【超全整理】《Python自动化全能开发从入门到精通》python基础教程笔记全放送 | 马哥教育官网-专业linux培训|python培训 人生苦短，我用Python（目录） - 海燕。 - 博客园 pycharm项目上传到Github - Jacck - 博客园 数据提取之JSON与JsonPATH-博客-云栖社区-阿里云 MarkdownMastering Markdown · GitHub Guides hexohexo史上最全搭建教程 - Fangzh的技术博客 - CSDN博客 如何优雅地发布Hexo博客 - 简书 绝配：hexo+next主题及我走过的坑 - 简书 为NexT主题添加文章阅读量统计功能 | Doublemine 备份Hexo博客源文件 | Doublemine Interview questions从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！ - 前端 - 掘金 springjQueryjava深入理解Java：SimpleDateFormat安全的时间格式化 - peida - 博客园 java-生成任意格式的json数据 - web喵神 - 博客园 segmentfault-lessons/「一入 Java 深似海 」 at master · mercyblitz/segmentfault-lessons Java对象的序列化与反序列化-Json篇 - I am jison - ITeye博客 Java 动态代理机制分析及扩展，第 1 部分 ssmMAC下使用IDEA搭建SSM的Maven项目 - 后端 - 掘金 databasePL/SQL游标 - PL/SQL教程™ inner join 与 left join 之间的区别 - 十七年的夏天 - 博客园 oracle查询重复数据方法 - 小人物的奋斗 - 博客园 关于本书 - Oracle-RAC 体验 - 极客学院Wiki Using Oracle Real Application Clusters (RAC) for High Availability Oracle数据库18c - 教程 达梦数据库-国产数据库-掌握全部源代码-拥有完全自主知识产权-大数据-云平台-DCA认证培训-数据库培训-柔性替代方案 mybatismybatis – MyBatis 3 | Introduction mybatis-spring – MyBatis-Spring | 简介 mybaits入门（含实例教程和源码） - CSDN博客 MavenEclipse上Maven环境配置使用 (全) - java_2017_csdn的博客 - CSDN博客 (9+条消息)使用IntelliJ IDEA 配置Maven（入门） - 记事本 - CSDN博客 IntelliJ IDEA 15 创建maven项目 - Angelaboy - 博客园 svn(9+条消息)IntelliJ IDEA 下的svn配置及使用的非常详细的图文总结 - 请叫我大师兄 - CSDN博客 (9条消息)Idea SVN导出MyEclipse项目部署问题 - 小白笔记本 - CSDN博客 linuxLinux基础教程之vim编辑器使用入门 | 马哥教育官网-专业linux培训|python培训 《Linux就该这么学》 - 必读的Linux系统与红帽RHCE认证免费自学书籍 详解Ubuntu 16.04 几个国内更新源_Linux_脚本之家 Linux 中国◆开源社区|技术 Ubuntu 18.04 安装微信（Linux通用） - 毒逆天 - 博客园 如何在Ubuntu上使用微信客户端 | 《Linux就该这么学》 如何使用 U 盘安装 Ubuntu 操作系统？ - 知乎 liunx下查看日志最实用命令和方法 - 天下雨水 - 博客园 Linux查看日志命令 - 大道至简，知易行难 - CSDN博客 springbootIntroduction · spring-boot-book 「一入 Java 深似海 」系列 2019年第一季（第一、二、三期合集） - 思否编程 SpringBoot系列一：SpringBoot入门 - ImportNew iptvJava实现将文本内容、网址链接url,生成二维码与反解析（转） - frank1998819 - ITeye博客 Java利用Google Zxing实现在线生成二维码和二维码解码 - yoodb - 素文宅博客 Java Code Examples com.google.zxing.client.j2se.BufferedImageLuminanceSource EnglishCourse逆风学习网 - Powered by Discuz! GitHubmercyblitz (Mercy Ma) 开发环境Putty的安装和使用 - 阿亮的博客 - CSDN博客 8 Reasons Why Typora Might Be Your Favorite Markdown Editor Release pandoc 2.0.6 · jgm/pandoc eclipse Atom Download - Sublime Text 数据结构与算法如果天空不死的主页 - 博客园 windowsHow To Fix Kernel Data Inpage Error in Windows 10? 小米帮助中心-小米商城 springmvcspringmvc前台访问404，不能进入controller，后台不报错问题解决方案心得 - ITwelision的博客 - CSDN博客 WiresharkWireshark User’s Guide webserviceJAX-WS入门实例及wsimport的使用 webservice的框架—axis - New - ITeye论坛 Apache Axis – User’s Guide axis 自定义对象序列化 - Snowolf的意境空间！ - ITeye博客 bloghexo Jekyll jekyll博客搭建之艰辛之路 | Dailc的个人主页 技术人如何搭建自己的技术博客 - 纯洁的微笑博客 Jekyll搭建个人博客 - Freud’s Blog 开始使用 - NexT 使用文档+hexo 开始使用 - NexT 使用文档+jekyll Jekyll搭建个人博客 静觅 崔庆才的个人博客 Nikkkki’s Notes 奇舞周刊 Web前端导航 前端圈——打造专业的前端技术会议– 个人分享–web前端学习资源分享 - 掘金 小马哥的技术博客 - 小马哥的技术博客 徐靖峰|个人博客 梁桂钊的博客 导读 | 晓风轻技术小站 码酱博客 前端之旅 Java 技术驿站-一个专注于 Java 技术分享的精品博客网站 周立的博客 - 关注Spring Cloud、Docker ZhongFuCheng3y/3y: 3y文章导航 CyC2018 / Repositories https://yuzhouwan.com/ hijiangtao (Joe Jiang) Eloquent JavaScript Snailclimb (SnailClimb) 前端开发博客-前端开发,前端博客 41个网站每个Java开发人员都应该收藏 11个最值得Java开发者收藏的网站 - ImportNew IBM developerWorks 中国 : Java technology : 文档库 Tutorials on JavaScript, React, Vue, GraphQL, and more 过往记忆 芋道源码 —— 纯源码解析博客 V2EX CodingLabs - keep coding, keep foolish Tags - 王泽远的博客 | Crow’s Blog 首页 - Beifengtz Blog 原创技术博客大联盟 | techblog 面试CS-Notes frank-lam/fullstack-tutorial: 🚀 fullstack tutorial 2019，后台技术栈/架构师之路/全栈开发社区，春招/秋招/校招/面试 aalansehaiyang/technology-talk: 汇总java生态圈常用技术框架、开源中间件，系统架构、数据库、大公司架构案例、常用三方类库、项目管理、线上问题排查、个人成长、思考等知识 GitHub - Advanced-Frontend/Daily-Interview-Question: 我是木易杨，公众号「高级前端进阶」作者，每天搞定一道前端大厂面试题，祝大家天天进步，一年后会看到不一样的自己。 doocs/advanced-java: 😮 互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务等领域知识，后端同学必看，前端同学也可学习 Snailclimb/JavaGuide: 【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。 aalansehaiyang/technology-talk: 汇总java生态圈常用技术框架、开源中间件，系统架构、数据库、大公司架构案例、常用三方类库、项目管理、线上问题排查、个人成长、思考等知识 azl397985856/leetcode: LeetCode Solutions: A Record of My Problem Solving Journey.( leetcode题解，记录自己的leetcode解题之路。) Blankj/awesome-java-leetcode: LeetCode of algorithms with java solution(updating). MisterBooo/LeetCodeAnimation: Demonstrate all the questions on LeetCode in the form of animation.（用动画的形式呈现解LeetCode题目的思路） interviews/README-zh-cn.md at master · kdn251/interviews biezhi/java-bible: 我的技术摘要 ZhongFuCheng3y/3y: 3y原创技术文章导航 程序员小吴 apiSpring Framework Documentation The Python Tutorial — Python 3.8.0a0 documentation The Python Standard Library — Python 3.7.1 documentation mybatis – MyBatis 3 | Introduction Spring Boot Reference Guide Spring Cloud jQuery API Documentation Cycle.js Cycle.js ECMAScript 2015 Language Specification – ECMA-262 6th Edition GitHub Developer | GitHub Developer Guide_测试接口 jQuery API 中文文档 | jQuery API 中文在线手册 | jquery api 下载 | jquery api chm ECharts nefe/You-Dont-Need-jQuery: Examples of how to do query, style, dom, ajax, event etc like jQuery with plain javascript. Guides | Node.js React Router: Declarative Routing for React.js 菜鸟教程 - 学的不仅是技术，更是梦想！ MySQL :: MySQL 5.7 Reference Manual Home - Wiki - 码云 Gitee.com Python Module Index — Python 3.8.0a3 documentation lyj8330328/leyou: 乐优商城项目后台 MDN Web 文档 Bootstrap中文网 Wikipedia Sublime Text - A sophisticated text editor for code, markup and prose devAtom IntelliJ IDEA: The Java IDE for Professional Developers by JetBrains Download PuTTY: latest release (0.70) 淘宝 NPM 镜像 Babel · The compiler for next generation JavaScript Index of /]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>index_catalogue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2F2019%2F04%2F03%2Fspringboot%2F</url>
    <content type="text"><![CDATA[入门 启动 官网创建 第一个例子 编辑pom.xml &lt;!-- springBoot的启动器 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> 编写controller /** * SpringBoot HelloWorld * @author Administrator * */ @Controller public class HelloWorld { @RequestMapping("/hello") @ResponseBody public Map&lt;String, Object> showHelloWorld(){ Map&lt;String, Object> map = new HashMap&lt;>(); map.put("msg", "HelloWorld"); return map; } } 编写启动类 package com.bjsxt.app; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; /** * SpringBoot 启动类 * @author Administrator * */ @SpringBootApplication public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 打包 进入到项目目录下，终端运行 mvn clean package -Dmaven.test.skip=true 运行 java -jar demo_springboot-0.0.1-SNAPSHOT.jar 整合Web开发 整合Servlet 注解扫描注册 通过注解扫描完成Servlet组件的注册 编写Servlet /** *SpringBoot整合Servlet方式一 * *&lt;servlet> * &lt;servlet-name>FirstServlet&lt;/servlet-name> * &lt;servlet-class>com.bjsxt.servlet.FirstServlet&lt;/servlet-class> *&lt;/servlet> * *&lt;servlet-mapping> * &lt;servlet-name>FirstServlet&lt;/servlet-name> * &lt;url-pattern>/first&lt;/url-pattern> *&lt;/servlet-mapping> * */ @WebServlet(name="FirstServlet",urlPatterns="/first") public class FirstServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println("FirstServlet............"); } } 编写启动类 /** * SpringBoot整合Servlet方式一 * * */ @SpringBootApplication //在springBoot启动时会扫描@WebServlet，并将该类实例化 @ServletComponentScan public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 方法注册 通过方法完成Servlet组件的注册 编写Servlet /** *SpringBoot整合Servlet方式二 * */ public class SecondServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println("SecondServlet.........."); } } 编写启动类 /** * SpringBoot整合Servlet方式二 * * */ @SpringBootApplication public class App2 { public static void main(String[] args) { SpringApplication.run(App2.class, args); } @Bean public ServletRegistrationBean getServletRegistrationBean(){ ServletRegistrationBean bean = new ServletRegistrationBean(new SecondServlet()); bean.addUrlMappings("/second"); return bean; } } 整合Filter 注解扫描注册 编写Filter /** *SpringBoot整合Filter 方式一 *&lt;filter> * &lt;filter-name>FirstFilter&lt;/filter-name> * &lt;filter-class>com.bjsxt.filter.FirstFilter&lt;/filter-class> *&lt;/filter> *&lt;filter-mapping> * &lt;filter-name>FirstFilter&lt;/filter-name> * &lt;url-pattern>/first&lt;/url-pattern> *&lt;/filter-mapping> */ //@WebFilter(filterName="FirstFilter",urlPatterns={"*.do","*.jsp"}) @WebFilter(filterName="FirstFilter",urlPatterns="/first") public class FirstFilter implements Filter { @Override public void destroy() { // TODO Auto-generated method stub } @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException { System.out.println("进入Filter"); arg2.doFilter(arg0, arg1); System.out.println("离开Filter"); } @Override public void init(FilterConfig arg0) throws ServletException { // TODO Auto-generated method stub } } 编写启动类 /** *SpringBoot整合Filter 方式一 * */ @SpringBootApplication @ServletComponentScan public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 方法注册 编写Filter /** * *SpringBoot整合Filter 方式二 * */ public class SecondFilter implements Filter { @Override public void destroy() { // TODO Auto-generated method stub } @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException { System.out.println("进入SecondFilter"); arg2.doFilter(arg0, arg1); System.out.println("离开SecondFilter"); } @Override public void init(FilterConfig arg0) throws ServletException { // TODO Auto-generated method stub } } 编写启动类 /** * SpringBoot整合Filter方式二 * * */ @SpringBootApplication public class App2 { public static void main(String[] args) { SpringApplication.run(App2.class, args); } /** * 注册Filter */ @Bean public FilterRegistrationBean getFilterRegistrationBean(){ FilterRegistrationBean bean = new FilterRegistrationBean(new SecondFilter()); //bean.addUrlPatterns(new String[]{"*.do","*.jsp"}); bean.addUrlPatterns("/second"); return bean; } } 整合Listener 注解扫描注册 编写Listener package com.bjsxt.listener; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; /** * springBoot整合Listener * *&lt;listener> * &lt;listener-class>com.bjsxt.listener.FirstListener&lt;/listener-class> *&lt;/listener> */ @WebListener public class FirstListener implements ServletContextListener { @Override public void contextDestroyed(ServletContextEvent arg0) { // TODO Auto-generated method stub } @Override public void contextInitialized(ServletContextEvent arg0) { System.out.println("Listener...init......"); } } 编写启动类 package com.bjsxt; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.ServletComponentScan; /** * springBoot整合Listener方式一 * * */ @SpringBootApplication @ServletComponentScan public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 方法注册 编写Listener package com.bjsxt.listener; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; /** * springBoot整合Listener方式二。 * * */ public class SecondListener implements ServletContextListener { @Override public void contextDestroyed(ServletContextEvent arg0) { // TODO Auto-generated method stub } @Override public void contextInitialized(ServletContextEvent arg0) { System.out.println("SecondListener..init....."); } } 编写启动类 /** * SpringBoot整合Listener方式二 * * */ @SpringBootApplication public class App2 { public static void main(String[] args) { SpringApplication.run(App2.class, args); } /** * 注册listener */ @Bean public ServletListenerRegistrationBean&lt;SecondListener> getServletListenerRegistrationBean(){ ServletListenerRegistrationBean&lt;SecondListener> bean= new ServletListenerRegistrationBean&lt;SecondListener>(new SecondListener()); return bean; } } 访问静态资源 从classpath/static的目录下读取 从ServletContext根目录下读取,即webapp目录 文件上传 编写Controller /** * SpringBoot文件上传 * * */ //@Controller @RestController //表示该类下的方法的返回值会自动做json格式的转换 public class FileUploadController { /* * 处理文件上传 */ @RequestMapping("/fileUploadController") public Map&lt;String, Object> fileUpload(MultipartFile filename)throws Exception{ System.out.println(filename.getOriginalFilename()); filename.transferTo(new File("e:/"+filename.getOriginalFilename())); Map&lt;String, Object> map = new HashMap&lt;>(); map.put("msg", "ok"); return map; } } 编写启动类 package com.bjsxt; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; /** * SpringBoot文件上传 * * */ @SpringBootApplication public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 编写文件上传表单 进入src/main/resources/static目录下,新增upload.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>文件上传&lt;/title> &lt;/head> &lt;body> &lt;form action="fileUploadController" method="post" enctype="multipart/form-data"> 上传文件：&lt;input type="file" name="filename"/>&lt;br/> &lt;input type="submit"/> &lt;/form> &lt;/body> &lt;/html> 设置上传文件大小的默认值 进入/src/main/resources目录，编辑application.properties文件 spring.http.multipart.maxFileSize=200MB spring.http.multipart.maxRequestSize=200MB 整合jsp 编辑pom.xml &lt;!-- jdk1.7 --> &lt;properties> &lt;java.version>1.7&lt;/java.version> &lt;/properties> &lt;dependencies> &lt;!-- springBoot的启动器 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;!-- jstl --> &lt;dependency> &lt;groupId>javax.servlet&lt;/groupId> &lt;artifactId>jstl&lt;/artifactId> &lt;/dependency> &lt;!-- jasper --> &lt;dependency> &lt;groupId>org.apache.tomcat.embed&lt;/groupId> &lt;artifactId>tomcat-embed-jasper&lt;/artifactId> &lt;scope>provided&lt;/scope> &lt;/dependency> &lt;/dependencies> 创建application.properties 进入src/main/resources目录，新增编辑application.properties文件 spring.mvc.view.prefix=/WEB-INF/jsp/ spring.mvc.view.suffix=.jsp 编写Controller /** * SpringBoot整合jsp * * */ @Controller public class UserController { /* * 处理请求，产生数据 */ @RequestMapping("/showUser") public String showUser(Model model){ List&lt;Users> list = new ArrayList&lt;>(); list.add(new Users(1,"张三",20)); list.add(new Users(2,"李四",22)); list.add(new Users(3,"王五",24)); //需要一个Model对象 model.addAttribute("list", list); //跳转视图 return "userList"; } } 创建jsp 进入src/main/webapp/WEB-INF/jsp目录,新增userList.jsp &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%> &lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%> &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> &lt;html> &lt;head> &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> &lt;title>Insert title here&lt;/title> &lt;/head> &lt;body> &lt;table border="1" align="center" width="50%"> &lt;tr> &lt;th>ID&lt;/th> &lt;th>Name&lt;/th> &lt;th>Age&lt;/th> &lt;/tr> &lt;c:forEach items="${list }" var="user"> &lt;tr> &lt;td>${user.userid }&lt;/td> &lt;td>${user.username }&lt;/td> &lt;td>${user.userage }&lt;/td> &lt;/tr> &lt;/c:forEach> &lt;/table> &lt;/body> &lt;/html> 创建启动类 package com.bjsxt; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; /** * SpringBoot启动类 * * */ @SpringBootApplication public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 整合freemarker 编辑pom.xml &lt;properties> &lt;java.version>1.7&lt;/java.version> &lt;/properties> &lt;dependencies> &lt;!-- springBoot的启动器 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;!-- freemarker启动器的坐标 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-freemarker&lt;/artifactId> &lt;/dependency> &lt;/dependencies> 创建 Controller /** * SpringBoot整合jsp * * */ @Controller public class UserController { /* * 处理请求，产生数据 */ @RequestMapping("/showUser") public String showUser(Model model){ List&lt;Users> list = new ArrayList&lt;>(); list.add(new Users(1,"张三",20)); list.add(new Users(2,"李四",22)); list.add(new Users(3,"王五",24)); //需要一个Model对象 model.addAttribute("list", list); //跳转视图 return "userList"; } } 编写前端页面 springBoot要求模板形式的视图层技术的文件必须要放到src/main/resources目录下必须要一个名称为templates 进入到src/main/resources/templates目录,新增userList.ftl文件 &lt;html> &lt;head> &lt;title>展示用户数据&lt;/title> &lt;meta charset="utf-9">&lt;/meta> &lt;/head> &lt;body> &lt;table border="1" align="center" width="50%"> &lt;tr> &lt;th>ID&lt;/th> &lt;th>Name&lt;/th> &lt;th>Age&lt;/th> &lt;/tr> &lt;#list list as user > &lt;tr> &lt;td>${user.userid}&lt;/td> &lt;td>${user.username}&lt;/td> &lt;td>${user.userage}&lt;/td> &lt;/tr> &lt;/#list> &lt;/table> &lt;/body> &lt;/html> 创建启动类 package com.bjsxt; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; /** * SpringBoot启动类 * * */ @SpringBootApplication public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 整合Thymeleaf 编辑pom.xml &lt;properties> &lt;java.version>1.7&lt;/java.version> &lt;thymeleaf.version>3.0.2.RELEASE&lt;/thymeleaf.version> &lt;thymeleaf-layout-dialect.version>2.0.4&lt;/thymeleaf-layout-dialect.version> &lt;/properties> &lt;dependencies> &lt;!-- springBoot的启动器 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;!-- springBoot的启动器 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> &lt;/dependencies> 编辑前端页面 进入src/main/resources/templates,templates目录是安全的。意味着该目录下的内容是不允许外界直接访问的。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Thymeleaf入门&lt;/title> &lt;/head> &lt;body> &lt;span th:text="Hello">&lt;/span> &lt;hr/> &lt;span th:text="${msg}">&lt;/span> &lt;/body> &lt;/html> 编辑Controller package com.bjsxt.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; /** * Thymeleaf入门案例 * * */ @Controller public class DemoController { @RequestMapping("/show") public String showInfo(Model model){ model.addAttribute("msg", "Thymeleaf 第一个案例"); return "index"; } } 编辑启动类 package com.bjsxt; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; /** * *Thymeleaf入门案例 * */ @SpringBootApplication public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 坑 org.xml.sax.SAXParseException:元素类型 &quot;meta&quot; 必须由匹配的结束标记&quot;&lt;/meta&gt;&quot;终止 解决 方式一 让html的标记按照严禁的语法编写 &lt;meta charset="UTF-8"/> 方式二 thymeleaf.jar更新为3.0以上的版本 thymeleaf-layout-dialect.jar更新为2.0以上的版本 &lt;properties> &lt;java.version>1.7&lt;/java.version> &lt;thymeleaf.version>3.0.2.RELEASE&lt;/thymeleaf.version> &lt;thymeleaf-layout-dialect.version>2.0.4&lt;/thymeleaf-layout-dialect.version> &lt;/properties> Thymeleaf语法 变量输出与字符串操作 调用内置对象一定要用# 大部分的内置对象都以s结尾strings、numbers、dates 后台数据 package com.bjsxt.controller; @Controller public class DemoController { @RequestMapping("/show") public String showInfo(HttpServletRequest request,Model model){ model.addAttribute("msg", "Thymeleaf 第一个案例"); model.addAttribute("key", new Date()); return "index"; } } th:text &lt;span th:text="Hello">&lt;/span> &lt;hr/> &lt;span th:text="${msg} ">&lt;/span> &lt;hr/> th:value &lt;span th:text="${msg} ">&lt;/span> 判断字符串是否为空 &lt;span th:text="${#strings.isEmpty(msg)}">&lt;/span> 判断字符串是否包含指定的子串 &lt;span th:text="${#strings.contains(msg,'9')}">&lt;/span> &lt;span th:text="${#strings.contains(msg,'T')}">&lt;/span> 判断当前字符串是否以子串开头 &lt;span th:text="${#strings.startsWith(msg,'a')}">&lt;/span> &lt;span th:text="${#strings.startsWith(msg,'T')}">&lt;/span> 判断当前字符串是否以子串结尾 &lt;span th:text="${#strings.endsWith(msg,'a')}">&lt;/span> &lt;span th:text="${#strings.endsWith(msg,'案例')}">&lt;/span> 返回字符串的长度 &lt;span th:text="${#strings.length(msg)}">&lt;/span> 查找子串的位置 返回该子串的下标，如果没找到则返回-1 &lt;span th:text="${#strings.indexOf(msg,'h')}">&lt;/span> 截取子串 &lt;span th:text="${#strings.substring(msg,13)}">&lt;/span> &lt;span th:text="${#strings.substring(msg,13,14)}">&lt;/span> 字符串转大小写 &lt;span th:text="${#strings.toUpperCase(msg)}">&lt;/span> &lt;span th:text="${#strings.toLowerCase(msg)}">&lt;/span> 日期格式化处理 后台数据 package com.bjsxt.controller; @Controller public class DemoController { @RequestMapping("/show") public String showInfo(HttpServletRequest request,Model model){ model.addAttribute("key", new Date()); return "index"; } } 默认格式日期 &lt;span th:text="${#dates.format(key)}">&lt;/span> 按照自定义的格式做日期转换 &lt;span th:text="${#dates.format(key,'yyy/MM/dd')}">&lt;/span> 取年 &lt;span th:text="${#dates.year(key)}">&lt;/span> 取月 &lt;span th:text="${#dates.month(key)}">&lt;/span> 取日 &lt;span th:text="${#dates.day(key)}">&lt;/span> 条件判断 后台数据 package com.bjsxt.controller; @Controller public class DemoController { @RequestMapping("/show2") public String showInfo2(Model model){ model.addAttribute("sex", "女"); model.addAttribute("id","1"); return "index2"; } } th:if &lt;span th:if="${sex} == '男'"> 性别：男 &lt;/span> &lt;span th:if="${sex} == '女'"> 性别：女 &lt;/span> th:switch &lt;div th:switch="${id}"> &lt;span th:case="1">ID为1&lt;/span> &lt;span th:case="2">ID为2&lt;/span> &lt;span th:case="3">ID为3&lt;/span> &lt;/div> 迭代遍历 后台数据 package com.bjsxt.controller; @Controller public class DemoController { @RequestMapping("/show3") public String showInfo3(Model model){ List&lt;Users> list = new ArrayList&lt;>(); list.add(new Users(1,"张三",20)); list.add(new Users(2,"李四",22)); list.add(new Users(3,"王五",24)); model.addAttribute("list", list); return "index3"; } @RequestMapping("/show4") public String showInfo4(Model model){ Map&lt;String, Users> map = new HashMap&lt;>(); map.put("u1", new Users(1,"张三",20)); map.put("u2", new Users(2,"李四",22)); map.put("u3", new Users(3,"王五",24)); model.addAttribute("map", map); return "index4"; } } th:each迭代list &lt;tr th:each="u : ${list}"> &lt;td th:text="${u.userid}">&lt;/td> &lt;td th:text="${u.username}">&lt;/td> &lt;td th:text="${u.userage}">&lt;/td> &lt;/tr> th:each状态变量 index当前迭代器的索引从0开始count当前迭代对象的计数从1开始size被迭代对象的长度even/odd布尔值,当前循环是否是偶数/奇数从0开始first布尔值，当前循环的是否是第一条,如果是返回true否则返回falselast布尔值，当前循环的是否是最后一条,如果是则返回true否则返回false &lt;tr th:each="u,var : ${list}"> &lt;td th:text="${u.userid}">&lt;/td> &lt;td th:text="${u.username}">&lt;/td> &lt;td th:text="${u.userage}">&lt;/td> &lt;td th:text="${var.index}">&lt;/td> &lt;td th:text="${var.count}">&lt;/td> &lt;td th:text="${var.size}">&lt;/td> &lt;td th:text="${var.even}">&lt;/td> &lt;td th:text="${var.odd}">&lt;/td> &lt;td th:text="${var.first}">&lt;/td> &lt;td th:text="${var.last}">&lt;/td> &lt;/tr> th:each迭代Map &lt;tr th:each="maps : ${map}"> &lt;td th:each="entry:${maps}" th:text="${entry.value.userid}" >&lt;/td> &lt;td th:each="entry:${maps}" th:text="${entry.value.username}">&lt;/td> &lt;td th:each="entry:${maps}" th:text="${entry.value.userage}">&lt;/td> &lt;/tr> 域对象操作 后台数据 package com.bjsxt.controller; @Controller public class DemoController { @RequestMapping("/show5") public String showInfo5(HttpServletRequest request,Model model){ request.setAttribute("req", "HttpServletRequest"); request.getSession().setAttribute("sess", "HttpSession"); request.getSession().getServletContext().setAttribute("app", "Application"); return "index5"; } } HttpServletRequest Request:&lt;span th:text="${#httpServletRequest.getAttribute('req')}">&lt;/span>&lt;br/> HttpSession Session:&lt;span th:text="${session.sess}">&lt;/span>&lt;br/> ServletContext Application:&lt;span th:text="${application.app}">&lt;/span> URL表达式 基本语法@{} 后台数据 package com.bjsxt.controller; @Controller public class DemoController { @RequestMapping("/{page}") public String showInfo(@PathVariable String page,Integer id,String name){ System.out.println(id+"--"+name); return page; } } 绝对路径 &lt;a th:href="@{http://www.baidu.com}">绝对路径&lt;/a>&lt;br/> &lt;a href="http://www.baidu.com">绝对路径2&lt;/a> 相对路径 &lt;a th:href="@{/show}">相对路径&lt;/a> &lt;hr/> &lt;a th:href="@{~/project2/resourcename}">相对于服务器的根&lt;/a> &lt;hr/> &lt;a th:href="@{/show(id=1,name=zhagnsan)}">相对路径-传参&lt;/a> &lt;hr/> &lt;a th:href="@{/path/{id}/show(id=1,name=zhagnsan)}">相对路径-传参-restful&lt;/a> 整合MyBatis 编辑pom.xml &lt;!-- Mybatis启动器 --> &lt;dependency> &lt;groupId>org.mybatis.spring.boot&lt;/groupId> &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId> &lt;version>1.1.1&lt;/version> &lt;/dependency> &lt;!-- mysql数据库驱动 --> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;/dependency> &lt;!-- druid数据库连接池 --> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid&lt;/artifactId> &lt;version>1.0.9&lt;/version> &lt;/dependency> 编辑application.properties 进入src/main/resources目录,编辑application.properties spring.datasource.driverClassName=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/ssm spring.datasource.username=root spring.datasource.password=root spring.datasource.type=com.alibaba.druid.pool.DruidDataSource mybatis.type-aliases-package=com.bjsxt.pojo 数据库表设计 CREATE TABLE `users` ( `id` INT (11) NOT NULL AUTO_INCREMENT, `name` VARCHAR (255) DEFAULT NULL, `age` INT (11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = INNODB DEFAULT CHARSET = utf8; 添加用户 创建实体类 package com.bjsxt.pojo; public class Users { private Integer id; private String name; private Integer age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 创建mapper接口以及映射配置文件 package com.bjsxt.mapper; import com.bjsxt.pojo.Users; public interface UsersMapper { void insertUser(Users users); } &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> &lt;mapper namespace="com.bjsxt.mapper.UsersMapper"> &lt;insert id="insertUser" parameterType="users"> insert into users(name,age) values(#{name},#{age}) &lt;/insert> &lt;/mapper> 创建业务层 所有方法开启事务@Transactional标注在类上 @Service @Transactional public class UsersServiceImpl implements UsersService { @Autowired private UsersMapper usersMapper; @Override public void addUser(Users users) { this.usersMapper.insertUser(users); } } 创建Controller 前端请求http://localhost:8080/users/input跳转到input.html页面 @Controller @RequestMapping("/users") public class UsersController { @Autowired private UsersService usersService; /** * 页面跳转 */ @RequestMapping("/{page}") public String showPage(@PathVariable String page){ return page; } /** * 添加用户 */ @RequestMapping("/addUser") public String addUser(Users users){ this.usersService.addUser(users); return "ok"; } } 编写页面 使用thymeleaf模板,页面必须放在src/main/resources/templates目录下 添加用户页面input.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>添加用户&lt;/title> &lt;/head> &lt;body> &lt;form th:action="@{/users/addUser}" method="post"> 用户姓名：&lt;input type="text" name="name"/>&lt;br/> 用户年龄：&lt;input type="text" name="age"/>&lt;br/> &lt;input type="submit" value="确定"/>&lt;br/> &lt;/form> &lt;/body> &lt;/html> 添加成功页面ok.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>操作提示页面&lt;/title> &lt;/head> &lt;body> 操作成功！！！ &lt;/body> &lt;/html> 创建启动类 用户扫描MyBatis的Mapper接口,使用@MapperScan(&quot;com.bjsxt.mapper&quot;)注解 package com.bjsxt; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan("com.bjsxt.mapper") //@MapperScan 用户扫描MyBatis的Mapper接口 public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 查询用户 修改mapper接口中以及映射配置文件 List&lt;Users> selectUsersAll(); &lt;select id="selectUsersAll" resultType="users"> select id,name,age from users &lt;/select> 修改业务层 添加查询方法 @Override public List&lt;Users> findUserAll() { return this.usersMapper.selectUsersAll(); } 修改Controller 浏览器请求http://localhost:8080/findUserAll,跳转到showUsers.html /** * 查询全部用户 */ @RequestMapping("/findUserAll") public String findUserAll(Model model){ List&lt;Users> list = this.usersService.findUserAll(); model.addAttribute("list", list); return "showUsers"; } 创建页面 查询用户页面showUsers.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>展示用户数据&lt;/title> &lt;/head> &lt;body> &lt;table border="1" style="width:300px;"> &lt;tr> &lt;th>用户ID&lt;/th> &lt;th>用户姓名&lt;/th> &lt;th>用户年龄&lt;/th> &lt;/tr> &lt;tr th:each="user : ${list}"> &lt;td th:text="${user.id}">&lt;/td> &lt;td th:text="${user.name}">&lt;/td> &lt;td th:text="${user.age}">&lt;/td> &lt;/tr> &lt;/table> &lt;/body> &lt;/html> 更新用户 数据回显 更新用户之前的查询，将数据在页面中回显 修改mapper接口以及映射配置文件 Users selectUsersById(Integer id); &lt;select id="selectUsersById" resultType="users"> select id,name,age from users where id = #{value} &lt;/select> 修改业务层代码 @Override public Users findUserById(Integer id) { return this.usersMapper.selectUsersById(id); } 修改Controller 浏览器请求http://localhost:8080/findUserById,跳转到updateUser.html页面，将数据用户数据回显 /** * 根据用户id查询用户 */ @RequestMapping("/findUserById") public String findUserById(Integer id,Model model){ Users user = this.usersService.findUserById(id); model.addAttribute("user", user); return "updateUser"; } 编写页面 更新用户页面updateUser.html进行数据回显,使用th:field取得controller中的模型数据 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Insert title here&lt;/title> &lt;/head> &lt;body> &lt;form th:action="@{/users/editUser}" method="post"> &lt;input type="hidden" name="id" th:field="${user.id}"/> 用户姓名：&lt;input type="text" name="name" th:field="${user.name}"/>&lt;br/> 用户年龄：&lt;input type="text" name="age" th:field="${user.age}"/>&lt;br/> &lt;input type="submit" value="确定"/>&lt;br/> &lt;/form> &lt;/body> &lt;/html> 更新 修改mapper接口以及映射配置文件 void updateUser(Users users); &lt;update id="updateUser" parameterType="users"> update users set name=#{name} ,age=#{age} where id=#{id} &lt;/update> 修改业务层代码 @Override public void updateUser(Users users) { this.usersMapper.updateUser(users); } 修改Controller 更新用户页面updateUser.html点击提交，浏览器请求http://localhost:8080/editUser,跳转到修改成功页面ok.html /** * 更新用户 */ @RequestMapping("/editUser") public String editUser(Users users){ this.usersService.updateUser(users); return "ok"; } 删除用户 修改mapper接口以及映射配置文件 void deleteUserById(Integer id); &lt;delete id="deleteUserById"> delete from users where id = #{value} &lt;/delete> 修改业务层 @Override public void deleteUserById(Integer id) { this.usersMapper.deleteUserById(id); } 修改Controller 浏览器请求http://localhost:8080/delUser重定向请求/users/findUserAll，跳转到查询用户页面showUsers.html /** * 删除用户 */ @RequestMapping("/delUser") public String delUser(Integer id){ this.usersService.deleteUserById(id); return "redirect:/users/findUserAll"; } 修改页面 修改查询用户页面showUsers.html,增加删除按钮链接 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>展示用户数据&lt;/title> &lt;/head> &lt;body> &lt;table border="1" style="width:500px;"> &lt;tr> &lt;th>用户ID&lt;/th> &lt;th>用户姓名&lt;/th> &lt;th>用户年龄&lt;/th> &lt;th>操作&lt;/th> &lt;/tr> &lt;tr th:each="user : ${list}"> &lt;td th:text="${user.id}">&lt;/td> &lt;td th:text="${user.name}">&lt;/td> &lt;td th:text="${user.age}">&lt;/td> &lt;td> &lt;a th:href="@{/users/findUserById(id=${user.id})}">更新用户&lt;/a> &lt;a th:href="@{/users/delUser(id=${user.id})}">删除用户&lt;/a> &lt;/td> &lt;/tr> &lt;/table> &lt;/body> &lt;/html> 服务端表单数据校验 表单做数据校验 修改实体类 非空校验使用@NotBlank注解标注在属性上 package com.bjsxt.pojo; import org.hibernate.validator.constraints.NotBlank; public class Users { @NotBlank //非空校验 private String name; @NotBlank //密码非空校验 private String password; private Integer age; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return "Users [name=" + name + ", password=" + password + ", age=" + age + "]"; } } 修改Controller 浏览器请求http://localhost:8080/addUser,跳转到添加用户页面add.html,点击提交按钮浏览器请求http://localhost:8080/save,如果校验通过跳转到成功页面ok.html,校验不通过跳转到添加用户页面add.html 开启校验使用@Valid注解封装了校验的结果BindingResult /** * SpringBoot 表单数据校验 * * */ @Controller public class UsersController { @RequestMapping("/addUser") public String showPage(){ return "add"; } /** * 完成用户添加 *@Valid 开启对Users对象的数据校验 *BindingResult:封装了校验的结果 */ @RequestMapping("/save") public String saveUser(@Valid Users users,BindingResult result){ if(result.hasErrors()){ return "add"; } System.out.println(users); return "ok"; } } 修改页面 添加用户页面add.html,使用th:errors取得校验信息 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>添加用户&lt;/title> &lt;/head> &lt;body> &lt;form th:action="@{/save}" method="post"> 用户姓名：&lt;input type="text" name="name"/>&lt;font color="red" th:errors="${users.name}">&lt;/font>&lt;br/> 用户密码：&lt;input type="password" name="password" />&lt;font color="red" th:errors="${users.password}">&lt;/font>&lt;br/> 用户年龄：&lt;input type="text" name="age" />&lt;font color="red" th:errors="${users.age}">&lt;/font>&lt;br/> &lt;input type="submit" value="OK"/> &lt;/form> &lt;/body> &lt;/html> 坑 java.lang.IllegalStateException: Neither BindingResult nor plain target object for bean name ‘users’ available as request attribute 描述 浏览器请求http://localhost:8080/addUser方法，该方法并没有传递Users对象，跳转到添加用户页面add.html取不到数据所以报错 解决 方式一 跳转页面注入对象 可以在浏览器请求http://localhost:8080/addUser方法中注入一个Uesrs对象由于springmvc会将Uesrs对象放入到Model模型中传递,使用驼峰命名规则,参数的变量名需要与对象的名称相同,将首字母小写 修改Controller /** * SpringBoot 表单数据校验 * * */ @Controller public class UsersController { /** * * 如果想为传递的对象更改名称，可以使用@ModelAttribute("aa")这表示当前传递的对象的key为aa。 * 那么我们在页面中获取该对象的key也需要修改为aa * @param users * @return */ @RequestMapping("/addUser") public String showPage(Users users){ return "add"; } /** * 完成用户添加 *@Valid 开启对Users对象的数据校验 *BindingResult:封装了校验的结果 */ @RequestMapping("/save") public String saveUser(@Valid Users users,BindingResult result){ if(result.hasErrors()){ return "add"; } System.out.println(users); return "ok"; } } 方式二 设置参数名称可变 如果想为传递的对象更改名称,可以使用@ModelAttribute(&quot;aa&quot;)这表示当前传递的对象的key为aa那么我们在页面中获取该对象的key也需要修改为aa 修改Controller /** * SpringBoot 表单数据校验 * * */ @Controller public class UsersController { /** * * 如果想为传递的对象更改名称，可以使用@ModelAttribute("aa")这表示当前传递的对象的key为aa。 * 那么我们在页面中获取该对象的key也需要修改为aa * @param users * @return */ @RequestMapping("/addUser") public String showPage(@ModelAttribute("aa") Users users){ return "add"; } /** * 完成用户添加 *@Valid 开启对Users对象的数据校验 *BindingResult:封装了校验的结果 */ @RequestMapping("/save") public String saveUser(@ModelAttribute("aa") @Valid Users users,BindingResult result){ if(result.hasErrors()){ return "add"; } System.out.println(users); return "ok"; } } 修改页面 添加用户页面add.html,${aa.name}需要和请求http://localhost:8080/addUser方法中设置的@ModelAttribute(&quot;aa&quot;)一样 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>添加用户&lt;/title> &lt;/head> &lt;body> &lt;form th:action="@{/save}" method="post"> 用户姓名：&lt;input type="text" name="name"/>&lt;font color="red" th:errors="${aa.name}">&lt;/font>&lt;br/> 用户密码：&lt;input type="password" name="password" />&lt;font color="red" th:errors="${aa.password}">&lt;/font>&lt;br/> 用户年龄：&lt;input type="text" name="age" />&lt;font color="red" th:errors="${aa.age}">&lt;/font>&lt;br/> 用户邮箱：&lt;input type="text" name="email" />&lt;font color="red" th:errors="${aa.email}">&lt;/font>&lt;br/> &lt;input type="submit" value="OK"/> &lt;/form> &lt;/body> &lt;/html> 其他校验规则 @NotBlank判断字符串是否为null或者是空串(去掉首尾空格)。@NotEmpty判断字符串是否null或者是空串。@Length判断字符的长度(最大或者最小)@Min判断数值最小值@Max判断数值最大值@Email判断邮箱是否合法 修改实体类 public class Users { @NotBlank(message="用户名不能为空") //非空校验 @Length(min=2,max=6,message="最小长度为2位，最大长度为6位") private String name; @NotEmpty private String password; @Min(value=15) private Integer age; @Email private String email; public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return "Users [name=" + name + ", password=" + password + ", age=" + age + "]"; } } 异常处理 SpringBoot中对于异常处理提供了五种处理方式 自定义错误页面 默认的处理异常的机制 一旦程序中出现了异常SpringBoot会向/error发送请求。在springBoot中提供了一个叫BasicExceptionController类来处理/error请求，然后跳转到默认显示异常的页面来展示异常信息 修改Controller 浏览器请求http://localhost:8080/show和http://localhost:8080/show2发生了异常,并不会跳转到index.html页面，而是会有默认异常页面error.html来显示异常信息 package com.bjsxt.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; /** * SpringBoot处理异常方式一：自定义错误页面 * * */ @Controller public class DemoController { @RequestMapping("/show") public String showInfo(){ String str = null; str.length(); return "index"; } @RequestMapping("/show2") public String showInfo2(){ int a = 10/0; return "index"; } } 效果 修改页面 如果我们需要将所有的异常同一跳转到自定义的错误页面需要在src/main/resources/templates目录下创建error.html页面,名称必须叫error.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>错误提示页面&lt;/title> &lt;/head> &lt;body> 出错了，请与管理员联系。。。 &lt;span th:text="${exception}">&lt;/span> &lt;/body> &lt;/html> 弊端 对所有异常都显示到异常页面error.html,不能处理对不同的异常跳转到不同的异常显示页面 @ExceptionHandle 修改Controller 使用@ExceptionHandler注解标注在方法上分别对不同的异常进行处理 使用ModelAndView可以指定异常信息及异常视图页面 /** * SpringBoot处理异常方式二：@ExceptionHandle注解处理异常 * * */ @Controller public class DemoController { @RequestMapping("/show") public String showInfo(){ String str = null; str.length(); return "index"; } @RequestMapping("/show2") public String showInfo2(){ int a = 10/0; return "index"; } /** * java.lang.ArithmeticException * 该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 * 参数Exception e:会将产生异常对象注入到方法中 */ @ExceptionHandler(value={java.lang.ArithmeticException.class}) public ModelAndView arithmeticExceptionHandler(Exception e){ ModelAndView mv = new ModelAndView(); mv.addObject("error", e.toString()); mv.setViewName("error1"); return mv; } /** * java.lang.NullPointerException * 该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 * 参数Exception e:会将产生异常对象注入到方法中 */ @ExceptionHandler(value={java.lang.NullPointerException.class}) public ModelAndView nullPointerExceptionHandler(Exception e){ ModelAndView mv = new ModelAndView(); mv.addObject("error", e.toString()); mv.setViewName("error2"); return mv; } } 修改页面 进入src/main/resources/templates目录下，创建空指针和算术异常页面 算术异常页面error1.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>错误提示页面-ArithmeticException&lt;/title> &lt;/head> &lt;body> 出错了，请与管理员联系。。。 &lt;span th:text="${error}">&lt;/span> &lt;/body> &lt;/html> 空指针异常页面error2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>错误提示页面-NullPointerException&lt;/title> &lt;/head> &lt;body> 出错了，请与管理员联系。。。 &lt;span th:text="${error}">&lt;/span> &lt;/body> &lt;/html> 效果 弊端 只有标记了@ExceptionHandle注解的Controller类才能处理跳转到自定义异常页面，而其它的Controller类中的方法则还是跳转到springboot默认机制的异常处理 @ControllerAdvice+@ExceptionHandler 修改Controller 全局异常控制类GlobalException.java,浏览器请求Controller，如果发生了异常，则会走全局异常控制类GlobalException.java,该类可以对不同的异常进行不同的处理(指定异常信息、视图页面) 该方式优于@ExceptionHandle注解处理异常 /** * 全局异常处理类 * * */ @ControllerAdvice public class GlobalException { /** * java.lang.ArithmeticException * 该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 * 参数Exception e:会将产生异常对象注入到方法中 */ @ExceptionHandler(value={java.lang.ArithmeticException.class}) public ModelAndView arithmeticExceptionHandler(Exception e){ ModelAndView mv = new ModelAndView(); mv.addObject("error", e.toString()); mv.setViewName("error1"); return mv; } /** * java.lang.NullPointerException * 该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 * 参数Exception e:会将产生异常对象注入到方法中 */ @ExceptionHandler(value={java.lang.NullPointerException.class}) public ModelAndView nullPointerExceptionHandler(Exception e){ ModelAndView mv = new ModelAndView(); mv.addObject("error", e.toString()); mv.setViewName("error2"); return mv; } } 效果 SimpleMappingExceptionResolver 比起@ControllerAdvice+@ExceptionHandler处理异常,通过SimpleMappingExceptionResolver做全局异常处理,方式更优雅,但是有个缺点即在异常页面不能输出异常信息 修改Controller /** * 通过SimpleMappingExceptionResolver做全局异常处理 * * */ @Configuration public class GlobalException { /** * 该方法必须要有返回值。返回值类型必须是：SimpleMappingExceptionResolver */ @Bean public SimpleMappingExceptionResolver getSimpleMappingExceptionResolver(){ SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver(); Properties mappings = new Properties(); /** * 参数一：异常的类型，注意必须是异常类型的全名 * 参数二：视图名称 */ mappings.put("java.lang.ArithmeticException", "error1"); mappings.put("java.lang.NullPointerException","error2"); //设置异常与视图映射信息的 resolver.setExceptionMappings(mappings); return resolver; } } 效果 不能输出异常信息 弊端 不能在异常页面输出异常信息，SimpleMappingExceptionResolver类处理异常只能针对不同的异常映射不同的视图逻辑 自定义HandlerExceptionResolver 修改Controller 定义全局异常控制类必须要实现HandlerExceptionResolver接口,该种方式可以针对不同异常跳转不同的异常页面，并且在异常异页面可以输出异常信息，但是平常异常信息不会直接输出在异常页，避免异常数据被人窃取 推荐使用 /** * 通过实现HandlerExceptionResolver接口做全局异常处理 * * */ @Configuration public class GlobalException implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { ModelAndView mv = new ModelAndView(); //判断不同异常类型，做不同视图跳转 if(ex instanceof ArithmeticException){ mv.setViewName("error1"); } if(ex instanceof NullPointerException){ mv.setViewName("error2"); } mv.addObject("error", ex.toString()); return mv; } } 单元测试 修改pom.xml &lt;!-- 添加junit环境的jar包 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;/dependency> 创建dao package com.bjsxt.dao; import org.springframework.stereotype.Repository; @Repository public class UserDaoImpl { public void saveUser(){ System.out.println("insert into users....."); } } 创建service package com.bjsxt.service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.bjsxt.dao.UserDaoImpl; @Service public class UserServiceImpl { @Autowired private UserDaoImpl userDaoImpl; public void addUser(){ this.userDaoImpl.saveUser(); } } 创建启动类 package com.bjsxt; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 整合Junit做单元测试 @RunWith启动器SpringJUnit4ClassRunner.class让junit与spring环境进行整合 @SpringBootTest(classes={App.class})说明当前类为springBoot的测试类加载SpringBoot启动类App.class package com.bjsxt.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.App; import com.bjsxt.service.UserServiceImpl; /** * SpringBoot测试类 *@RunWith:启动器 *SpringJUnit4ClassRunner.class：让junit与spring环境进行整合 * *@SpringBootTest(classes={App.class}) 1,当前类为springBoot的测试类 *@SpringBootTest(classes={App.class}) 2,加载SpringBoot启动类。启动springBoot * *junit与spring整合 @Contextconfiguartion("classpath:applicationContext.xml") */ @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest(classes={App.class}) public class UserServiceTest { @Autowired private UserServiceImpl userServiceImpl; @Test public void testAddUser(){ this.userServiceImpl.addUser(); } } 热部署 SpringLoader插件 创建controller package com.bjsxt.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; /** * SpringBoot----SpringLoader * * */ @Controller public class UsersController { @RequestMapping("/show") public String showPage(){ System.out.println("ShowPage......"); return "index"; } } 创建页面 进入/src/main/resources/templates目录下，创建热部署前端测试页面 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Insert title here&lt;/title> &lt;/head> &lt;body> &lt;span th:text="Hello....">&lt;/span> &lt;/body> &lt;/html> 创建启动类 package com.bjsxt; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 运行 方式一 修改pom.xml &lt;!-- springloader插件 --> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>springloaded&lt;/artifactId> &lt;version>1.2.5.RELEASE&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/plugin> &lt;/plugins> &lt;/build> maven命令启动 弊端 这种方式的缺点是Springloader热部署程序是在系统后台以进程的形式来运行,需要手动关闭该进程对Java代码做部署处理,但是对页面无能为力 方式二 在项目中直接使用jar包的方式 启动命令VM Options参数-javaagent:.\lib\springloaded-1.2.5.RELEASE.jar -noverify DevTools工具 修改pom.xml &lt;!-- DevTools的坐标 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;/dependency> SpringLoader与DevTools的区别 SpringLoader在部署项目时使用的是热部署的方式 DevTools在部署项目时使用的是重新部署的方式 整合Ehcache 修改pom.xml &lt;dependencies> &lt;!-- springBoot的启动器 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;!-- springBoot的启动器 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> &lt;!-- springBoot的启动器 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-jpa&lt;/artifactId> &lt;/dependency> &lt;!-- 测试工具的启动器 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;/dependency> &lt;!-- mysql --> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;/dependency> &lt;!-- druid连接池 --> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid&lt;/artifactId> &lt;version>1.0.9&lt;/version> &lt;/dependency> &lt;!-- Spring Boot缓存支持启动器 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-cache&lt;/artifactId> &lt;/dependency> &lt;!-- Ehcache坐标 --> &lt;dependency> &lt;groupId>net.sf.ehcache&lt;/groupId> &lt;artifactId>ehcache&lt;/artifactId> &lt;/dependency> &lt;/dependencies> 创建Ehcache的配置文件 进入src/main/resources/目录下,创建ehcache.xml &lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../config/ehcache.xsd"> &lt;diskStore path="java.io.tmpdir"/> &lt;!--defaultCache:echcache的默认缓存策略 --> &lt;defaultCache maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" maxElementsOnDisk="10000000" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"> &lt;persistence strategy="localTempSwap"/> &lt;/defaultCache> &lt;!-- 自定义缓存策略 --> &lt;cache name="users" maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" maxElementsOnDisk="10000000" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"> &lt;persistence strategy="localTempSwap"/> &lt;/cache> &lt;/ehcache> 修改application.properties文件 进入src/main/resources/目录下,修改application.properties spring.datasource.driverClassName=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/ssm spring.datasource.username=root spring.datasource.password=root spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true spring.cache.ehcache.cofnig=ehcache.xml 创建service 使用缓存策略@Cacheable(value=&quot;users&quot;) package com.bjsxt.service.impl; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cache.annotation.Cacheable; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.stereotype.Service; import com.bjsxt.dao.UsersRepository; import com.bjsxt.pojo.Users; import com.bjsxt.service.UsersService; /** * UsersService接口实现类 * * */ @Service public class UsersServiceImpl implements UsersService { @Autowired private UsersRepository usersRepository; @Override public List&lt;Users> findUserAll() { return this.usersRepository.findAll(); } @Override //@Cacheable:对当前查询的对象做缓存处理 @Cacheable(value="users") public Users findUserById(Integer id) { return this.usersRepository.findOne(id); } @Override public Page&lt;Users> findUserByPage(Pageable pageable) { return this.usersRepository.findAll(pageable); } @Override public void saveUsers(Users users) { this.usersRepository.save(users); } } 修改实体类 package com.bjsxt.pojo; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name="t_users") public class Users implements Serializable { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="id") private Integer id; @Column(name="name") private String name; @Column(name="age") private Integer age; @Column(name="address") private String address; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return "Users [id=" + id + ", name=" + name + ", age=" + age + ", address=" + address + "]"; } } 创建启动类 开启缓存使用@EnableCaching注解 package com.bjsxt; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cache.annotation.EnableCaching; @SpringBootApplication @EnableCaching public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 测试 package com.bjsxt.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.App; import com.bjsxt.service.UsersService; /** * UsersService测试 * * */ @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest(classes=App.class) public class UsersServiceTest { @Autowired private UsersService usersService; @Test public void testFindUserById(){ //第一次查询 System.out.println(this.usersService.findUserById(1)); //第二次查询 System.out.println(this.usersService.findUserById(1)); } } 效果 后台输出执行了一次sql查询，第二条结果是从缓存中取出来的 Hibernate: select users0_.id as id1_0_0_, users0_.address as address2_0_0_, users0_.age as age3_0_0_, users0_.name as name4_0_0_ from t_users users0_ where users0_.id=? Users [id=1, name=shenlibing, age=18, address=haikoou] Users [id=1, name=shenlibing, age=18, address=haikoou] 2019-04-08 15:28:17.262 INFO 1320 --- [ Thread-4] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@5b94b04d: startup date [Mon Apr 08 15:28:11 CST 2019]; root of context hierarchy 2019-04-08 15:28:17.265 INFO 1320 --- [ Thread-4] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &#39;default&#39; 2019-04-08 15:28:17.270 INFO 1320 --- [ Thread-4] com.alibaba.druid.pool.DruidDataSource : {dataSource-1} closed @Cacheable 把方法的返回值添加到Ehcache中做缓存 Value属性：指定一个Ehcache配置文件中的缓存策略，如果么有给定value，则表示使用默认的缓存策略 Key属性：给存储的值起个名称。在查询时如果有名称相同的，那么则知己从缓存中将数据返回 修改service package com.bjsxt.service.impl; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cache.annotation.Cacheable; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.stereotype.Service; import com.bjsxt.dao.UsersRepository; import com.bjsxt.pojo.Users; import com.bjsxt.service.UsersService; /** * UsersService接口实现类 * * */ @Service public class UsersServiceImpl implements UsersService { @Autowired private UsersRepository usersRepository; @Override public List&lt;Users> findUserAll() { return this.usersRepository.findAll(); } @Override //@Cacheable:对当前查询的对象做缓存处理 @Cacheable(value="users") public Users findUserById(Integer id) { return this.usersRepository.findOne(id); } @Override @Cacheable(value="users",key="#pageable.pageSize") public Page&lt;Users> findUserByPage(Pageable pageable) { return this.usersRepository.findAll(pageable); } @Override public void saveUsers(Users users) { this.usersRepository.save(users); } } 修改测试 package com.bjsxt.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.App; import com.bjsxt.service.UsersService; /** * UsersService测试 * * */ @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest(classes=App.class) public class UsersServiceTest { @Autowired private UsersService usersService; @Test public void testFindUserByPage(){ Pageable pageable = new PageRequest(0, 2); //第一次查询 System.out.println(this.usersService.findUserByPage(pageable).getTotalElements()); //第二次查询 System.out.println(this.usersService.findUserByPage(pageable).getTotalElements()); //第三次查询 pageable = new PageRequest(1, 2); System.out.println(this.usersService.findUserByPage(pageable).getTotalElements()); } } 效果 后台输出执行了一次sql查询，后面两次是从缓存取出来的 因为service层使用了缓存策略@Cacheable(value=&quot;users&quot;,key=&quot;#pageable.pageSize&quot;)且指定了key为分页的每页条数在测试查询的时候虽然第三次查询重新new PageRequest(1, 2)，但是size还是为2，所以还是从缓存中取 Hibernate: select users0_.id as id1_0_, users0_.address as address2_0_, users0_.age as age3_0_, users0_.name as name4_0_ from t_users users0_ limit ? Hibernate: select count(users0_.id) as col_0_0_ from t_users users0_ 5 5 5 2019-04-08 15:45:08.451 INFO 20352 --- [ Thread-4] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@192c3f1e: startup date [Mon Apr 08 15:45:02 CST 2019]; root of context hierarchy 2019-04-08 15:45:08.457 INFO 20352 --- [ Thread-4] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &#39;default&#39; 2019-04-08 15:45:08.464 INFO 20352 --- [ Thread-4] com.alibaba.druid.pool.DruidDataSource : {dataSource-1} closed @CacheEvict 清除缓存,在对频繁查询的数据可以从缓存中取,然而一旦有新的数据写入数据库,必须重新刷新缓存,即清除缓存 修改service @Override //@CacheEvict(value="users",allEntries=true) 清除缓存中以users缓存策略缓存的对象 @CacheEvict(value="users",allEntries=true) public void saveUsers(Users users) { this.usersRepository.save(users); } 修改测试 package com.bjsxt.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.App; import com.bjsxt.pojo.Users; import com.bjsxt.service.UsersService; /** * UsersService测试 * * */ @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest(classes=App.class) public class UsersServiceTest { @Autowired private UsersService usersService; @Test public void testFindAll(){ //第一次查询 System.out.println(this.usersService.findUserAll().size()); Users users = new Users(); users.setAddress("南京"); users.setAge(43); users.setName("朱七"); this.usersService.saveUsers(users); //第二次查询 System.out.println(this.usersService.findUserAll().size()); } } 效果 后台输出第一次查询和第二次查询之间插入了一条新数据，第一次查询结果是5条，在插入数据方法saveUsers上开启了清除缓存，所以插入数据之后再一次查询的数据也就同步过来更新为6条 Hibernate: select users0_.id as id1_0_, users0_.address as address2_0_, users0_.age as age3_0_, users0_.name as name4_0_ from t_users users0_ 5 Hibernate: insert into t_users (address, age, name) values (?, ?, ?) Hibernate: select users0_.id as id1_0_, users0_.address as address2_0_, users0_.age as age3_0_, users0_.name as name4_0_ from t_users users0_ 6 2019-04-08 15:54:13.046 INFO 19660 --- [ Thread-4] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@192c3f1e: startup date [Mon Apr 08 15:54:08 CST 2019]; root of context hierarchy 2019-04-08 15:54:13.049 INFO 19660 --- [ Thread-4] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &#39;default&#39; 2019-04-08 15:54:13.053 INFO 19660 --- [ Thread-4] com.alibaba.druid.pool.DruidDataSource : {dataSource-1} closed 整合Redis 修改pom.xml &lt;!-- Spring Data Redis的启动器 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId> &lt;/dependency> 创建Redis配置类 package com.bjsxt.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.jedis.JedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.StringRedisSerializer; import redis.clients.jedis.JedisPoolConfig; /** * 完成对Redis的整合的一些配置 * * */ @Configuration public class RedisConfig { /** * 1.创建JedisPoolConfig对象。在该对象中完成一些链接池配置 * */ @Bean public JedisPoolConfig jedisPoolConfig(){ JedisPoolConfig config = new JedisPoolConfig(); //最大空闲数 config.setMaxIdle(10); //最小空闲数 config.setMinIdle(5); //最大链接数 config.setMaxTotal(20); return config; } /** * 2.创建JedisConnectionFactory：配置redis链接信息 */ @Bean public JedisConnectionFactory jedisConnectionFactory(JedisPoolConfig config){ JedisConnectionFactory factory = new JedisConnectionFactory(); //关联链接池的配置对象 factory.setPoolConfig(config); //配置链接Redis的信息 //主机地址 factory.setHostName("192.168.1.104"); //端口 factory.setPort(6379); return factory; } /** * 3.创建RedisTemplate:用于执行Redis操作的方法 */ @Bean public RedisTemplate&lt;String,Object> redisTemplate(JedisConnectionFactory factory){ RedisTemplate&lt;String, Object> template = new RedisTemplate&lt;>(); //关联 template.setConnectionFactory(factory); //为key设置序列化器 template.setKeySerializer(new StringRedisSerializer()); //为value设置序列化器 template.setValueSerializer(new StringRedisSerializer()); return template; } } 创建测试 修改pom.xml 添加测试启动依赖坐标 &lt;!-- Test的启动器 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;/dependency> 测试 package com.bjsxt.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.App; /** * Spring Data Redis测试 * * */ @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest(classes=App.class) public class RedisTest { @Autowired private RedisTemplate&lt;String, Object> redisTemplate; /** * 添加一个字符串 */ @Test public void testSet(){ this.redisTemplate.opsForValue().set("key", "北京尚学堂"); } /** * 获取一个字符串 */ @Test public void testGet(){ String value = (String)this.redisTemplate.opsForValue().get("key"); System.out.println(value); } } 提取redis的配置信息 修改application.properties 进入src/main/resource/目录,修改application.properties spring.redis.pool.max-idle=10 spring.redis.pool.min-idle=5 spring.redis.pool.max-total=20 spring.redis.hostName=192.168.1.104 spring.redis.port=6379 修改redis配置类 将前缀相同的内容创建一个实体使用@ConfigurationProperties注解 package com.bjsxt.config; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.jedis.JedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.StringRedisSerializer; import redis.clients.jedis.JedisPoolConfig; /** * 完成对Redis的整合的一些配置 * * */ @Configuration public class RedisConfig { /** * 1.创建JedisPoolConfig对象。在该对象中完成一些链接池配置 * @ConfigurationProperties:会将前缀相同的内容创建一个实体。 */ @Bean @ConfigurationProperties(prefix="spring.redis.pool") public JedisPoolConfig jedisPoolConfig(){ JedisPoolConfig config = new JedisPoolConfig(); /*//最大空闲数 config.setMaxIdle(10); //最小空闲数 config.setMinIdle(5); //最大链接数 config.setMaxTotal(20);*/ System.out.println("默认值："+config.getMaxIdle()); System.out.println("默认值："+config.getMinIdle()); System.out.println("默认值："+config.getMaxTotal()); return config; } /** * 2.创建JedisConnectionFactory：配置redis链接信息 */ @Bean @ConfigurationProperties(prefix="spring.redis") public JedisConnectionFactory jedisConnectionFactory(JedisPoolConfig config){ System.out.println("配置完毕："+config.getMaxIdle()); System.out.println("配置完毕："+config.getMinIdle()); System.out.println("配置完毕："+config.getMaxTotal()); JedisConnectionFactory factory = new JedisConnectionFactory(); //关联链接池的配置对象 factory.setPoolConfig(config); //配置链接Redis的信息 //主机地址 /*factory.setHostName("192.168.1.104"); //端口 factory.setPort(6379);*/ return factory; } /** * 3.创建RedisTemplate:用于执行Redis操作的方法 */ @Bean public RedisTemplate&lt;String,Object> redisTemplate(JedisConnectionFactory factory){ RedisTemplate&lt;String, Object> template = new RedisTemplate&lt;>(); //关联 template.setConnectionFactory(factory); //为key设置序列化器 template.setKeySerializer(new StringRedisSerializer()); //为value设置序列化器 template.setValueSerializer(new StringRedisSerializer()); return template; } } 效果 2019-04-08 16:24:36.624 INFO 9340 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode! 默认值：8 默认值：0 默认值：8 配置完毕：10 配置完毕：5 配置完毕：20 2019-04-08 16:24:38.113 INFO 9340 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.web.context.support.GenericWebApplicationContext@79d8407f: startup date [Mon Apr 08 16:24:35 CST 2019]; root of context hierarchy 2019-04-08 16:24:38.184 INFO 9340 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error]}&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest) 2019-04-08 16:24:38.185 INFO 9340 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error],produces=[text/html]}&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse) 2019-04-08 16:24:38.221 INFO 9340 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2019-04-08 16:24:38.221 INFO 9340 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2019-04-08 16:24:38.269 INFO 9340 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2019-04-08 16:24:38.317 WARN 9340 --- [ main] org.thymeleaf.templatemode.TemplateMode : [THYMELEAF][main] Template Mode &#39;HTML5&#39; is deprecated. Using Template Mode &#39;HTML&#39; instead. 2019-04-08 16:24:38.931 INFO 9340 --- [ main] com.bjsxt.test.RedisTest : Started RedisTest in 4.089 seconds (JVM running for 5.112) 北京尚学堂 2019-04-08 16:24:39.039 INFO 9340 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@79d8407f: startup date [Mon Apr 08 16:24:35 CST 2019]; root of context hierarchy 存储实体对象 创建实体 实体必须实现序列化接口 package com.bjsxt.pojo; import java.io.Serializable; public class Users implements Serializable { private Integer id; private String name; private Integer age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return "Users [id=" + id + ", name=" + name + ", age=" + age + "]"; } } 修改测试 保存实体前时必须重新设置序列化器 package com.bjsxt.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.App; import com.bjsxt.pojo.Users; /** * Spring Data Redis测试 * * */ @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest(classes=App.class) public class RedisTest { @Autowired private RedisTemplate&lt;String, Object> redisTemplate; /** * 添加Users对象 */ @Test public void testSetUesrs(){ Users users = new Users(); users.setAge(20); users.setName("张三丰"); users.setId(1); //重新设置序列化器 this.redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); this.redisTemplate.opsForValue().set("users", users); } /** * 取Users对象 */ @Test public void testGetUsers(){ //重新设置序列化器 this.redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); Users users = (Users)this.redisTemplate.opsForValue().get("users"); System.out.println(users); } } 效果 2019-04-08 16:29:32.045 INFO 12720 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode! 默认值：8 默认值：0 默认值：8 配置完毕：10 配置完毕：5 配置完毕：20 2019-04-08 16:29:33.400 INFO 12720 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.web.context.support.GenericWebApplicationContext@1e66f1f5: startup date [Mon Apr 08 16:29:31 CST 2019]; root of context hierarchy 2019-04-08 16:29:33.477 INFO 12720 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error]}&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest) 2019-04-08 16:29:33.478 INFO 12720 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error],produces=[text/html]}&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse) 2019-04-08 16:29:33.518 INFO 12720 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2019-04-08 16:29:33.518 INFO 12720 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2019-04-08 16:29:33.564 INFO 12720 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2019-04-08 16:29:33.607 WARN 12720 --- [ main] org.thymeleaf.templatemode.TemplateMode : [THYMELEAF][main] Template Mode &#39;HTML5&#39; is deprecated. Using Template Mode &#39;HTML&#39; instead. 2019-04-08 16:29:34.223 INFO 12720 --- [ main] com.bjsxt.test.RedisTest : Started RedisTest in 3.616 seconds (JVM running for 4.489) Users [id=1, name=张三丰, age=20] 2019-04-08 16:29:34.352 INFO 12720 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@1e66f1f5: startup date [Mon Apr 08 16:29:31 CST 2019]; root of context hierarchy JdkSerializationRedisSerializer弊端 实体对象通过JdkSerializationRedisSerializer序列化后存到Redis中占用空间大 JSON格式存储实体对象 推荐使用 修改测试 重置序列化Jackson2JsonRedisSerializer package com.bjsxt.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.bjsxt.App; import com.bjsxt.pojo.Users; /** * Spring Data Redis测试 * * */ @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest(classes=App.class) public class RedisTest { @Autowired private RedisTemplate&lt;String, Object> redisTemplate; /** * 基于JSON格式存Users对象 */ @Test public void testSetUsersUseJSON(){ Users users = new Users(); users.setAge(20); users.setName("李四丰"); users.setId(1); this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;>(Users.class)); this.redisTemplate.opsForValue().set("users_json", users); } /** * 基于JSON格式取Users对象 */ @Test public void testGetUseJSON(){ this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;>(Users.class)); Users users = (Users)this.redisTemplate.opsForValue().get("users_json"); System.out.println(users); } } 效果 2019-04-08 16:41:53.694 INFO 19280 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode! 默认值：8 默认值：0 默认值：8 配置完毕：10 配置完毕：5 配置完毕：20 2019-04-08 16:41:55.094 INFO 19280 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.web.context.support.GenericWebApplicationContext@1e66f1f5: startup date [Mon Apr 08 16:41:52 CST 2019]; root of context hierarchy 2019-04-08 16:41:55.177 INFO 19280 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error]}&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest) 2019-04-08 16:41:55.178 INFO 19280 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error],produces=[text/html]}&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse) 2019-04-08 16:41:55.216 INFO 19280 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2019-04-08 16:41:55.216 INFO 19280 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2019-04-08 16:41:55.259 INFO 19280 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2019-04-08 16:41:55.311 WARN 19280 --- [ main] org.thymeleaf.templatemode.TemplateMode : [THYMELEAF][main] Template Mode &#39;HTML5&#39; is deprecated. Using Template Mode &#39;HTML&#39; instead. 2019-04-08 16:41:55.957 INFO 19280 --- [ main] com.bjsxt.test.RedisTest : Started RedisTest in 3.767 seconds (JVM running for 4.678) Users [id=1, name=李四丰, age=20] 2019-04-08 16:41:56.141 INFO 19280 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@1e66f1f5: startup date [Mon Apr 08 16:41:52 CST 2019]; root of context hierarchy]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat集群与Redis分布式]]></title>
    <url>%2F2019%2F03%2F25%2Fjava-qi-ye-ji-dian-shang-xiang-mu-jia-gou-yan-jin-zhi-lu-tomcat-ji-qun-yu-redis-fen-bu-shi%2F</url>
    <content type="text"><![CDATA[Lombok原理及使用 下载 官网 插件下载 IDEA安装Lombok插件 Add the Lombok IntelliJ plugin to add lombok support for IntelliJ:Go to File &gt; Settings &gt; PluginsClick on Browse repositories…Search for Lombok PluginClick on Install pluginRestart IntelliJ IDEA Maven引入Lombok &lt;dependencies> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;version>1.18.4&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency> &lt;/dependencies> Java Decompiler 官网 下载 Lombok验证 通过Java Decompiler验证class文件 Lombok原理 Maven环境隔离 项目环境 本地开发环境(Local) 开发环境(Dev) 测试环境(Beta) 线上环境(Prod) 目录初始化 配置pom.xml build节点中的resources中增加resource节点 &lt;resources> &lt;resource> &lt;directory>src/main/resources.${deploy.type}&lt;/directory> &lt;excludes> &lt;exclude>*.jsp&lt;/exclude> &lt;/excludes> &lt;/resource> &lt;resource> &lt;directory>src/main/resources&lt;/directory> &lt;/resource> &lt;/resources> project节点中增加profiles节点 &lt;profiles> &lt;profile> &lt;id>dev&lt;/id> &lt;activation> &lt;activeByDefault>true&lt;/activeByDefault> &lt;/activation> &lt;properties> &lt;deploy.type>dev&lt;/deploy.type> &lt;/properties> &lt;/profile> &lt;profile> &lt;id>beta&lt;/id> &lt;properties> &lt;deploy.type>beta&lt;/deploy.type> &lt;/properties> &lt;/profile> &lt;profile> &lt;id>prod&lt;/id> &lt;properties> &lt;deploy.type>prod&lt;/deploy.type> &lt;/properties> &lt;/profile> &lt;/profiles> IDEA中设置默认环境 在IDEA右侧Maven Projects,选中本地开发环境对应的的环境，点击右下角出现import changes进行更新 这里设置的默认环境作用于IDEA中配置的Tomcat启动时发布部署的war包 编译打包命令 开发环境 手动打war包 mvn clean package -Dmaven.test.skip=true -Pdev 线上环境 mvn clean package -Dmaven.test.skip=true -Pprod 验证 Tomcat集群搭建 原理 通过Nginx负载均衡进行请求转发 单机部署多应用 单机部署多个Tomcat，第一个Tomcat不变,修改第二个Tomcat 配置环境变量 修改/etc/profile增加Tomcat环境变量 #tomcat export CATALINA_BASE=/opt/module/tomcat1 export CATALINA_HOME=/opt/module/tomcat1 export TOMCAT_HOME=/opt/module/tomcat1 export CATALINA_BASE_2=/opt/module/tomcat2 export CATALINA_HOME_2=/opt/module/tomcat2 export TOMCAT_HOME_2=/opt/module/tomcat2 #export PATH=$PATH:$CATALINA_HOME/bin source /etc/profile使配置文件立即生效 编辑catalina.sh 进入/opt/module/tomcat2/bin目录,编辑catalina.sh # OS specific support. $var _must_ be set to either true or false. export CATALINA_BASE=$CATALINA_BASE_2 export CATALINA_HOME=$CATALINA_HOME_2 编辑server.xml 进入/opt/module/tomcat2/conf目录，编辑server.xml，修改3个端口，为了方便，每个端口号加上1000 启动 启动Tomcat2 [root@192 bin]# pwd /opt/module/tomcat2/bin [root@192 bin]# ./startup.sh Using CATALINA_BASE: /opt/module/tomcat2 Using CATALINA_HOME: /opt/module/tomcat2 Using CATALINA_TMPDIR: /opt/module/tomcat2/temp Using JRE_HOME: /usr/java/jdk1.7.0_80 Using CLASSPATH: /opt/module/tomcat2/bin/bootstrap.jar:/opt/module/tomcat2/bin/tomcat-juli.jar Tomcat started. 启动Tomcat1 [root@192 bin]# pwd /opt/module/tomcat1/bin [root@192 bin]# ./startup.sh Using CATALINA_BASE: /opt/module/tomcat1 Using CATALINA_HOME: /opt/module/tomcat1 Using CATALINA_TMPDIR: /opt/module/tomcat1/temp Using JRE_HOME: /usr/java/jdk1.7.0_80 Using CLASSPATH: /opt/module/tomcat1/bin/bootstrap.jar:/opt/module/tomcat1/bin/tomcat-juli.jar Tomcat started. 多机部署多应用 多个服务器并且每个服务器只安装一个Tomcat，要保证它们之间的网络是互通的，方可集群，Nginx在任意一台服务器上即可，也可单独把Nginx服务独立出来一台。 Nginx负载均衡实现 负载均衡常用策略 轮询 默认优点：实现简单缺点：不考虑每台服务器处理能力 权重 优点：考虑了每台服务器处理能力的不同，weight默认是1 ip hash 优点：能实现同一个用户访问同一个服务器,可以不改变现有技术架构，直接实现横向拓展缺点：导致服务器请求(负载)不平均(完全依赖ip hash的结果)在ip变化的环境下无法服务 url hash(第三方) 优点：能实现同一个服务器访问同一个服务器缺点：根据url hash分配请求会不平均，请求频繁的url会请求到同一个服务器上的 fair(第三方) 缺点：按后端服务器的响应时间来分配请求，响应时间短的优先分配 负载均衡策略权重配置 编辑/usr/local/nginx/conf/nginx.conf文件，追加 ###########################vhost############################################## include vhost/*.conf; 在/usr/local/nginx/conf目录下，新建vhost文件夹 在/usr/local/nginx/conf/vhost目录下，编辑www.mytest.com.conf配置文件 [root@192 sbin]# cat ../conf/vhost/www.mytest.com.conf upstream 127.0.0.1{ server 127.0.0.1:8080 weight=1; server 127.0.0.1:9080 weight=2; } #Start www.mytest.com server { listen 80; server_name www.mytest.com; access_log /usr/local/nginx/logs/access.log combined; index index.html index.htm index.php; # send request back to apach location / { proxy_pass http://127.0.0.1; } } 验证 替换/opt/module/tomcat2/webapps/ROOT目录下tomcat.png 访问www.mytest.com,请求分流一下打到Tomcat1，一下打到Tomcat2，Nginx负载均衡策略权重Tomcat2配置weight=2，Tomcat1配置weight=1，所以访问到Tomcat2的概率是Tomcat1的2倍 坑 Session登录信息存储及读取的问题 轮询 登录的时候登录了A服务器，session信息存储到A服务器上了Nginx负载均衡策略使用轮询或者最小连接会导致，第一次访问A服务器，第二次可能访问到B服务器，这个时候存储在A服务器上的session信息在B服务器上读取不到。 ip hash Nginx负载均衡策略使用ip hash，那么登录信息还可以从A服务器上访问，但是这个有可能造成某些服务器压力过大，某些服务器又没有什么压力，这个时候压力过大的机器(包括网卡带宽)有可能成为瓶颈，并且请求不够分散。 服务器定时任务并发的问题 假设有定时关单的Job，单个Tomcat没有任何问题，但是在集群环境下，Spring Schedule定时执行的时候，会都一起执行，会导致数据错乱和资源浪费 Redis 简介 高性能的key-value数据库 内存数据库，支持数据持久化 安装 linux下载redis-2.8.0.tar.gzwindows 解压 [root@192 soft]# tar -zxvf redis-2.8.0.tar.gz -C /opt/module/ 服务端 启动 直接启动 默认是6379端口 [root@192 src]# pwd /opt/module/redis-2.8.0/src [root@192 src]# ./redis-server [6448] 26 Mar 18:30:37.044 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf [6448] 26 Mar 18:30:37.045 * Max number of open files set to 10032 _._ _.-``__ &#39;&#39;-._ _.-`` `. `_. &#39;&#39;-._ Redis 2.8.0 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &#39;&#39;-._ ( &#39; , .-` | `, ) Running in stand alone mode |`-._`-...-` __...-.``-._|&#39;` _.-&#39;| Port: 6379 | `-._ `._ / _.-&#39; | PID: 6448 `-._ `-._ `-./ _.-&#39; _.-&#39; |`-._`-._ `-.__.-&#39; _.-&#39;_.-&#39;| | `-._`-._ _.-&#39;_.-&#39; | http://redis.io `-._ `-._`-.__.-&#39;_.-&#39; _.-&#39; |`-._`-._ `-.__.-&#39; _.-&#39;_.-&#39;| | `-._`-._ _.-&#39;_.-&#39; | `-._ `-._`-.__.-&#39;_.-&#39; _.-&#39; `-._ `-.__.-&#39; _.-&#39; `-._ _.-&#39; `-.__.-&#39; [6448] 26 Mar 18:30:37.046 # Server started, Redis version 2.8.0 指定端口启动 [root@192 src]# ./redis-server --port 6380 [6457] 26 Mar 18:32:55.317 * Max number of open files set to 10032 _._ _.-``__ &#39;&#39;-._ _.-`` `. `_. &#39;&#39;-._ Redis 2.8.0 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &#39;&#39;-._ ( &#39; , .-` | `, ) Running in stand alone mode |`-._`-...-` __...-.``-._|&#39;` _.-&#39;| Port: 6380 | `-._ `._ / _.-&#39; | PID: 6457 `-._ `-._ `-./ _.-&#39; _.-&#39; |`-._`-._ `-.__.-&#39; _.-&#39;_.-&#39;| | `-._`-._ _.-&#39;_.-&#39; | http://redis.io `-._ `-._`-.__.-&#39;_.-&#39; _.-&#39; |`-._`-._ `-.__.-&#39; _.-&#39;_.-&#39;| | `-._`-._ _.-&#39;_.-&#39; | `-._ `-._`-.__.-&#39;_.-&#39; _.-&#39; `-._ `-.__.-&#39; _.-&#39; `-._ _.-&#39; `-.__.-&#39; [6457] 26 Mar 18:32:55.318 # Server started, Redis version 2.8.0 指定配置文件配置启动 配置文件修改端口,登录密码 [root@192 redis-2.8.0]# pwd /opt/module/redis-2.8.0 [root@192 redis-2.8.0]# vim redis.conf [root@192 src]# ./redis-server ../redis.conf [6468] 26 Mar 18:37:12.957 * Max number of open files set to 10032 _._ _.-``__ &#39;&#39;-._ _.-`` `. `_. &#39;&#39;-._ Redis 2.8.0 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &#39;&#39;-._ ( &#39; , .-` | `, ) Running in stand alone mode |`-._`-...-` __...-.``-._|&#39;` _.-&#39;| Port: 6380 | `-._ `._ / _.-&#39; | PID: 6468 `-._ `-._ `-./ _.-&#39; _.-&#39; |`-._`-._ `-.__.-&#39; _.-&#39;_.-&#39;| | `-._`-._ _.-&#39;_.-&#39; | http://redis.io `-._ `-._`-.__.-&#39;_.-&#39; _.-&#39; |`-._`-._ `-.__.-&#39; _.-&#39;_.-&#39;| | `-._`-._ _.-&#39;_.-&#39; | `-._ `-._`-.__.-&#39;_.-&#39; _.-&#39; `-._ `-.__.-&#39; _.-&#39; `-._ _.-&#39; `-.__.-&#39; [6468] 26 Mar 18:37:12.959 # Server started, Redis version 2.8.0 关闭 直接关闭 [root@192 src]# ./redis-cli shutdown 指定端口关闭 启动如果指定了端口，关闭必须指定端口 [root@192 src]# ./redis-cli -p 6379 shutdown 指定端口、ip地址、密码关闭 启动指定配置文件启动，配置文件修改了端口、密码，关闭的时候必须指定端口、密码 [root@192 src]# ./redis-cli -p 6380 shutdown (error) NOAUTH Authentication required. [root@192 src]# ./redis-cli -p 6380 -h 127.0.0.1 -a 000000 shutdown [root@192 src]# ps -ef | grep redis root 6526 6337 0 18:51 pts/6 00:00:00 grep redis [root@192 src]# 客户端 连接服务端 直接连接 服务端默认启动，客户端可以直接默认连接 [root@192 src]# ./redis-cli 127.0.0.1:6379&gt; keys * 1) &quot;b&quot; 2) &quot;hash&quot; 3) &quot;a2&quot; 4) &quot;a1&quot; 5) &quot;1&quot; 6) &quot;hash2&quot; 7) &quot;word&quot; 8) &quot;a&quot; 9) &quot;a3&quot; 127.0.0.1:6379&gt; quit 指定端口连接 服务端指定端口启动，客户端启连接必须指定端口 [root@192 src]# ./redis-cli -p 6379 指定端口、ip连接 [root@192 src]# ./redis-cli -p 6379 -h 127.0.0.1 指定端口、ip、密码连接 服务端指定配置文件启动，配置文件修改了端口、密码，客户端连接必须指定端口、密码 [root@192 src]# pwd /opt/module/redis-2.8.0/src [root@192 src]# ./redis-cli -p 6380 127.0.0.1:6380&gt; keys * (error) NOAUTH Authentication required. 127.0.0.1:6380&gt; quit [root@192 src]# ./redis-cli -p 6380 -h 127.0.0.1 -a 000000 127.0.0.1:6380&gt; keys * 1) &quot;1&quot; 2) &quot;a&quot; 3) &quot;a2&quot; 4) &quot;hash2&quot; 5) &quot;word&quot; 6) &quot;b&quot; 7) &quot;hash&quot; 8) &quot;a3&quot; 9) &quot;a1&quot; 127.0.0.1:6380&gt; 关闭 127.0.0.1:6379&gt; quit 数据结构 系统命令 查看键 127.0.0.1:6379&gt; keys * 查看基本信息 127.0.0.1:6379&gt; info 退出 127.0.0.1:6379&gt; exit 127.0.0.1:6379&gt; quit 切换库 默认使用0库 127.0.0.1:6379&gt; select 2 清除当前库数据 127.0.0.1:6379&gt; flushdb 清除所有库数据 127.0.0.1:6379&gt; flushall 查看键的数量 127.0.0.1:6379&gt; dbsize 查看键生命时间 -1代表永久有效 127.0.0.1:6379[1]&gt; keys * 1) &quot;a&quot; 2) &quot;b&quot; 127.0.0.1:6379[1]&gt; ttl a (integer) -1 查看类型 127.0.0.1:6379[1]&gt; type a string 日志监听 127.0.0.1:6379&gt; monitor OK String字符串 设置 设置单个 127.0.0.1:6379[1]&gt; set c c OK 设置指定生命时间(秒) 127.0.0.1:6379[1]&gt; setex d 10 d OK 127.0.0.1:6379[1]&gt; ttl d (integer) 7 127.0.0.1:6379[1]&gt; ttl d (integer) 6 设置指定生命时间(毫秒秒) 127.0.0.1:6379[1]&gt; psetex e 10000 e OK 127.0.0.1:6379[1]&gt; ttl e (integer) 8 127.0.0.1:6379[1]&gt; ttl e (integer) 6 127.0.0.1:6379[1]&gt; ttl e (integer) 5 重置单个 127.0.0.1:6379[1]&gt; get a &quot;a&quot; 127.0.0.1:6379[1]&gt; getset a aaa &quot;a&quot; 127.0.0.1:6379[1]&gt; get a &quot;aaa&quot; 设置多个 127.0.0.1:6379[1]&gt; mset a1 a1_value a2 a2_value a3 a3_value OK 127.0.0.1:6379[1]&gt; keys * 1) &quot;a&quot; 2) &quot;b&quot; 3) &quot;a1&quot; 4) &quot;a3&quot; 5) &quot;hello&quot; 6) &quot;a2&quot; 7) &quot;c&quot; 127.0.0.1:6379[1]&gt; 设置前判断键是否存在setnx 127.0.0.1:6379[1]&gt; keys * 1) &quot;a&quot; 2) &quot;b&quot; 3) &quot;a1&quot; 4) &quot;a3&quot; 5) &quot;hello&quot; 6) &quot;a2&quot; 7) &quot;c&quot; 127.0.0.1:6379[1]&gt; get a &quot;aaa&quot; 127.0.0.1:6379[1]&gt; setnx a a (integer) 0 127.0.0.1:6379[1]&gt; get a &quot;aaa&quot; 设置多个，判断键是否存在，只要一个失败就失败 127.0.0.1:6379[1]&gt; keys * (empty list or set) 127.0.0.1:6379[1]&gt; msetnx a a b b c c (integer) 1 127.0.0.1:6379[1]&gt; keys * 1) &quot;a&quot; 2) &quot;b&quot; 3) &quot;c&quot; 追加 127.0.0.1:6379[1]&gt; append a aaa (integer) 4 127.0.0.1:6379[1]&gt; get a &quot;aaaa&quot; 默认增长 只能是数字增长，默认步长是1 127.0.0.1:6379[1]&gt; set 1 1 OK 127.0.0.1:6379[1]&gt; incr 1 (integer) 2 127.0.0.1:6379[1]&gt; incr 1 (integer) 3 127.0.0.1:6379[1]&gt; get 1 &quot;3&quot; 指定步长增长 127.0.0.1:6379[1]&gt; get 1 &quot;3&quot; 127.0.0.1:6379[1]&gt; incrby 1 100 (integer) 103 127.0.0.1:6379[1]&gt; incrby 1 100 (integer) 203 127.0.0.1:6379[1]&gt; get 1 &quot;203&quot; 默认减值 127.0.0.1:6379[1]&gt; get 1 &quot;203&quot; 127.0.0.1:6379[1]&gt; decr 1 (integer) 202 127.0.0.1:6379[1]&gt; decr 1 (integer) 201 127.0.0.1:6379[1]&gt; decr 1 (integer) 200 127.0.0.1:6379[1]&gt; get 1 &quot;200&quot; 指定步长减值 127.0.0.1:6379[1]&gt; get 1 &quot;200&quot; 127.0.0.1:6379[1]&gt; decrby 1 20 (integer) 180 127.0.0.1:6379[1]&gt; decrby 1 20 (integer) 160 127.0.0.1:6379[1]&gt; decrby 1 20 (integer) 140 127.0.0.1:6379[1]&gt; get 1 &quot;140&quot; 获取 获取单个 127.0.0.1:6379[1]&gt; get a &quot;a&quot; 127.0.0.1:6379[1]&gt; get b &quot;b&quot; 截取 127.0.0.1:6379[1]&gt; set hello hello OK 127.0.0.1:6379[1]&gt; getrange hello 0 2 &quot;hel&quot; 获取多个 127.0.0.1:6379[1]&gt; mget a1 a2 a3 1) &quot;a1_value&quot; 2) &quot;a2_value&quot; 3) &quot;a3_value&quot; 127.0.0.1:6379[1]&gt; 长度 127.0.0.1:6379[1]&gt; get hello &quot;hello&quot; 127.0.0.1:6379[1]&gt; strlen hello (integer) 5 哈希hash 设置 设置单个 127.0.0.1:6379[1]&gt; hset hash username shenlibing (integer) 1 设置多个 127.0.0.1:6379[1]&gt; hmset hash address haikou phone 15501892660 OK 127.0.0.1:6379[1]&gt; hgetall hash 1) &quot;username&quot; 2) &quot;shenlibing&quot; 3) &quot;age&quot; 4) &quot;18&quot; 5) &quot;address&quot; 6) &quot;haikou&quot; 7) &quot;phone&quot; 8) &quot;15501892660&quot; 127.0.0.1:6379[1]&gt; hkeys hash 1) &quot;username&quot; 2) &quot;age&quot; 3) &quot;address&quot; 4) &quot;phone&quot; 删除多个 127.0.0.1:6379[1]&gt; hkeys hash 1) &quot;username&quot; 2) &quot;age&quot; 3) &quot;address&quot; 4) &quot;phone&quot; 127.0.0.1:6379[1]&gt; hdel hash address phone (integer) 2 127.0.0.1:6379[1]&gt; hkeys hash 1) &quot;username&quot; 2) &quot;age&quot; 设置单个前判断键是否存在 127.0.0.1:6379[1]&gt; hsetnx hash username xiaobingbing (integer) 0 127.0.0.1:6379[1]&gt; hget hash username &quot;shenlibing&quot; 获取 获取单个 127.0.0.1:6379[1]&gt; hget hash username &quot;shenlibing&quot; 判断键是否存在 127.0.0.1:6379[1]&gt; hexists hash username (integer) 1 获取整个 127.0.0.1:6379[1]&gt; hgetall hash 1) &quot;username&quot; 2) &quot;shenlibing&quot; 3) &quot;age&quot; 4) &quot;18&quot; 获取键 127.0.0.1:6379[1]&gt; hkeys hash 1) &quot;username&quot; 2) &quot;age&quot; 获取值 127.0.0.1:6379[1]&gt; hvals hash 1) &quot;shenlibing&quot; 2) &quot;18&quot; 获取长度 127.0.0.1:6379[1]&gt; hlen hash (integer) 2 获取多个 127.0.0.1:6379[1]&gt; hmget hash username age 1) &quot;shenlibing&quot; 2) &quot;18&quot; 列表list 设置 从左往右进 127.0.0.1:6379&gt; lpush list 1 2 3 4 5 6 7 8 9 10 (integer) 10 重置 根据索引重置某个元素 127.0.0.1:6379&gt; lset list 0 100 OK 向左弹出 127.0.0.1:6379&gt; lpop list &quot;100&quot; 向右弹出 127.0.0.1:6379&gt; rpop list &quot;1&quot; 获取 获取多个 根据索引截取list元素，获取多个元素 127.0.0.1:6379&gt; lrange list 0 2 1) &quot;10&quot; 2) &quot;9&quot; 3) &quot;8&quot; 获取单个 根据索引查找list中某个元素，获取单个元素 127.0.0.1:6379&gt; lindex list 0 &quot;100&quot; 长度 127.0.0.1:6379&gt; llen list (integer) 10 获取所有 127.0.0.1:6379&gt; llen list (integer) 8 127.0.0.1:6379&gt; lrange list 0 7 1) &quot;9&quot; 2) &quot;8&quot; 3) &quot;7&quot; 4) &quot;6&quot; 5) &quot;5&quot; 6) &quot;4&quot; 7) &quot;3&quot; 8) &quot;2&quot; 集合set 无序，不允许重复 设置 设置多个 127.0.0.1:6379&gt; sadd set a b c d (integer) 4 重命名 127.0.0.1:6379&gt; rename set set1 OK 删除指定元素,一个或者多个 127.0.0.1:6379&gt; srem set1 a b (integer) 2 127.0.0.1:6379&gt; srem set1 c (integer) 1 随机删除一个元素 127.0.0.1:6379&gt; spop set2 &quot;f&quot; 获取 长度 127.0.0.1:6379&gt; scard set1 (integer) 4 获取所有 127.0.0.1:6379&gt; smembers set2 1) &quot;d&quot; 2) &quot;e&quot; 3) &quot;c&quot; 4) &quot;f&quot; 差集 127.0.0.1:6379&gt; smembers set1 1) &quot;d&quot; 2) &quot;b&quot; 3) &quot;c&quot; 4) &quot;a&quot; 127.0.0.1:6379&gt; smembers set2 1) &quot;d&quot; 2) &quot;e&quot; 3) &quot;c&quot; 4) &quot;f&quot; 127.0.0.1:6379&gt; sdiff set1 set2 1) &quot;b&quot; 2) &quot;a&quot; 127.0.0.1:6379&gt; sdiff set2 set1 1) &quot;e&quot; 2) &quot;f&quot; 交集 127.0.0.1:6379&gt; sinter set1 set2 1) &quot;c&quot; 2) &quot;d&quot; 并集 127.0.0.1:6379&gt; sunion set1 set2 1) &quot;c&quot; 2) &quot;e&quot; 3) &quot;f&quot; 4) &quot;a&quot; 5) &quot;b&quot; 6) &quot;d&quot; 是否存在某个元素 127.0.0.1:6379&gt; sismember set1 a (integer) 1 有序集合sortedset 设置 根据分数设置 127.0.0.1:6379&gt; zadd sortedset1 100 a 200 b 300 c (integer) 3 重命名 127.0.0.1:6379&gt; rename sortedset1 sortedset OK 加分数 127.0.0.1:6379&gt; zincrby sortedset 1000 a &quot;1100&quot; 127.0.0.1:6379&gt; zrank sortedset a (integer) 2 获取 长度 127.0.0.1:6379&gt; zcard sortedset (integer) 3 获取分数 获取元素的分数 127.0.0.1:6379&gt; zscore sortedset a &quot;100&quot; 根据分数范围返回成员个数 127.0.0.1:6379&gt; zcount sortedset 0 200 (integer) 2 127.0.0.1:6379&gt; zcount sortedset 0 300 (integer) 3 获取元素索引 127.0.0.1:6379&gt; zrank sortedset a (integer) 0 127.0.0.1:6379&gt; zrank sortedset b (integer) 1 根据索引区间返回元素 可以带分数显示 127.0.0.1:6379&gt; zcard sortedset (integer) 3 127.0.0.1:6379&gt; zrange sortedset 0 2 1) &quot;b&quot; 2) &quot;c&quot; 3) &quot;a&quot; 127.0.0.1:6379&gt; zrange sortedset 0 2 withscores 1) &quot;b&quot; 2) &quot;200&quot; 3) &quot;c&quot; 4) &quot;300&quot; 5) &quot;a&quot; 6) &quot;1100&quot; Redis_Desktop_Manager工具 下载 下载2 Quick Start 原生单点登录 原生Redis+Cookie+Jackson+Filter解决session共享问题实现单点登录 java使用Jedis客户端 编辑pom.xml &lt;dependency> &lt;groupId>redis.clients&lt;/groupId> &lt;artifactId>jedis&lt;/artifactId> &lt;version>2.6.0&lt;/version> &lt;/dependency> 获取连接 从连接池获取连接 package com.mmall.common; import com.mmall.util.PropertiesUtil; import redis.clients.jedis.Jedis; import redis.clients.jedis.JedisPool; import redis.clients.jedis.JedisPoolConfig; /** * Created by geely */ public class RedisPool { //jedis连接池 private static JedisPool pool; //最大连接数 private static Integer maxTotal = Integer.parseInt(PropertiesUtil.getProperty("redis.max.total", "20")); //在jedispool中最大的idle状态(空闲的)的jedis实例的个数 private static Integer maxIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.max.idle", "20")); //在jedispool中最小的idle状态(空闲的)的jedis实例的个数 private static Integer minIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.min.idle", "20")); //在borrow一个jedis实例的时候，是否要进行验证操作，如果赋值true。则得到的jedis实例肯定是可以用的。 private static Boolean testOnBorrow = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.borrow", "true")); //在return一个jedis实例的时候，是否要进行验证操作，如果赋值true。则放回jedispool的jedis实例肯定是可以用的。 private static Boolean testOnReturn = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.return", "true")); private static String redisIp = PropertiesUtil.getProperty("redis.ip"); private static Integer redisPort = Integer.parseInt(PropertiesUtil.getProperty("redis.port")); private static void initPool() { JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(maxTotal); config.setMaxIdle(maxIdle); config.setMinIdle(minIdle); config.setTestOnBorrow(testOnBorrow); config.setTestOnReturn(testOnReturn); //连接耗尽的时候，是否阻塞，false会抛出异常，true阻塞直到超时。默认为true。 config.setBlockWhenExhausted(true); pool = new JedisPool(config, redisIp, redisPort, 1000 * 2); } static { initPool(); } public static Jedis getJedis() { return pool.getResource(); } public static void returnBrokenResource(Jedis jedis) { pool.returnBrokenResource(jedis); } public static void returnResource(Jedis jedis) { pool.returnResource(jedis); } public static void main(String[] args) { Jedis jedis = pool.getResource(); jedis.set("geelykey", "geelyvalue"); returnResource(jedis); //临时调用，销毁连接池中的所有连接 pool.destroy(); System.out.println("program is end"); } } Jedis API封装 读写数据 package com.mmall.util; import com.mmall.common.RedisPool; import lombok.extern.slf4j.Slf4j; import redis.clients.jedis.Jedis; /** * Created by geely */ @Slf4j public class RedisPoolUtil { /** * 设置key的有效期，单位是秒 * @param key * @param exTime * @return */ public static Long expire(String key,int exTime){ Jedis jedis = null; Long result = null; try { jedis = RedisPool.getJedis(); result = jedis.expire(key,exTime); } catch (Exception e) { log.error("expire key:{} error",key,e); RedisPool.returnBrokenResource(jedis); return result; } RedisPool.returnResource(jedis); return result; } //exTime的单位是秒 public static String setEx(String key,String value,int exTime){ Jedis jedis = null; String result = null; try { jedis = RedisPool.getJedis(); result = jedis.setex(key,exTime,value); } catch (Exception e) { log.error("setex key:{} value:{} error",key,value,e); RedisPool.returnBrokenResource(jedis); return result; } RedisPool.returnResource(jedis); return result; } public static String set(String key,String value){ Jedis jedis = null; String result = null; try { jedis = RedisPool.getJedis(); result = jedis.set(key,value); } catch (Exception e) { log.error("set key:{} value:{} error",key,value,e); RedisPool.returnBrokenResource(jedis); return result; } RedisPool.returnResource(jedis); return result; } public static String get(String key){ Jedis jedis = null; String result = null; try { jedis = RedisPool.getJedis(); result = jedis.get(key); } catch (Exception e) { log.error("get key:{} error",key,e); RedisPool.returnBrokenResource(jedis); return result; } RedisPool.returnResource(jedis); return result; } public static Long del(String key){ Jedis jedis = null; Long result = null; try { jedis = RedisPool.getJedis(); result = jedis.del(key); } catch (Exception e) { log.error("del key:{} error",key,e); RedisPool.returnBrokenResource(jedis); return result; } RedisPool.returnResource(jedis); return result; } public static void main(String[] args) { Jedis jedis = RedisPool.getJedis(); RedisPoolUtil.set("keyTest","value"); String value = RedisPoolUtil.get("keyTest"); RedisPoolUtil.setEx("keyex","valueex",60*10); RedisPoolUtil.expire("keyTest",60*20); RedisPoolUtil.del("keyTest"); String aaa = RedisPoolUtil.get(null); System.out.println(aaa); System.out.println("end"); } } Jackson封装JacksonUtil 编辑pom.xml &lt;dependency> &lt;groupId>org.codehaus.jackson&lt;/groupId> &lt;artifactId>jackson-mapper-asl&lt;/artifactId> &lt;version>1.9.12&lt;/version> &lt;/dependency> 多泛型序列化和反序列化 package com.mmall.util; import com.google.common.collect.Lists; import com.mmall.pojo.Category; import com.mmall.pojo.TestPojo; import com.mmall.pojo.User; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang.StringUtils; import org.codehaus.jackson.map.DeserializationConfig; import org.codehaus.jackson.map.ObjectMapper; import org.codehaus.jackson.map.SerializationConfig; import org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion; import org.codehaus.jackson.type.JavaType; import org.codehaus.jackson.type.TypeReference; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; /** * Created by geely */ @Slf4j public class JsonUtil { private static ObjectMapper objectMapper = new ObjectMapper(); static{ //对象的所有字段全部列入 objectMapper.setSerializationInclusion(Inclusion.ALWAYS); //取消默认转换timestamps形式 objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS,false); //忽略空Bean转json的错误 objectMapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS,false); //所有的日期格式都统一为以下的样式，即yyyy-MM-dd HH:mm:ss objectMapper.setDateFormat(new SimpleDateFormat(DateTimeUtil.STANDARD_FORMAT)); //忽略 在json字符串中存在，但是在java对象中不存在对应属性的情况。防止错误 objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES,false); } public static &lt;T> String obj2String(T obj){ if(obj == null){ return null; } try { return obj instanceof String ? (String)obj : objectMapper.writeValueAsString(obj); } catch (Exception e) { log.warn("Parse Object to String error",e); return null; } } public static &lt;T> String obj2StringPretty(T obj){ if(obj == null){ return null; } try { return obj instanceof String ? (String)obj : objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); } catch (Exception e) { log.warn("Parse Object to String error",e); return null; } } public static &lt;T> T string2Obj(String str,Class&lt;T> clazz){ if(StringUtils.isEmpty(str) || clazz == null){ return null; } try { return clazz.equals(String.class)? (T)str : objectMapper.readValue(str,clazz); } catch (Exception e) { log.warn("Parse String to Object error",e); return null; } } public static &lt;T> T string2Obj(String str, TypeReference&lt;T> typeReference){ if(StringUtils.isEmpty(str) || typeReference == null){ return null; } try { return (T)(typeReference.getType().equals(String.class)? str : objectMapper.readValue(str,typeReference)); } catch (Exception e) { log.warn("Parse String to Object error",e); return null; } } public static &lt;T> T string2Obj(String str,Class&lt;?> collectionClass,Class&lt;?>... elementClasses){ JavaType javaType = objectMapper.getTypeFactory().constructParametricType(collectionClass,elementClasses); try { return objectMapper.readValue(str,javaType); } catch (Exception e) { log.warn("Parse String to Object error",e); return null; } } public static void main(String[] args) { TestPojo testPojo = new TestPojo(); testPojo.setName("Geely"); testPojo.setId(666); //{"name":"Geely","id":666} String json = "{\"name\":\"Geely\",\"color\":\"blue\",\"id\":666}"; TestPojo testPojoObject = JsonUtil.string2Obj(json,TestPojo.class); // String testPojoJson = JsonUtil.obj2String(testPojo); // log.info("testPojoJson:{}",testPojoJson); log.info("end"); // User user = new User(); // user.setId(2); // user.setEmail("geely@happymmall.com"); // user.setCreateTime(new Date()); // String userJsonPretty = JsonUtil.obj2StringPretty(user); // log.info("userJson:{}",userJsonPretty); // User u2 = new User(); // u2.setId(2); // u2.setEmail("geelyu2@happymmall.com"); // // // // String user1Json = JsonUtil.obj2String(u1); // // String user1JsonPretty = JsonUtil.obj2StringPretty(u1); // // log.info("user1Json:{}",user1Json); // // log.info("user1JsonPretty:{}",user1JsonPretty); // // // User user = JsonUtil.string2Obj(user1Json,User.class); // // // List&lt;User> userList = Lists.newArrayList(); // userList.add(u1); // userList.add(u2); // // String userListStr = JsonUtil.obj2StringPretty(userList); // // log.info("=================="); // // log.info(userListStr); // // // List&lt;User> userListObj1 = JsonUtil.string2Obj(userListStr, new TypeReference&lt;List&lt;User>>() { // }); // // // List&lt;User> userListObj2 = JsonUtil.string2Obj(userListStr,List.class,User.class); System.out.println("end"); } } Cookie封装 其中COOKIE_NAME和COOKIE_DOMAIN是根据实际项目，线上的域名来配置的，如果扩展开来讲，对于里面每个属性，在二级/三级域名下的读写问题是必须要细化的 Cookie的读、写、删 package com.mmall.util; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang.StringUtils; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * Created by geely */ @Slf4j public class CookieUtil { private final static String COOKIE_DOMAIN = ".happymmall.com"; private final static String COOKIE_NAME = "mmall_login_token"; public static String readLoginToken(HttpServletRequest request){ Cookie[] cks = request.getCookies(); if(cks != null){ for(Cookie ck : cks){ log.info("read cookieName:{},cookieValue:{}",ck.getName(),ck.getValue()); if(StringUtils.equals(ck.getName(),COOKIE_NAME)){ log.info("return cookieName:{},cookieValue:{}",ck.getName(),ck.getValue()); return ck.getValue(); } } } return null; } //X:domain=".happymmall.com" //a:A.happymmall.com cookie:domain=A.happymmall.com;path="/" //b:B.happymmall.com cookie:domain=B.happymmall.com;path="/" //c:A.happymmall.com/test/cc cookie:domain=A.happymmall.com;path="/test/cc" //d:A.happymmall.com/test/dd cookie:domain=A.happymmall.com;path="/test/dd" //e:A.happymmall.com/test cookie:domain=A.happymmall.com;path="/test" public static void writeLoginToken(HttpServletResponse response,String token){ Cookie ck = new Cookie(COOKIE_NAME,token); ck.setDomain(COOKIE_DOMAIN); ck.setPath("/");//代表设置在根目录 ck.setHttpOnly(true); //单位是秒。 //如果这个maxage不设置的话，cookie就不会写入硬盘，而是写在内存。只在当前页面有效。 ck.setMaxAge(60 * 60 * 24 * 365);//如果是-1，代表永久 log.info("write cookieName:{},cookieValue:{}",ck.getName(),ck.getValue()); response.addCookie(ck); } public static void delLoginToken(HttpServletRequest request,HttpServletResponse response){ Cookie[] cks = request.getCookies(); if(cks != null){ for(Cookie ck : cks){ if(StringUtils.equals(ck.getName(),COOKIE_NAME)){ ck.setDomain(COOKIE_DOMAIN); ck.setPath("/"); ck.setMaxAge(0);//设置成0，代表删除此cookie。 log.info("del cookieName:{},cookieValue:{}",ck.getName(),ck.getValue()); response.addCookie(ck); return; } } } } } SessionExpireFilter构建Session时间重置过滤器 编辑web.xml &lt;filter> &lt;filter-name>sessionExpireFilter&lt;/filter-name> &lt;filter-class>com.mmall.controller.common.SessionExpireFilter&lt;/filter-class> &lt;/filter> &lt;filter-mapping> &lt;filter-name>sessionExpireFilter&lt;/filter-name> &lt;url-pattern>*.do&lt;/url-pattern> &lt;/filter-mapping> 时间重置过滤器类 SessionExpireFilter.java package com.mmall.controller.common; import com.mmall.common.Const; import com.mmall.pojo.User; import com.mmall.util.CookieUtil; import com.mmall.util.JsonUtil; import com.mmall.util.RedisShardedPoolUtil; import org.apache.commons.lang.StringUtils; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletRequest; import java.io.IOException; /** * Created by geely */ public class SessionExpireFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest; String loginToken = CookieUtil.readLoginToken(httpServletRequest); if(StringUtils.isNotEmpty(loginToken)){ //判断logintoken是否为空或者""； //如果不为空的话，符合条件，继续拿user信息 String userJsonStr = RedisShardedPoolUtil.get(loginToken); User user = JsonUtil.string2Obj(userJsonStr,User.class); if(user != null){ //如果user不为空，则重置session的时间，即调用expire命令 RedisShardedPoolUtil.expire(loginToken, Const.RedisCacheExtime.REDIS_SESSION_EXTIME); } } filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } } Guava Cache迁移Redis分布式缓存 描述：修改密码时需要验证token，token的生成是在校验忘记密码的问题答案是正确的时候生成，如果答案是正确的话，返回给前台。重置密码发起请求携带该token到后台校验是否一致。 集群后Guava Cache的不足 Tomcat之前使用的guava cache存储token，它只存在于tomcat实例上，tomcat及tomcat之间并不共享，所以必须迁移。否则负载均衡就TomcatA存储了guava cache，TomcatB想拿就拿不到了 Guava Cache迁移Redis缓存 修改前 guava cache存储token public ServerResponse&lt;String> checkAnswer(String username,String question,String answer){ int resultCount = userMapper.checkAnswer(username,question,answer); if(resultCount>0){ //说明问题及问题答案是这个用户的,并且是正确的 String forgetToken = UUID.randomUUID().toString(); TokenCache.setKey(TokenCache.TOKEN_PREFIX+username,forgetToken); return ServerResponse.createBySuccess(forgetToken); } return ServerResponse.createByErrorMessage("问题的答案错误"); } public ServerResponse&lt;String> forgetResetPassword(String username,String passwordNew,String forgetToken){ if(org.apache.commons.lang3.StringUtils.isBlank(forgetToken)){ return ServerResponse.createByErrorMessage("参数错误,token需要传递"); } ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess()){ //用户不存在 return ServerResponse.createByErrorMessage("用户不存在"); } String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX+username); if(org.apache.commons.lang3.StringUtils.isBlank(token)){ return ServerResponse.createByErrorMessage("token无效或者过期"); } if(org.apache.commons.lang3.StringUtils.equals(forgetToken,token)){ String md5Password = MD5Util.MD5EncodeUtf8(passwordNew); int rowCount = userMapper.updatePasswordByUsername(username,md5Password); if(rowCount > 0){ return ServerResponse.createBySuccessMessage("修改密码成功"); } }else{ return ServerResponse.createByErrorMessage("token错误,请重新获取重置密码的token"); } return ServerResponse.createByErrorMessage("修改密码失败"); } 修改后 后台token保存在Redis上 public ServerResponse&lt;String> checkAnswer(String username,String question,String answer){ int resultCount = userMapper.checkAnswer(username,question,answer); if(resultCount>0){ //说明问题及问题答案是这个用户的,并且是正确的 String forgetToken = UUID.randomUUID().toString(); RedisShardedPoolUtil.setEx(Const.TOKEN_PREFIX+username,forgetToken,60*60*12); return ServerResponse.createBySuccess(forgetToken); } return ServerResponse.createByErrorMessage("问题的答案错误"); } public ServerResponse&lt;String> forgetResetPassword(String username,String passwordNew,String forgetToken){ if(org.apache.commons.lang3.StringUtils.isBlank(forgetToken)){ return ServerResponse.createByErrorMessage("参数错误,token需要传递"); } ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess()){ //用户不存在 return ServerResponse.createByErrorMessage("用户不存在"); } String token = RedisShardedPoolUtil.get(Const.TOKEN_PREFIX+username); if(org.apache.commons.lang3.StringUtils.isBlank(token)){ return ServerResponse.createByErrorMessage("token无效或者过期"); } if(org.apache.commons.lang3.StringUtils.equals(forgetToken,token)){ String md5Password = MD5Util.MD5EncodeUtf8(passwordNew); int rowCount = userMapper.updatePasswordByUsername(username,md5Password); if(rowCount > 0){ return ServerResponse.createBySuccessMessage("修改密码成功"); } }else{ return ServerResponse.createByErrorMessage("token错误,请重新获取重置密码的token"); } return ServerResponse.createByErrorMessage("修改密码失败"); } Redis分布式环境搭建 第一个Redis不变，修改第二个Redis 编辑redis.conf 启动 第一个默认启动,默认端口6379 [root@192 src]# ./redis-server &amp; 第二个指定配置文件启动，修改后的端口6380 [root@192 src]# ./redis-server ../redis.conf &amp; java代码连接Redis分布式缓存 一致性算法 获取连接 package com.mmall.common; import com.mmall.util.PropertiesUtil; import redis.clients.jedis.JedisPoolConfig; import redis.clients.jedis.JedisShardInfo; import redis.clients.jedis.ShardedJedis; import redis.clients.jedis.ShardedJedisPool; import redis.clients.util.Hashing; import redis.clients.util.Sharded; import java.util.ArrayList; import java.util.List; /** * Created by geely */ public class RedisShardedPool { private static ShardedJedisPool pool;//sharded jedis连接池 private static Integer maxTotal = Integer.parseInt(PropertiesUtil.getProperty("redis.max.total","20")); //最大连接数 private static Integer maxIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.max.idle","20"));//在jedispool中最大的idle状态(空闲的)的jedis实例的个数 private static Integer minIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.min.idle","20"));//在jedispool中最小的idle状态(空闲的)的jedis实例的个数 private static Boolean testOnBorrow = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.borrow","true"));//在borrow一个jedis实例的时候，是否要进行验证操作，如果赋值true。则得到的jedis实例肯定是可以用的。 private static Boolean testOnReturn = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.return","true"));//在return一个jedis实例的时候，是否要进行验证操作，如果赋值true。则放回jedispool的jedis实例肯定是可以用的。 private static String redis1Ip = PropertiesUtil.getProperty("redis1.ip"); private static Integer redis1Port = Integer.parseInt(PropertiesUtil.getProperty("redis1.port")); private static String redis2Ip = PropertiesUtil.getProperty("redis2.ip"); private static Integer redis2Port = Integer.parseInt(PropertiesUtil.getProperty("redis2.port")); private static void initPool(){ JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(maxTotal); config.setMaxIdle(maxIdle); config.setMinIdle(minIdle); config.setTestOnBorrow(testOnBorrow); config.setTestOnReturn(testOnReturn); //连接耗尽的时候，是否阻塞，false会抛出异常，true阻塞直到超时。默认为true。 config.setBlockWhenExhausted(true); JedisShardInfo info1 = new JedisShardInfo(redis1Ip,redis1Port,1000*2); JedisShardInfo info2 = new JedisShardInfo(redis2Ip,redis2Port,1000*2); List&lt;JedisShardInfo> jedisShardInfoList = new ArrayList&lt;JedisShardInfo>(2); jedisShardInfoList.add(info1); jedisShardInfoList.add(info2); pool = new ShardedJedisPool(config,jedisShardInfoList, Hashing.MURMUR_HASH, Sharded.DEFAULT_KEY_TAG_PATTERN); } static{ initPool(); } public static ShardedJedis getJedis(){ return pool.getResource(); } public static void returnBrokenResource(ShardedJedis jedis){ pool.returnBrokenResource(jedis); } public static void returnResource(ShardedJedis jedis){ pool.returnResource(jedis); } public static void main(String[] args) { ShardedJedis jedis = pool.getResource(); for(int i =0;i&lt;10;i++){ jedis.set("key"+i,"value"+i); } returnResource(jedis); // pool.destroy();//临时调用，销毁连接池中的所有连接 System.out.println("program is end"); } } 读写数据 package com.mmall.util; import com.mmall.common.RedisShardedPool; import lombok.extern.slf4j.Slf4j; import redis.clients.jedis.ShardedJedis; /** * Created by geely */ @Slf4j public class RedisShardedPoolUtil { /** * 设置key的有效期，单位是秒 * @param key * @param exTime * @return */ public static Long expire(String key,int exTime){ ShardedJedis jedis = null; Long result = null; try { jedis = RedisShardedPool.getJedis(); result = jedis.expire(key,exTime); } catch (Exception e) { log.error("expire key:{} error",key,e); RedisShardedPool.returnBrokenResource(jedis); return result; } RedisShardedPool.returnResource(jedis); return result; } //exTime的单位是秒 public static String setEx(String key,String value,int exTime){ ShardedJedis jedis = null; String result = null; try { jedis = RedisShardedPool.getJedis(); result = jedis.setex(key,exTime,value); } catch (Exception e) { log.error("setex key:{} value:{} error",key,value,e); RedisShardedPool.returnBrokenResource(jedis); return result; } RedisShardedPool.returnResource(jedis); return result; } public static String set(String key,String value){ ShardedJedis jedis = null; String result = null; try { jedis = RedisShardedPool.getJedis(); result = jedis.set(key,value); } catch (Exception e) { log.error("set key:{} value:{} error",key,value,e); RedisShardedPool.returnBrokenResource(jedis); return result; } RedisShardedPool.returnResource(jedis); return result; } public static String getSet(String key,String value){ ShardedJedis jedis = null; String result = null; try { jedis = RedisShardedPool.getJedis(); result = jedis.getSet(key,value); } catch (Exception e) { log.error("getset key:{} value:{} error",key,value,e); RedisShardedPool.returnBrokenResource(jedis); return result; } RedisShardedPool.returnResource(jedis); return result; } public static String get(String key){ ShardedJedis jedis = null; String result = null; try { jedis = RedisShardedPool.getJedis(); result = jedis.get(key); } catch (Exception e) { log.error("get key:{} error",key,e); RedisShardedPool.returnBrokenResource(jedis); return result; } RedisShardedPool.returnResource(jedis); return result; } public static Long del(String key){ ShardedJedis jedis = null; Long result = null; try { jedis = RedisShardedPool.getJedis(); result = jedis.del(key); } catch (Exception e) { log.error("del key:{} error",key,e); RedisShardedPool.returnBrokenResource(jedis); return result; } RedisShardedPool.returnResource(jedis); return result; } public static Long setnx(String key,String value){ ShardedJedis jedis = null; Long result = null; try { jedis = RedisShardedPool.getJedis(); result = jedis.setnx(key,value); } catch (Exception e) { log.error("setnx key:{} value:{} error",key,value,e); RedisShardedPool.returnBrokenResource(jedis); return result; } RedisShardedPool.returnResource(jedis); return result; } public static void main(String[] args) { ShardedJedis jedis = RedisShardedPool.getJedis(); RedisPoolUtil.set("keyTest","value"); String value = RedisPoolUtil.get("keyTest"); RedisPoolUtil.setEx("keyex","valueex",60*10); RedisPoolUtil.expire("keyTest",60*20); RedisPoolUtil.del("keyTest"); String aaa = RedisPoolUtil.get(null); System.out.println(aaa); System.out.println("end"); } } Spring Session单点登录 参考 官网 官方文档 GitHub地址 Quick Start 引入依赖 &lt;!-- spring session 单点登录 --> &lt;dependency> &lt;groupId>org.springframework.session&lt;/groupId> &lt;artifactId>spring-session-data-redis&lt;/artifactId> &lt;version>1.2.0.RELEASE&lt;/version> &lt;/dependency> Spring Session整合Redis applicationContext.xml引入整合配置文件 &lt;import resource="applicationContext-spring-session.xml"/> 新建applicationContext-spring-session.xml资源文件 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"> &lt;bean id="redisHttpSessionConfiguration" class="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"> &lt;property name="maxInactiveIntervalInSeconds" value="1800" /> &lt;/bean> &lt;bean id="defaultCookieSerializer" class="org.springframework.session.web.http.DefaultCookieSerializer"> &lt;property name="domainName" value="localhost" /> &lt;property name="useHttpOnlyCookie" value="true" /> &lt;property name="cookiePath" value="/" /> &lt;property name="cookieMaxAge" value="31536000" /> &lt;/bean> &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"> &lt;property name="maxTotal" value="20"/> &lt;/bean> &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"> &lt;property name="hostName" value="192.168.1.104" /> &lt;property name="port" value="6379" /> &lt;property name="poolConfig" ref="jedisPoolConfig" /> &lt;/bean> &lt;/beans> 配置web.xml &lt;filter> &lt;filter-name>springSessionRepositoryFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class> &lt;/filter> &lt;filter-mapping> &lt;filter-name>springSessionRepositoryFilter&lt;/filter-name> &lt;url-pattern>*.do&lt;/url-pattern> &lt;/filter-mapping> 使用 这里的session是经过包装过的代理类 session.setAttribute(Const.CURRENT_USER,response.getData()); session.removeAttribute(Const.CURRENT_USER); User user = (User)session.getAttribute(Const.CURRENT_USER); 坑 Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [org.springframework.session.SessionRepository] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {} 描述： 启动报错 解决：修改&lt;org.springframework.version&gt;4.0.0.RELEASE&lt;/org.springframework.version&gt;为 &lt;org.springframework.version&gt;4.0.3.RELEASE&lt;/org.springframework.version&gt; No bean named ‘springSessionRepositoryFilter’ is defined 描述：启动报错，容器找不到该bean &lt;filter> &lt;filter-name>springSessionRepositoryFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class> &lt;/filter> &lt;filter-mapping> &lt;filter-name>springSessionRepositoryFilter&lt;/filter-name> &lt;url-pattern>*.do&lt;/url-pattern> &lt;/filter-mapping> 解决： spring配置文件没有引入spring-session整合配置文件 &lt;import resource="applicationContext-spring-session.xml"/> SpringMVC全局异常控制 Spring及SpringMVC包扫描隔离 Spring扫描 排除controller扫描注解 &lt;context:component-scan base-package="com.mmall" annotation-config="true"> &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /> &lt;/context:component-scan> SpringMVC扫描 &lt;!--springmvc扫描包指定到controller，防止重复扫描 use-default-filters="false" 关闭默认扫描 --> &lt;context:component-scan base-package="com.mmall.controller" annotation-config="true" use-default-filters="false"> &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/> &lt;/context:component-scan> @Component注解 异常包装类ExceptionResolver.java,必须要加上@Component注解，使其成为容器中的bean，@Component类似于@Controller、@Service、@Repository dao层用@Repositoryservice层用@Servicecontroller层用@Controller其它的用@Component package com.mmall.common; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import org.springframework.stereotype.Repository; import org.springframework.stereotype.Service; import org.springframework.web.servlet.HandlerExceptionResolver; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.view.json.MappingJacksonJsonView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * Created by geely */ @Slf4j @Component public class ExceptionResolver implements HandlerExceptionResolver{ @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) { log.error("{} Exception",httpServletRequest.getRequestURI(),e); ModelAndView modelAndView = new ModelAndView(new MappingJacksonJsonView()); //当使用是jackson2.x的时候使用MappingJackson2JsonView，本项目使用的是1.9。 modelAndView.addObject("status",ResponseCode.ERROR.getCode()); modelAndView.addObject("msg","接口异常,详情请查看服务端日志的异常信息"); modelAndView.addObject("data",e.toString()); return modelAndView; } } SpringMVC拦截器 springmvc配置拦截器 &lt;mvc:mapping path=&quot;/manage/**&quot;/&gt;代表请求经过/manage目录下的子目录下的controller也会被拦截 &lt;mvc:mapping path=&quot;/manage/*&quot;/&gt;代表请求经过/manage目录下的controller会被拦截，而子目录下的controller不会被拦截 &lt;mvc:exclude-mapping path=&quot;/manage/user/login.do&quot;/&gt;配置不拦截某些请求 &lt;mvc:interceptors> &lt;!-- 定义在这里的，所有的都会拦截--> &lt;mvc:interceptor> &lt;!--manage/a.do /manage/*--> &lt;!--manage/b.do /manage/*--> &lt;!--manage/product/save.do /manage/**--> &lt;!--manage/order/detail.do /manage/**--> &lt;mvc:mapping path="/manage/**"/> &lt;!--&lt;mvc:exclude-mapping path="/manage/user/login.do"/>--> &lt;bean class="com.mmall.controller.common.interceptor.AuthorityInterceptor" /> &lt;/mvc:interceptor> &lt;/mvc:interceptors> 定义拦截器处理类 preHandle请求到达controll之前会调用该方法 postHandle请求到达controller处理后会调用该方法 afterCompletion请求到达controller处理后返回ModelAndView后会调用该方法 package com.mmall.controller.common.interceptor; import com.google.common.collect.Maps; import com.mmall.common.Const; import com.mmall.common.ServerResponse; import com.mmall.pojo.User; import com.mmall.util.CookieUtil; import com.mmall.util.JsonUtil; import com.mmall.util.RedisShardedPoolUtil; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang.StringUtils; import org.springframework.web.method.HandlerMethod; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.PrintWriter; import java.util.Arrays; import java.util.Iterator; import java.util.Map; /** * Created by geely */ @Slf4j public class AuthorityInterceptor implements HandlerInterceptor{ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info("preHandle"); //请求中Controller中的方法名 HandlerMethod handlerMethod = (HandlerMethod)handler; //解析HandlerMethod String methodName = handlerMethod.getMethod().getName(); String className = handlerMethod.getBean().getClass().getSimpleName(); //解析参数,具体的参数key以及value是什么，我们打印日志 StringBuffer requestParamBuffer = new StringBuffer(); Map paramMap = request.getParameterMap(); Iterator it = paramMap.entrySet().iterator(); while (it.hasNext()){ Map.Entry entry = (Map.Entry)it.next(); String mapKey = (String)entry.getKey(); String mapValue = StringUtils.EMPTY; //request这个参数的map，里面的value返回的是一个String[] Object obj = entry.getValue(); if(obj instanceof String[]){ String[] strs = (String[])obj; mapValue = Arrays.toString(strs); } requestParamBuffer.append(mapKey).append("=").append(mapValue); } if(StringUtils.equals(className,"UserManageController") &amp;&amp; StringUtils.equals(methodName,"login")){ log.info("权限拦截器拦截到请求,className:{},methodName:{}",className,methodName); //如果是拦截到登录请求，不打印参数，因为参数里面有密码，全部会打印到日志中，防止日志泄露 return true; } log.info("权限拦截器拦截到请求,className:{},methodName:{},param:{}",className,methodName,requestParamBuffer.toString()); User user = null; String loginToken = CookieUtil.readLoginToken(request); if(StringUtils.isNotEmpty(loginToken)){ String userJsonStr = RedisShardedPoolUtil.get(loginToken); user = JsonUtil.string2Obj(userJsonStr,User.class); } if(user == null || (user.getRole().intValue() != Const.Role.ROLE_ADMIN)){ //返回false.即不会调用controller里的方法 response.reset();//geelynote 这里要添加reset，否则报异常 getWriter() has already been called for this response. response.setCharacterEncoding("UTF-8");//geelynote 这里要设置编码，否则会乱码 response.setContentType("application/json;charset=UTF-8");//geelynote 这里要设置返回值的类型，因为全部是json接口。 PrintWriter out = response.getWriter(); //上传由于富文本的控件要求，要特殊处理返回值，这里面区分是否登录以及是否有权限 if(user == null){ if(StringUtils.equals(className,"ProductManageController") &amp;&amp; StringUtils.equals(methodName,"richtextImgUpload")){ Map resultMap = Maps.newHashMap(); resultMap.put("success",false); resultMap.put("msg","请登录管理员"); out.print(JsonUtil.obj2String(resultMap)); }else{ out.print(JsonUtil.obj2String(ServerResponse.createByErrorMessage("拦截器拦截,用户未登录"))); } }else{ if(StringUtils.equals(className,"ProductManageController") &amp;&amp; StringUtils.equals(methodName,"richtextImgUpload")){ Map resultMap = Maps.newHashMap(); resultMap.put("success",false); resultMap.put("msg","无权限操作"); out.print(JsonUtil.obj2String(resultMap)); }else{ out.print(JsonUtil.obj2String(ServerResponse.createByErrorMessage("拦截器拦截,用户无权限操作"))); } } out.flush(); out.close();//geelynote 这里要关闭 return false; } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.info("postHandle"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { log.info("afterCompletion"); } } 登录死循环 描述：springmvc配置拦截器，如果登录请求也拦截的话，会导致一直登录不上，陷入死循环当中 解决：方式一：可以在配置拦截器的时候过滤掉登录请求&lt;mvc:exclude-mapping path=&quot;/manage/user/login.do&quot;/&gt; 方式二：拦截器处理类的preHandle方法会在到达controller调用该方法,因此可以在该方法中过滤掉登录请求不拦截 if(StringUtils.equals(className,"UserManageController") &amp;&amp; StringUtils.equals(methodName,"login")){ log.info("权限拦截器拦截到请求,className:{},methodName:{}",className,methodName); //如果是拦截到登录请求，不打印参数，因为参数里面有密码，全部会打印到日志中，防止日志泄露 return true; } 重置响应对象 描述：拦截器处理类的三个方法都是返回布尔值，而controller都是返回json数据，请求如果被拦截到没有到达controller，那么在拦截器处理类的preHandle方法中必须重置响应对象 解决： if(user == null || (user.getRole().intValue() != Const.Role.ROLE_ADMIN)){ //返回false.即不会调用controller里的方法 response.reset();//geelynote 这里要添加reset，否则报异常 getWriter() has already been called for this response. response.setCharacterEncoding("UTF-8");//geelynote 这里要设置编码，否则会乱码 response.setContentType("application/json;charset=UTF-8");//geelynote 这里要设置返回值的类型，因为全部是json接口。 PrintWriter out = response.getWriter(); //上传由于富文本的控件要求，要特殊处理返回值，这里面区分是否登录以及是否有权限 if(user == null){ if(StringUtils.equals(className,"ProductManageController") &amp;&amp; StringUtils.equals(methodName,"richtextImgUpload")){ Map resultMap = Maps.newHashMap(); resultMap.put("success",false); resultMap.put("msg","请登录管理员"); out.print(JsonUtil.obj2String(resultMap)); }else{ out.print(JsonUtil.obj2String(ServerResponse.createByErrorMessage("拦截器拦截,用户未登录"))); } }else{ if(StringUtils.equals(className,"ProductManageController") &amp;&amp; StringUtils.equals(methodName,"richtextImgUpload")){ Map resultMap = Maps.newHashMap(); resultMap.put("success",false); resultMap.put("msg","无权限操作"); out.print(JsonUtil.obj2String(resultMap)); }else{ out.print(JsonUtil.obj2String(ServerResponse.createByErrorMessage("拦截器拦截,用户无权限操作"))); } } out.flush(); out.close();//geelynote 这里要关闭 return false; } SpringMVC RESTful改造 编辑web.xml 修改前 &lt;servlet> &lt;servlet-name>dispatcher&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcher&lt;/servlet-name> &lt;url-pattern>*.do&lt;/url-pattern> &lt;/servlet-mapping> 修改后 &lt;servlet> &lt;servlet-name>dispatcher&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcher&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> controller使用RESTful风格 根据id查询产品 修改前 @RequestMapping("detail.do") @ResponseBody public ServerResponse&lt;ProductDetailVo> detail(Integer productId){ return iProductService.getProductDetail(productId); } 修改后 @RequestMapping(value = "/{productId}", method = RequestMethod.GET) @ResponseBody public ServerResponse&lt;ProductDetailVo> detailRESTful(@PathVariable Integer productId){ return iProductService.getProductDetail(productId); } 搜索产品 keyword、categoryId不为空 修改前 @RequestMapping("list.do") @ResponseBody public ServerResponse&lt;PageInfo> list(@RequestParam(value = "keyword",required = false)String keyword, @RequestParam(value = "categoryId",required = false)Integer categoryId, @RequestParam(value = "pageNum",defaultValue = "1") int pageNum, @RequestParam(value = "pageSize",defaultValue = "10") int pageSize, @RequestParam(value = "orderBy",defaultValue = "") String orderBy){ return iProductService.getProductByKeywordCategory(keyword,categoryId,pageNum,pageSize,orderBy); } 修改后 //http://www.happymmall.com/product/手机/100012/1/10/price_asc @RequestMapping(value = "/{keyword}/{categoryId}/{pageNum}/{pageSize}/{orderBy}",method = RequestMethod.GET) @ResponseBody public ServerResponse&lt;PageInfo> listRESTful(@PathVariable(value = "keyword")String keyword, @PathVariable(value = "categoryId")Integer categoryId, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy){ if(pageNum == null){ pageNum = 1; } if(pageSize == null){ pageSize = 10; } if(StringUtils.isBlank(orderBy)){ orderBy = "price_asc"; } return iProductService.getProductByKeywordCategory(keyword,categoryId,pageNum,pageSize,orderBy); } keyword、categoryId有一个为空 修改后版本一 keyword为空 // http://www.happymmall.com/product/100012/1/10/price_asc @RequestMapping(value = "/{categoryId}/{pageNum}/{pageSize}/{orderBy}",method = RequestMethod.GET) @ResponseBody public ServerResponse&lt;PageInfo> listRESTfulBadcase(@PathVariable(value = "categoryId")Integer categoryId, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy){ if(pageNum == null){ pageNum = 1; } if(pageSize == null){ pageSize = 10; } if(StringUtils.isBlank(orderBy)){ orderBy = "price_asc"; } return iProductService.getProductByKeywordCategory("",categoryId,pageNum,pageSize,orderBy); } categoryId为空 @RequestMapping(value = "/{keyword}/{pageNum}/{pageSize}/{orderBy}",method = RequestMethod.GET) @ResponseBody public ServerResponse&lt;PageInfo> listRESTfulBadcase(@PathVariable(value = "keyword")String keyword, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy){ if(pageNum == null){ pageNum = 1; } if(pageSize == null){ pageSize = 10; } if(StringUtils.isBlank(orderBy)){ orderBy = "price_asc"; } return iProductService.getProductByKeywordCategory(keyword,null,pageNum,pageSize,orderBy); } 浏览器请求http://localhost:8088/mmall_war_exploded/product/100012/1/10/price_asc 发生了歧义，不知道要走哪一个方法，所以报错了 修改后版本二 categoryId为空 //http://www.happymmall.com/product/keyword/手机/1/10/price_asc @RequestMapping(value = "/keyword/{keyword}/{pageNum}/{pageSize}/{orderBy}",method = RequestMethod.GET) @ResponseBody public ServerResponse&lt;PageInfo> listRESTful(@PathVariable(value = "keyword")String keyword, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy){ if(pageNum == null){ pageNum = 1; } if(pageSize == null){ pageSize = 10; } if(StringUtils.isBlank(orderBy)){ orderBy = "price_asc"; } return iProductService.getProductByKeywordCategory(keyword,null,pageNum,pageSize,orderBy); } keyword为空 //http://www.happymmall.com/product/category/100012/1/10/price_asc @RequestMapping(value = "/category/{categoryId}/{pageNum}/{pageSize}/{orderBy}",method = RequestMethod.GET) @ResponseBody public ServerResponse&lt;PageInfo> listRESTful(@PathVariable(value = "categoryId")Integer categoryId, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy){ if(pageNum == null){ pageNum = 1; } if(pageSize == null){ pageSize = 10; } if(StringUtils.isBlank(orderBy)){ orderBy = "price_asc"; } return iProductService.getProductByKeywordCategory("",categoryId,pageNum,pageSize,orderBy); } 浏览器访问http://localhost:8088/mmall_war_exploded/product/keyword/手机/1/10/price_asc和http://localhost:8088/mmall_war_exploded/product/category/100002/1/10/price_asc 这样子就可以避免歧义 Spring Schedul定时任务 Cron生成器 在线Cron表达式生成器 定时任务配置 注解方式配置定时任务 编辑spring配置文件 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation="http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd" &lt;task:annotation-driven/> &lt;/beans> 创建定时任务类 package com.mmall.task; import com.mmall.service.IOrderService; import com.mmall.util.PropertiesUtil; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; /** * Created by geely */ @Component @Slf4j public class CloseOrderTask { @Autowired private IOrderService iOrderService; //每隔5秒执行一次 @Scheduled(cron="*/5 * * * * ?") public void closeOrderTaskV1(){ log.info("关闭订单定时任务启动"); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2")); // iOrderService.closeOrder(hour); log.info("关闭订单定时任务结束"); } } MySQL行锁、表锁 行锁 明确的主键 明确指定主键id，并且有结果集,产生行锁 SELECT * FROM mmall_product WHERE id = '26' FOR UPDATE; 明确指定主键id，并且无结果集,无锁 SELECT * FROM mmall_product WHERE id = '66' FOR UPDATE; 表锁 无明确的主键 无主键,产生表锁 SELECT * FROM mmall_product WHERE NAME = 'Apple iPhone 7 Plus (A1661) 128G 玫瑰金色 移动联通电信4G手机' FOR UPDATE; 主键不明确产生表锁 SELECT * FROM mmall_product WHERE id &lt;> '66' FOR UPDATE; SELECT * FROM mmall_product WHERE id LIKE '66' FOR UPDATE; 使用 关单:查询订单的时候，订单包含了子订单，根据子订单号查询产品 &lt;select id="selectStockByProductId" resultType="int" parameterType="java.lang.Integer"> select stock from mmall_product where id = #{id} for update &lt;/select> xml转义 用&amp;lt![CDATA[]]&amp;gt包裹住有转义的字符即可 &lt;select id="selectOrderStatusByCreateTime" resultMap="BaseResultMap" parameterType="map"> SELECT &lt;include refid="Base_Column_List"/> from mmall_order where status = #{status} &amp;lt![CDATA[ and create_time &lt;= #{date} ]]&amp;gt order by create_time desc &lt;/select> 原生分布式锁 Spring Schedule+Redis分布式锁构建分布式任务调度 简单版 获取到锁，锁住时间5秒，如果此期间发生中断，会导致死锁 // @Scheduled(cron="0 */1 * * * ?") public void closeOrderTaskV2(){ log.info("关闭订单定时任务启动"); long lockTimeout = Long.parseLong(PropertiesUtil.getProperty("lock.timeout","5000")); Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+lockTimeout)); if(setnxResult != null &amp;&amp; setnxResult.intValue() == 1){ //如果返回值是1，代表设置成功，获取锁 closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); }else{ log.info("没有获得分布式锁:{}",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); } log.info("关闭订单定时任务结束"); } private void closeOrder(String lockName){ //有效期50秒，防止死锁 RedisShardedPoolUtil.expire(lockName,5); log.info("获取{},ThreadName:{}",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2")); iOrderService.closeOrder(hour); RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); log.info("释放{},ThreadName:{}",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); log.info("==============================="); } 安全版 双重防死锁 未获取到锁，继续判断，判断时间戳，看是否可以重置并获取到锁 @Scheduled(cron="0 */1 * * * ?") public void closeOrderTaskV3(){ log.info("关闭订单定时任务启动"); long lockTimeout = Long.parseLong(PropertiesUtil.getProperty("lock.timeout","5000")); Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+lockTimeout)); if(setnxResult != null &amp;&amp; setnxResult.intValue() == 1){ closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); }else{ //未获取到锁，继续判断，判断时间戳，看是否可以重置并获取到锁 String lockValueStr = RedisShardedPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); if(lockValueStr != null &amp;&amp; System.currentTimeMillis() > Long.parseLong(lockValueStr)){ String getSetResult = RedisShardedPoolUtil.getSet(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+lockTimeout)); //再次用当前时间戳getset。 //返回给定的key的旧值，->旧值判断，是否可以获取锁 //当key没有旧值时，即key不存在时，返回nil ->获取锁 //这里我们set了一个新的value值，获取旧的值。 if(getSetResult == null || (getSetResult != null &amp;&amp; StringUtils.equals(lockValueStr,getSetResult))){ //真正获取到锁 closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); }else{ log.info("没有获取到分布式锁:{}",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); } }else{ log.info("没有获取到分布式锁:{}",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); } } log.info("关闭订单定时任务结束"); } private void closeOrder(String lockName){ //有效期50秒，防止死锁 RedisShardedPoolUtil.expire(lockName,5); log.info("获取{},ThreadName:{}",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2")); iOrderService.closeOrder(hour); RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); log.info("释放{},ThreadName:{}",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); log.info("==============================="); } Redisson分布式锁 编辑pom.xml &lt;dependency> &lt;groupId>org.redisson&lt;/groupId> &lt;artifactId>redisson&lt;/artifactId> &lt;version>2.9.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.fasterxml.jackson.dataformat&lt;/groupId> &lt;artifactId>jackson-dataformat-avro&lt;/artifactId> &lt;version>2.9.0&lt;/version> &lt;/dependency> 使用Redisson分布式锁 // @Scheduled(cron="0 */1 * * * ?") public void closeOrderTaskV4(){ RLock lock = redissonManager.getRedisson().getLock(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); boolean getLock = false; try { if(getLock = lock.tryLock(0,50, TimeUnit.SECONDS)){ log.info("Redisson获取到分布式锁:{},ThreadName:{}",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2")); // iOrderService.closeOrder(hour); }else{ log.info("Redisson没有获取到分布式锁:{},ThreadName:{}",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); } } catch (InterruptedException e) { log.error("Redisson分布式锁获取异常",e); } finally { if(!getLock){ return; } lock.unlock(); log.info("Redisson分布式锁释放锁"); } }]]></content>
      <categories>
        <category>集群</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Redis</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS]]></title>
    <url>%2F2019%2F03%2F20%2Fnodejs%2F</url>
    <content type="text"><![CDATA[NodeJS入门 NodeJS模块 http模块 server.js const http=require('http'); let server=http.createServer((req, res)=>{ switch(req.url){ case '/aaa': res.write('abc'); break; case '/bbb': res.write('dddd'); break; case '/1.html': res.write('&lt;html>&lt;head>&lt;/head>&lt;body>sdfasfasf&lt;/body>&lt;/html>'); break; } res.end(); }); server.listen(8080); server2.js const http=require('http'); const fs=require('fs'); let server=http.createServer((req, res)=>{ fs.readFile(`www${req.url}`, (err, data)=>{ if(err){ res.write('404'); //? }else{ res.write(data); } res.end(); }); }); server.listen(8080); 断言——assert const assert=require('assert'); function sum(a, b){ assert(arguments.length==2, '必须传2个参数'); assert(typeof a=='number', '第一个参数必须是数字'); assert(typeof b=='number', '第二个参数必须是数字'); return a+b; } console.log(sum(12, 5)); File System 读写文件 fs.js const fs=require('fs'); fs.readFile('1.txt', (err, data)=>{ if(err){ console.log('有错'); }else{ //'ads'.charCodeAt(0) console.log(data.toString()); } }); /*fs.writeFile('3.txt', 'erqwreqwere', err=>{ if(err){ console.log(err); }else{ console.log('成功'); } });*/ fs2.js const fs=require('fs'); fs.readFile('ofo.png', (err, data)=>{ fs.writeFile('ofo2.png', data, (err)=>{ if(err){ console.log(err); }else{ console.log('成功'); } }); }); 多进程 进程和线程的区别： 进程拥有独立的执行空间、存储同一个进程内的所有线程共享一套空间、代码 多进程(PHP、Node) 成本高(慢)；安全(进程间隔离)；进程间通信麻烦；写代码简单多线程(Java、C) 成本低(快)；不安全(线程要死一块死)；线程间通信容易；写代码复杂 进程间通信的几种方式管道共享内存socket Crypto——签名 MD5是单向散列生成hash值，不可逆破解 md5.js const crypto=require('crypto'); let obj=crypto.createHash('md5'); obj.update('123456'); // obj.update('123'); // obj.update('4'); // obj.update('56'); console.log(obj.digest('hex')); 双重加密 md5_2.js const crypto=require('crypto'); function md5(str){ let obj=crypto.createHash('md5'); obj.update(str); return obj.digest('hex'); } console.log(md5(md5('123456')+'se32ssdfsd43')); OS 获取系统信息 const os=require('os'); console.log(os.cpus()); Path const path=require('path'); let str='/var/local/www/aaa/1.png'; //dirname //basename //extname console.log(path.extname(str)); Events事件队列 和普通js函数的定义调用区别：解耦 const Event=require('events').EventEmitter; let ev=new Event(); //1.监听(接收) ev.on('msg', function (a, b, c){ console.log('收到了msg事件：', a, b, c); }); //2.派发(发送) ev.emit('msg', 12, 5, 88); /*function msg(a, b, c){ console.log('收到了msg事件：', a, b, c); } msg(12, 5, 88);*/ Query Strings、URL 地址解析 querystring.js const querystring=require('querystring'); let obj=querystring.parse('ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=aa&amp;rsv_pq=f80d982000063ffb&amp;rsv_t=6498LAZdRZjq9v4v0hs88kZItnCjDpT6UNBKr%2FF83%2F%2Bg4eiPURW2eQl9Iwc&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug2=0&amp;inputT=10&amp;rsv_sug4=10'); console.log(obj); url.js const url=require('url'); let obj=url.parse('https://www.baidu.com:8080/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=aa&amp;rsv_pq=f80d982000063ffb&amp;rsv_t=6498LAZdRZjq9v4v0hs88kZItnCjDpT6UNBKr%2FF83%2F%2Bg4eiPURW2eQl9Iwc&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug2=0&amp;inputT=10&amp;rsv_sug4=10',true); console.log(obj); 域名解析 DNS、Domain const dns=require('dns'); dns.resolve('www.goole.com', (err, res)=>{ if(err){ console.log('解析失败'); }else{ console.log(res); } }); 流操作——Stream 连续数据都是流——视频流、网络流、文件流、语音流 TLS/SSL 加密、安全 ZLIB——gz 压缩 NodeJS数据交互 设置响应头 get请求 数据放在url地址上，存放的数量小(32k) post请求 在body里面,存放的数据量大(1G),一个大数据包切成一堆小包传输,容错性强 安全性 一切来自前台的数据都不可信前后台都得进行数据校验 前台校验：提高用户体验 后台校验：提高安全性 数据库 关系型数据库——MySQL、Oracle 特点 最常见、最常用,数据之间是有关系的MySQL使用占比80%，免费，绝大多数普通应用，性能很高、安全性很高，容灾略差Oracle收费，应用在金融、医疗，容灾特别强 SQL 增 INSERT INTO 表 (字段列表) VALUES(值列表) INSERT INTO user_table (ID, name, gender, chinese, math, english) VALUES(0, 'blue', '男', 35, 18, 29); 删 DELETE FROM 表 WHERE 条件 DELETE FROM user_table WHERE ID=3; 改 UPDATE 表 SET 字段=值, 字段2=值2, … WHERE 条件 UPDATE user_table SET chinese=100 WHERE ID=2; 查 SELECT 字段列表 FROM 表 WHERE 条件 SELECT name, gender FROM user_table WHERE ID=2; 文件型数据库——sqlite 使用简单、存储数据量小 文档型数据库——MongoDB 直接存储异构数据，使用方便 NoSQL 没有复杂的关系、对性能有极高的要求常见的有redis、memcached、hypertable、bigtable NodeJS进阶上 文件数据解析 表单的三种POST text/plain,用的很少，纯文字application/x-www-form-urlencoded,默认,以url编码方式,xxx=xxx&amp;xxx=xx...multipart/form-data上传文件内容 file上传，是post请求方式 普通纯文本表单文件上传 普通纯文本文件上传可以用字符串拼接接收，有弊端，如果是图片文件上传，用字符串接收会出现数据错乱 描述：可以看到纯文本文件上传请求了2个资源 浏览器 后台结果输出 包含了前台表单用户名、密码和纯文本文件的描述和内容 /upload ------WebKitFormBoundaryNIoabcKEXajTUMAI Content-Disposition: form-data; name=&quot;user&quot; shenlibing ------WebKitFormBoundaryNIoabcKEXajTUMAI Content-Disposition: form-data; name=&quot;pass&quot; 000000 ------WebKitFormBoundaryNIoabcKEXajTUMAI Content-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;1.txt&quot; Content-Type: text/plain abc ------WebKitFormBoundaryNIoabcKEXajTUMAI-- /favicon.ico Buffer接收文件上传的原始二进制数据 /upload &lt;Buffer 2d 2d 2d 2d 2d 2d 57 65 62 4b 69 74 46 6f 72 6d 42 6f 75 6e 64 61 72 79 75 42 6d 6b 78 4a 65 51 6d 35 6b 4a 4f 68 59 65 0d 0a 43 6f 6e 74 65 6e 74 2d ... &gt; /favicon.ico &lt;Buffer &gt; Buffer数据进行查找、截取、切分 如果是非纯文本文件上传，用字符串接收会破坏数据的完整性，需要用Buffer接收二进制数据 Buffer数据查找 let b=new Buffer('abccc-=-dddder-=-qwerqwer'); console.log(b.indexOf('-=-')); Buffer数据截取 let b=new Buffer('abccc-=-dddder-=-qwerqwer'); console.log(b.slice(17).toString()); Buffer数据切分 Buffer本身不具有split方法 let b=new Buffer('abccc-=-dddder-=-qwerqwer'); Buffer.prototype.split=Buffer.prototype.split||function (b){ let arr=[]; let cur=0; let n=0; while((n=this.indexOf(b, cur))!=-1){ arr.push(this.slice(cur, n)); cur=n+b.length; } arr.push(this.slice(cur)); return arr; }; let arr=b.split('-=-'); console.log(arr); console.log(arr.map(buffer=>buffer.toString())); 解析数据 数据化简 先对纯文本文件上传用字符串拼接的结果进行分析化简版本一 分隔符 Content-Disposition: form-data; name=&quot;user&quot; shenlibing 分隔符 Content-Disposition: form-data; name=&quot;pass&quot; 000000 分隔符 Content-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;1.txt&quot; Content-Type: text/plain abc 分隔符-- 化简版本二：每一行末尾会自动加上\r\n 分隔符\r\n Content-Disposition: form-data; name=&quot;user&quot;\r\n \r\n shenlibing\r\n 分隔符\r\n Content-Disposition: form-data; name=&quot;pass&quot;\r\n \r\n 000000\r\n 分隔符\r\n Content-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;1.txt&quot;\r\n Content-Type: text/plain\r\n \r\n abc\r\n 分隔符--\r\n 化简版本三 分隔符\r\n数据描述\r\n\r\n数据值\r\n 分隔符\r\n数据描述\r\n\r\n数据值\r\n 分隔符\r\n数据描述1\r\n数据描述2\r\n\r\n文件内容\r\n 分隔符--\r\n 化简到版本三的时候，就可以开始解析数据了 用分隔符切开数据 [ 空, \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述1\r\n数据描述2\r\n\r\n&lt;文件内容&gt;\r\n, --\r\n ] 丢弃头尾元素 [ \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述1\r\n数据描述2\r\n\r\n&lt;文件内容&gt;\r\n, ] 丢弃每一项的头尾\r\n [ 数据描述\r\n\r\n数据值, 数据描述\r\n\r\n数据值, 数据描述1\r\n数据描述2\r\n\r\n&lt;文件内容&gt;, ] 用第一次出现的\r\n\r\n切分 普通数据：[数据描述, 数据值] 文件数据：[数据描述1\r\n数据描述2, &lt;文件内容&gt;] 判断描述的里面有没有\r\n 有的话就是文件数据：[数据描述1\r\n数据描述2, &lt;文件内容&gt;]没有的话就是普通数据：[数据描述, 数据值] 分析数据描述 文件上传代码实现 const http=require('http'); const common=require('./libs/common'); const fs=require('fs'); const uuid=require('uuid/v4'); let server=http.createServer((req, res)=>{ let arr=[]; req.on('data', data=>{ arr.push(data); }); req.on('end', ()=>{ let data=Buffer.concat(arr); //data //解析二进制文件上传数据 let post={}; let files={}; if(req.headers['content-type']){ let str=req.headers['content-type'].split('; ')[1]; if(str){ let boundary='--'+str.split('=')[1]; //1.用"分隔符切分整个数据" let arr=data.split(boundary); //2.丢弃头尾两个数据 arr.shift(); arr.pop(); //3.丢弃掉每个数据头尾的"\r\n" arr=arr.map(buffer=>buffer.slice(2,buffer.length-2)); //4.每个数据在第一个"\r\n\r\n"处切成两半 arr.forEach(buffer=>{ let n=buffer.indexOf('\r\n\r\n'); let disposition=buffer.slice(0, n); let content=buffer.slice(n+4); disposition=disposition.toString(); if(disposition.indexOf('\r\n')==-1){ //普通数据 //Content-Disposition: form-data; name="user" content=content.toString(); let name=disposition.split('; ')[1].split('=')[1]; name=name.substring(1, name.length-1); post[name]=content; }else{ //文件数据 /*Content-Disposition: form-data; name="f1"; filename="a.txt"\r\n Content-Type: text/plain*/ let [line1, line2]=disposition.split('\r\n'); let [,name,filename]=line1.split('; '); let type=line2.split(': ')[1]; name=name.split('=')[1]; name=name.substring(1,name.length-1); filename=filename.split('=')[1]; filename=filename.substring(1,filename.length-1); let path=`upload/${uuid().replace(/\-/g, '')}`; fs.writeFile(path, content, err=>{ if(err){ console.log('文件写入失败', err); }else{ files[name]={filename, path, type}; console.log(files); } }); } }); //5.完成 console.log(post); } } res.end(); }); }); server.listen(8080); 流操作 fs.readFile和fs.writeFile的弊端 描述：以上文件上传的一个瑕疵就是会等到所有数据都到达了才开始处理，然后通过fs.writeFile上传文件 http.createServer((req, res)=>{ fs.readFile(`www${req.url}`, (err, data)=>{ res.write(data); }); }); fs.readFile先把所有数据全读到内存中，然后回调,这种方式极其占用内存且资源利用极其不充分，读取文件的过程中网络传输一直空闲，等到文件IO读取完毕，IO一直空闲，网络传输变得繁忙 解决：收到一部分就解析一部分，极大节约内存,使用流读取文件，读一点、发一点 分类 读取流fs.createReadStream写入流fs.createWriteStream const http=require('http'); const fs=require('fs'); let server=http.createServer((req, res)=>{ let rs=fs.createReadStream(`www${req.url}`); rs.pipe(res); rs.on('error', err=>{ res.writeHeader(404); res.write('Not Found'); res.end(); }); }); server.listen(8080); gz压缩 无gz压缩传输 没有通过gz压缩传输,请求资源1.html文件大小321B，jquery.js文件大小262KB const http=require('http'); const fs=require('fs'); const zlib=require('zlib'); let server=http.createServer((req, res)=>{ let rs=fs.createReadStream(`www${req.url}`); rs.pipe(res); /*res.setHeader('content-encoding', 'gzip'); let gz=zlib.createGzip(); rs.pipe(gz).pipe(res);*/ rs.on('error', err=>{ res.writeHeader(404); res.write('Not Found'); res.end(); }); }); server.listen(8080); gz压缩传输 读写流,通过gz压缩传输,请求资源1.html文件大小292B，jquery.js文件大小77.8KB 创建读取流读取www${req.url}文件，通过gz压缩、加密该文件然后返回给浏览器，需要设置响应头res.setHeader(&#39;content-encoding&#39;, &#39;gzip&#39;),让浏览器识别该资源是通过gz压缩的文件 const http=require('http'); const fs=require('fs'); const zlib=require('zlib'); let server=http.createServer((req, res)=>{ let rs=fs.createReadStream(`www${req.url}`); //rs.pipe(res); res.setHeader('content-encoding', 'gzip'); let gz=zlib.createGzip(); rs.pipe(gz).pipe(res); rs.on('error', err=>{ res.writeHeader(404); res.write('Not Found'); res.end(); }); }); server.listen(8080); NodeJS进阶下 缓存 标记文件修改时间实现缓存 获得文件修改时间 const fs=require('fs'); fs.stat('./www/1.html', (err, stat)=>{ if(err){ console.log('获取文件信息失败'); }else{ console.log(stat.mtime.toGMTString()); } }); 服务器设置响应头Last-Modified 标记文件最后一次修改时间 缓存实现过程 const http=require('http'); const fs=require('fs'); const url=require('url'); http.createServer((req, res)=>{ let {pathname}=url.parse(req.url); //获取文件日期 fs.stat(`www${pathname}`, (err, stat)=>{ if(err){ res.writeHeader(404); res.write('Not Found'); res.end(); }else{ // console.log(req) if(req.headers['if-modified-since']){ let oDate=new Date(req.headers['if-modified-since']); let time_client=Math.floor(oDate.getTime()/1000); let time_server=Math.floor(stat.mtime.getTime()/1000); if(time_server>time_client){ //服务器的文件时间>客户端手里的版本 sendFileToClient(); }else{ res.writeHeader(304); res.write('Not Modified'); res.end(); } }else{ sendFileToClient(); } function sendFileToClient(){ //发送 let rs=fs.createReadStream(`www${pathname}`); res.setHeader('Last-Modified', stat.mtime.toGMTString()); //输出 rs.pipe(res); rs.on('error', err=>{ res.writeHeader(404); res.write('Not Found'); res.end(); }); } } }); }).listen(8080); 第一次请求,响应状态码200,浏览器没有缓存 服务器响应头带了Last-Modified标记该资源文件最后一次修改时间 第二次请求,响应状态码304，浏览器有缓存 请求头带了if-modified-since标记该资源文件的最后一次修改时间,通过该标记去告诉服务器我本地有这个文件及这个文件最后一次修改时间，服务器收到请求通过if-modified-since标记的时间和服务器上该文件的时间进行比较，如果服务器的文件等于if-modified-since的时间，说明该资源文件没有被修改过，浏览器决定从不从缓存中取出 缓存策略 服务器设置响应头cache-control和expires 多进程 主进程负责派生子进程，子进程负责干活 特点 普通程序不能“创建”进程，只有系统进程才能创建进程；只有主进程能分裂进程是分裂出来分裂出来的两个进程执行的是同一套代码父子进程之间可以共享”句柄”(如：8080端口) 进程分裂实现 通过cluster.isMaster判断是否是主进程，如果是主进程则cluster.fork()分裂子进程 const http=require('http'); const cluster=require('cluster'); const os=require('os'); const process=require('process'); if(cluster.isMaster){ for(let i=0;i&lt;os.cpus().length;i++){ cluster.fork(); } console.log('主进程'); }else{ console.log('子进程'); let server=http.createServer((req, res)=>{ //进程id console.log('子进程id',process.pid); res.write('aaaa'); res.end(); }); server.listen(8080); console.log('服务器开好了，在8080上'); } 主进程 子进程 服务器开好了，在8080上 子进程 服务器开好了，在8080上 子进程 服务器开好了，在8080上 子进程 服务器开好了，在8080上 子进程 服务器开好了，在8080上 子进程 服务器开好了，在8080上 子进程 服务器开好了，在8080上 子进程 服务器开好了，在8080上 子进程 26956 进程调度 主进程通过系统的CPU核数分裂了8个子进程，浏览器发起请求的时候只有一个子进程 26956干活 多个进程同时存在时，进程的调度原则是第一个进程满了才开启第二个进程，前面两个进程满了才开启第三个进程，这样做的原因是因为进程调度即进程切换是需要花费开销的 坑 主进程能否分裂100个进程，有必要么 可以分裂100个进程，但是没有必要，进程调度需要花费开销，况且进程的实际工作计算能力需要根据计算机本身硬件的限制 NodeJS使用MySQL 连接 一条连接 let db=mysql.createConnection({host: 'localhost', user: 'root', password: '', port: 3309, database: '20180127'}); 连接池获取连接 //连接池 let db=mysql.createPool({host: 'localhost', user: 'root', password: '', port: 3309, database: '20180127'}); 查询 const mysql=require('mysql'); let db=mysql.createConnection({host: 'localhost', user: 'root', password: '', port: 3309, database: '20180127'}); db.query(`INSERT INTO user_table (ID, name, gender, chinese, math, english) VALUES(0, '小明', '男', 98, 5, 3);`, (err, data)=>{ if(err){ console.log('错了', err); }else{ console.log(data); } }); 用户登录注册 数据库结构(数据字典) 接口格式(接口文档) 注册： /reg?user=xxx&amp;pass=xxx =&gt;{err: 0, msg: &#39;原因&#39;} 登陆： /login?user=xxx&amp;pass=xxx =&gt;{err: 0, msg: &#39;原因&#39;} 代码实现 前台 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script src="jquery.js" charset="utf-8">&lt;/script> &lt;script> $(function (){ //注册 $('#btn_reg').click(function (){ $.ajax({ url: '/reg', data: {user: $('#user').val(),pass: $('#pass').val()}, dataType: 'json', success(json){ if(json.err){ alert('注册失败'+json.msg); }else{ alert('注册成功'); } }, error(err){ alert('失败'); } }); }); //登陆 $('#btn_login').click(function (){ $.ajax({ url: '/login', data: {user: $('#user').val(),pass: $('#pass').val()}, dataType: 'json', success(json){ if(json.err){ alert('登陆失败'+json.msg); }else{ alert('登陆成功'); } }, error(err){ alert('失败'); } }); }); }); &lt;/script> &lt;/head> &lt;body> 用户：&lt;input type="text" id="user" />&lt;br> 密码：&lt;input type="password" id="pass" />&lt;br> &lt;input type="button" value="注册" id="btn_reg"> &lt;input type="button" value="登陆" id="btn_login"> &lt;/body> &lt;/html> 后台 const http=require('http'); const mysql=require('mysql'); const fs=require('fs'); const url=require('url'); const zlib=require('zlib'); const crypto=require('crypto'); //盐值 const _key='sadfslekrtuew5iutoselgdtjiypoydse4ufhs.edtyo;s8te4arfeliawkfhtsie5tlfia;sefdshroiupeoutwyeli5gurse;ihf'; //MD5加密 function md5(str){ let obj=crypto.createHash('md5'); obj.update(str); return obj.digest('hex'); } //MD5盐值加密 function md5_2(str){ return md5(md5(str)+_key); } //从连接池获取连接 let db=mysql.createPool({host: 'localhost', port: 3306, user: 'root', password: '000000', database: 'mytest'}); let server=http.createServer((req, res)=>{ let {pathname, query}=url.parse(req.url, true); let {user, pass}=query; switch(pathname){ //接口 case '/reg': //校验 if(!user){ res.write('{"err": 1, "msg": "username can\'t be null"}'); res.end(); }else if(!pass){ res.write('{"err": 1, "msg": "password can\'t be null"}'); res.end(); }else if(!/^\w{4,16}$/.test(user)){ res.write('{"err": 1, "msg": "username is invaild"}'); res.end(); }else if(/['|"]/.test(pass)){ res.write('{"err": 1, "msg": "password is invaild"}'); res.end(); }else{ db.query(`SELECT * FROM user_table WHERE username='${user}'`, (err, data)=>{ if(err){ res.write('{"err": 1, "msg": "database error"}'); res.end(); }else if(data.length>0){ res.write('{"err": 1, "msg": "this username exsits"}'); res.end(); }else{ db.query(`INSERT INTO user_table (ID,username,password) VALUES(0,'${user}','${md5_2(pass)}')`, (err, data)=>{ if(err){ res.write('{"err": 1, "msg": "database error"}'); res.end(); }else{ res.write('{"err": 0, "msg": "success"}'); res.end(); } }); } }); } break; case '/login': //校验 if(!user){ res.write('{"err": 1, "msg": "username can\'t be null"}'); res.end(); }else if(!pass){ res.write('{"err": 1, "msg": "password can\'t be null"}'); res.end(); }else if(!/^\w{4,16}$/.test(user)){ res.write('{"err": 1, "msg": "username is invaild"}'); res.end(); }else if(/['|"]/.test(pass)){ res.write('{"err": 1, "msg": "password is invaild"}'); res.end(); }else{ db.query(`SELECT * FROM user_table WHERE username='${user}'`, (err, data)=>{ if(err){ res.write('{"err": 1, "msg": "database error"}'); res.end(); }else if(data.length==0){ res.write('{"err": 1, "msg": "no this user"}'); res.end(); }else if(data[0].password!=md5_2(pass)){ res.write('{"err": 1, "msg": "username or password is incorrect"}'); res.end(); }else{ res.write('{"err": 0, "msg": "success"}'); res.end(); } }); } break; default: //缓存 TODO //静态文件 let rs=fs.createReadStream(`www${pathname}`); let gz=zlib.createGzip(); res.setHeader('content-encoding', 'gzip'); rs.pipe(gz).pipe(res); rs.on('error', err=>{ res.writeHeader(404); res.write('Not Found'); res.end(); }); } }); server.listen(8080);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始独立完成企业级Java电商网站开发（服务端）]]></title>
    <url>%2F2019%2F03%2F13%2Fcong-0-kai-shi-du-li-wan-cheng-qi-ye-ji-java-dian-shang-wang-zhan-kai-fa-fu-wu-duan%2F</url>
    <content type="text"><![CDATA[数据表结构设计 唯一索引unique，保证数据唯一性 CREATE TABLE `mmall_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户表id', `username` varchar(50) NOT NULL COMMENT '用户名', `password` varchar(50) NOT NULL COMMENT '用户密码，MD5加密', `email` varchar(50) DEFAULT NULL, `phone` varchar(20) DEFAULT NULL, `question` varchar(100) DEFAULT NULL COMMENT '找回密码问题', `answer` varchar(100) DEFAULT NULL COMMENT '找回密码答案', `role` int(4) NOT NULL COMMENT '角色0-管理员,1-普通用户', `create_time` datetime NOT NULL COMMENT '创建时间', `update_time` datetime NOT NULL COMMENT '最后一次更新时间', PRIMARY KEY (`id`), UNIQUE KEY `user_name_unique` (`username`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8; 单索引及组合索引 CREATE TABLE `mmall_order_item` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '订单子表id', `user_id` int(11) DEFAULT NULL, `order_no` bigint(20) DEFAULT NULL, `product_id` int(11) DEFAULT NULL COMMENT '商品id', `product_name` varchar(100) DEFAULT NULL COMMENT '商品名称', `product_image` varchar(500) DEFAULT NULL COMMENT '商品图片地址', `current_unit_price` decimal(20,2) DEFAULT NULL COMMENT '生成订单时的商品单价，单位是元,保留两位小数', `quantity` int(10) DEFAULT NULL COMMENT '商品数量', `total_price` decimal(20,2) DEFAULT NULL COMMENT '商品总价,单位是元,保留两位小数', `create_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `order_no_index` (`order_no`) USING BTREE, KEY `order_no_user_id_index` (`user_id`,`order_no`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=135 DEFAULT CHARSET=utf8; 查业务问题的后悔药 create_time 数据创建时间update_time 数据更新时间 mybatis三剑客 mybatis-generator自动化生成数据库交互代码 配置pom.xml &lt;build> &lt;finalName>mmall&lt;/finalName> &lt;plugins> &lt;plugin> &lt;groupId>org.mybatis.generator&lt;/groupId> &lt;artifactId>mybatis-generator-maven-plugin&lt;/artifactId> &lt;version>1.3.2&lt;/version> &lt;configuration> &lt;verbose>true&lt;/verbose> &lt;overwrite>true&lt;/overwrite> &lt;/configuration> &lt;/plugin> &lt;/build> datasource.properties db.driverLocation=/Users/imooc/mysql-connector-java-5.1.6-bin.jar db.driverClassName=com.mysql.jdbc.Driver #db.url=jdbc:mysql://192.1.1.1:3306/mmall?characterEncoding=utf-8 db.url=jdbc:mysql://你的数据库IP:你的数据库Port/你的database?characterEncoding=utf-8 db.username=mmall db.password=dbpassword db.initialSize = 20 db.maxActive = 50 db.maxIdle = 20 db.minIdle = 10 db.maxWait = 10 db.defaultAutoCommit = true db.minEvictableIdleTimeMillis = 3600000 generatorConfig.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"> &lt;generatorConfiguration> &lt;!--导入属性配置--> &lt;properties resource="datasource.properties">&lt;/properties> &lt;!--指定特定数据库的jdbc驱动jar包的位置--> &lt;classPathEntry location="${db.driverLocation}"/> &lt;context id="default" targetRuntime="MyBatis3"> &lt;!-- optional，旨在创建class时，对注释进行控制 --> &lt;commentGenerator> &lt;property name="suppressDate" value="true"/> &lt;property name="suppressAllComments" value="true"/> &lt;/commentGenerator> &lt;!--jdbc的数据库连接 --> &lt;jdbcConnection driverClass="${db.driverClassName}" connectionURL="${db.url}" userId="${db.username}" password="${db.password}"> &lt;/jdbcConnection> &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--> &lt;javaTypeResolver> &lt;property name="forceBigDecimals" value="false"/> &lt;/javaTypeResolver> &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --> &lt;!--&lt;javaModelGenerator targetPackage="com.mmall.pojo" targetProject=".\src\main\java">--> &lt;javaModelGenerator targetPackage="com.mmall.pojo" targetProject="./src/main/java"> &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --> &lt;property name="enableSubPackages" value="false"/> &lt;!-- 是否对model添加 构造函数 --> &lt;property name="constructorBased" value="true"/> &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --> &lt;property name="trimStrings" value="true"/> &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --> &lt;property name="immutable" value="false"/> &lt;/javaModelGenerator> &lt;!--mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --> &lt;!--&lt;sqlMapGenerator targetPackage="mappers" targetProject=".\src\main\resources">--> &lt;sqlMapGenerator targetPackage="mappers" targetProject="./src/main/resources"> &lt;property name="enableSubPackages" value="false"/> &lt;/sqlMapGenerator> &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码 type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象 type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象 type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口 --> &lt;!-- targetPackage：mapper接口dao生成的位置 --> &lt;!--&lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.mmall.dao" targetProject=".\src\main\java">--> &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.mmall.dao" targetProject="./src/main/java"> &lt;!-- enableSubPackages:是否让schema作为包的后缀 --> &lt;property name="enableSubPackages" value="false" /> &lt;/javaClientGenerator> &lt;table tableName="mmall_shipping" domainObjectName="Shipping" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false">&lt;/table> &lt;table tableName="mmall_cart" domainObjectName="Cart" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false">&lt;/table> &lt;table tableName="mmall_cart_item" domainObjectName="CartItem" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false">&lt;/table> &lt;table tableName="mmall_category" domainObjectName="Category" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false">&lt;/table> &lt;table tableName="mmall_order" domainObjectName="Order" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false">&lt;/table> &lt;table tableName="mmall_order_item" domainObjectName="OrderItem" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false">&lt;/table> &lt;table tableName="mmall_pay_info" domainObjectName="PayInfo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false">&lt;/table> &lt;table tableName="mmall_product" domainObjectName="Product" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"> &lt;columnOverride column="detail" jdbcType="VARCHAR" /> &lt;columnOverride column="sub_images" jdbcType="VARCHAR" /> &lt;/table> &lt;table tableName="mmall_user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false">&lt;/table> &lt;!-- geelynote mybatis插件的搭建 --> &lt;/context> &lt;/generatorConfiguration> 运行 mybatis-plugin idea插件，实现mybatis的接口文件和xml自动跳转 下载 mybatis-pagehelper mybatis分页组件 配置pom.xml &lt;!-- mybatis pager --> &lt;dependency> &lt;groupId>com.github.pagehelper&lt;/groupId> &lt;artifactId>pagehelper&lt;/artifactId> &lt;version>4.1.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.github.miemiedev&lt;/groupId> &lt;artifactId>mybatis-paginator&lt;/artifactId> &lt;version>1.2.17&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.github.jsqlparser&lt;/groupId> &lt;artifactId>jsqlparser&lt;/artifactId> &lt;version>0.9.4&lt;/version> &lt;/dependency> Tomcat加载spring、springmvc 方式一：配置web.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"> &lt;welcome-file-list> &lt;welcome-file>login.jsp&lt;/welcome-file> &lt;/welcome-file-list> &lt;!-- 启动我们自己的listener --> &lt;listener> &lt;listener-class>com.atguigu.scw.manager.listener.MyAppListener&lt;/listener-class> &lt;/listener> &lt;!-- 启动spring容器 --> &lt;!-- needed for ContextLoaderListener --> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:spring-*.xml&lt;/param-value> &lt;/context-param> &lt;!-- Bootstraps the root web application context before servlet initialization --> &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener> &lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --> &lt;servlet> &lt;servlet-name>springDispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springmvc.xml&lt;/param-value> &lt;/init-param> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;!-- Map all requests to the DispatcherServlet for handling --> &lt;servlet-mapping> &lt;servlet-name>springDispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;!-- 加上字符编码过滤器 --> &lt;filter> &lt;filter-name>CharacterEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;!-- 只是指定了编码格式 --> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>utf-8&lt;/param-value> &lt;/init-param> &lt;!-- 进行请求乱码解决 --> &lt;init-param> &lt;param-name>forceRequestEncoding&lt;/param-name> &lt;param-value>true&lt;/param-value> &lt;/init-param> &lt;init-param> &lt;param-name>forceResponseEncoding&lt;/param-name> &lt;param-value>true&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>CharacterEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;/web-app> 方式二：配置web.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"> &lt;display-name>Archetype Created Web Application&lt;/display-name> &lt;filter> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;init-param> &lt;param-name>forceEncoding&lt;/param-name> &lt;param-value>true&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;listener> &lt;listener-class>org.springframework.web.context.request.RequestContextListener&lt;/listener-class> &lt;/listener> &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value> classpath:applicationContext.xml &lt;/param-value> &lt;/context-param> &lt;servlet> &lt;servlet-name>dispatcher&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcher&lt;/servlet-name> &lt;url-pattern>*.do&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> 测试插件 FeHelper Restlet Client 用户模块 横向越权 入参需要指定当前用户id 纵向越权 MD5明文加密 盐值加密 MD5Util.java package com.mmall.util; import org.springframework.util.StringUtils; import java.security.MessageDigest; /** * Created by geely */ public class MD5Util { private static String byteArrayToHexString(byte b[]) { StringBuffer resultSb = new StringBuffer(); for (int i = 0; i &lt; b.length; i++) resultSb.append(byteToHexString(b[i])); return resultSb.toString(); } private static String byteToHexString(byte b) { int n = b; if (n &lt; 0) n += 256; int d1 = n / 16; int d2 = n % 16; return hexDigits[d1] + hexDigits[d2]; } /** * 返回大写MD5 * * @param origin * @param charsetname * @return */ private static String MD5Encode(String origin, String charsetname) { String resultString = null; try { resultString = new String(origin); MessageDigest md = MessageDigest.getInstance("MD5"); if (charsetname == null || "".equals(charsetname)) resultString = byteArrayToHexString(md.digest(resultString.getBytes())); else resultString = byteArrayToHexString(md.digest(resultString.getBytes(charsetname))); } catch (Exception exception) { } return resultString.toUpperCase(); } public static String MD5EncodeUtf8(String origin) { origin = origin + PropertiesUtil.getProperty("password.salt", ""); return MD5Encode(origin, "utf-8"); } private static final String hexDigits[] = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"}; } PropertiesUtil.java 读取src/main/resources目录下的配置文件 package com.mmall.util; import org.apache.commons.lang3.StringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.IOException; import java.io.InputStreamReader; import java.util.Properties; /** * Created by geely */ public class PropertiesUtil { private static Logger logger = LoggerFactory.getLogger(PropertiesUtil.class); private static Properties props; static { String fileName = "mmall.properties"; props = new Properties(); try { props.load(new InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(fileName),"UTF-8")); } catch (IOException e) { logger.error("配置文件读取异常",e); } } public static String getProperty(String key){ String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value)){ return null; } return value.trim(); } public static String getProperty(String key,String defaultValue){ String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value)){ value = defaultValue; } return value.trim(); } } mmall.properties ftp.server.ip=你的FTP服务器ip地址 ftp.user=mmallftp ftp.pass=ftppassword ftp.server.http.prefix=http://img.happymmall.com/ alipay.callback.url=http://www.happymmall.com/order/alipay_callback.do password.salt = geelysdafaqj23ou89ZXcj@#$@#$#@KJdjklj;D../dSF., 应用：明文加密 guava缓存 设置token并传给前台用户 验证token TokenCache.java package com.mmall.common; import com.google.common.cache.CacheBuilder; import com.google.common.cache.CacheLoader; import com.google.common.cache.LoadingCache; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.concurrent.TimeUnit; /** * Created by geely */ public class TokenCache { private static Logger logger = LoggerFactory.getLogger(TokenCache.class); public static final String TOKEN_PREFIX = "token_"; //LRU算法 private static LoadingCache&lt;String,String> localCache = CacheBuilder.newBuilder().initialCapacity(1000).maximumSize(10000).expireAfterAccess(12, TimeUnit.HOURS) .build(new CacheLoader&lt;String, String>() { //默认的数据加载实现,当调用get取值的时候,如果key没有对应的值,就调用这个方法进行加载. @Override public String load(String s) throws Exception { return "null"; } }); public static void setKey(String key,String value){ localCache.put(key,value); } public static String getKey(String key){ String value = null; try { value = localCache.get(key); if("null".equals(value)){ return null; } return value; }catch (Exception e){ logger.error("localCache get error",e); } return null; } } UserServiceImpl.java public ServerResponse&lt;String> checkAnswer(String username,String question,String answer){ int resultCount = userMapper.checkAnswer(username,question,answer); if(resultCount>0){ //说明问题及问题答案是这个用户的,并且是正确的 String forgetToken = UUID.randomUUID().toString(); TokenCache.setKey(TokenCache.TOKEN_PREFIX+username,forgetToken); return ServerResponse.createBySuccess(forgetToken); } return ServerResponse.createByErrorMessage("问题的答案错误"); } public ServerResponse&lt;String> forgetResetPassword(String username,String passwordNew,String forgetToken){ if(org.apache.commons.lang3.StringUtils.isBlank(forgetToken)){ return ServerResponse.createByErrorMessage("参数错误,token需要传递"); } ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess()){ //用户不存在 return ServerResponse.createByErrorMessage("用户不存在"); } String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX+username); if(org.apache.commons.lang3.StringUtils.isBlank(token)){ return ServerResponse.createByErrorMessage("token无效或者过期"); } if(org.apache.commons.lang3.StringUtils.equals(forgetToken,token)){ String md5Password = MD5Util.MD5EncodeUtf8(passwordNew); int rowCount = userMapper.updatePasswordByUsername(username,md5Password); if(rowCount > 0){ return ServerResponse.createBySuccessMessage("修改密码成功"); } }else{ return ServerResponse.createByErrorMessage("token错误,请重新获取重置密码的token"); } return ServerResponse.createByErrorMessage("修改密码失败"); } 高复用服务响应对象的设计思想和封装 ServerResponse.java package com.mmall.common; import org.codehaus.jackson.annotate.JsonIgnore; import org.codehaus.jackson.map.annotate.JsonSerialize; import java.io.Serializable; /** * Created by geely */ @JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL) //保证序列化json的时候,如果是null的对象,key也会消失 public class ServerResponse&lt;T> implements Serializable { private int status; private String msg; private T data; private ServerResponse(int status){ this.status = status; } private ServerResponse(int status,T data){ this.status = status; this.data = data; } private ServerResponse(int status,String msg,T data){ this.status = status; this.msg = msg; this.data = data; } private ServerResponse(int status,String msg){ this.status = status; this.msg = msg; } @JsonIgnore //使之不在json序列化结果当中 public boolean isSuccess(){ return this.status == ResponseCode.SUCCESS.getCode(); } public int getStatus(){ return status; } public T getData(){ return data; } public String getMsg(){ return msg; } public static &lt;T> ServerResponse&lt;T> createBySuccess(){ return new ServerResponse&lt;T>(ResponseCode.SUCCESS.getCode()); } public static &lt;T> ServerResponse&lt;T> createBySuccessMessage(String msg){ return new ServerResponse&lt;T>(ResponseCode.SUCCESS.getCode(),msg); } public static &lt;T> ServerResponse&lt;T> createBySuccess(T data){ return new ServerResponse&lt;T>(ResponseCode.SUCCESS.getCode(),data); } public static &lt;T> ServerResponse&lt;T> createBySuccess(String msg,T data){ return new ServerResponse&lt;T>(ResponseCode.SUCCESS.getCode(),msg,data); } public static &lt;T> ServerResponse&lt;T> createByError(){ return new ServerResponse&lt;T>(ResponseCode.ERROR.getCode(),ResponseCode.ERROR.getDesc()); } public static &lt;T> ServerResponse&lt;T> createByErrorMessage(String errorMessage){ return new ServerResponse&lt;T>(ResponseCode.ERROR.getCode(),errorMessage); } public static &lt;T> ServerResponse&lt;T> createByErrorCodeMessage(int errorCode,String errorMessage){ return new ServerResponse&lt;T>(errorCode,errorMessage); } } ResponseCode.java package com.mmall.common; /** * Created by geely */ public enum ResponseCode { SUCCESS(0,"SUCCESS"), ERROR(1,"ERROR"), NEED_LOGIN(10,"NEED_LOGIN"), ILLEGAL_ARGUMENT(2,"ILLEGAL_ARGUMENT"); private final int code; private final String desc; ResponseCode(int code,String desc){ this.code = code; this.desc = desc; } public int getCode(){ return code; } public String getDesc(){ return desc; } } 分类模块 递归算法 /** * 递归查询本节点的id及孩子节点的id * @param categoryId * @return */ public ServerResponse&lt;List&lt;Integer>> selectCategoryAndChildrenById(Integer categoryId){ Set&lt;Category> categorySet = Sets.newHashSet(); findChildCategory(categorySet,categoryId); List&lt;Integer> categoryIdList = Lists.newArrayList(); if(categoryId != null){ for(Category categoryItem : categorySet){ categoryIdList.add(categoryItem.getId()); } } return ServerResponse.createBySuccess(categoryIdList); } //递归算法,算出子节点 private Set&lt;Category> findChildCategory(Set&lt;Category> categorySet ,Integer categoryId){ Category category = categoryMapper.selectByPrimaryKey(categoryId); if(category != null){ categorySet.add(category); } //查找子节点,递归算法一定要有一个退出的条件 List&lt;Category> categoryList = categoryMapper.selectCategoryChildrenByParentId(categoryId); for(Category categoryItem : categoryList){ findChildCategory(categorySet,categoryItem.getId()); } return categorySet; } 复杂对象排重 Set集合 重写自定义对象Category的equals和hashCode方法 无限层级树结构设计 商品模块 POJO、BO、VO抽象模型 Product.java package com.mmall.pojo; import java.math.BigDecimal; import java.util.Date; public class Product { private Integer id; private Integer categoryId; private String name; private String subtitle; private String mainImage; private String subImages; private String detail; private BigDecimal price; private Integer stock; private Integer status; private Date createTime; private Date updateTime; public Product(Integer id, Integer categoryId, String name, String subtitle, String mainImage, String subImages, String detail, BigDecimal price, Integer stock, Integer status, Date createTime, Date updateTime) { this.id = id; this.categoryId = categoryId; this.name = name; this.subtitle = subtitle; this.mainImage = mainImage; this.subImages = subImages; this.detail = detail; this.price = price; this.stock = stock; this.status = status; this.createTime = createTime; this.updateTime = updateTime; } public Product() { super(); } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Integer getCategoryId() { return categoryId; } public void setCategoryId(Integer categoryId) { this.categoryId = categoryId; } public String getName() { return name; } public void setName(String name) { this.name = name == null ? null : name.trim(); } public String getSubtitle() { return subtitle; } public void setSubtitle(String subtitle) { this.subtitle = subtitle == null ? null : subtitle.trim(); } public String getMainImage() { return mainImage; } public void setMainImage(String mainImage) { this.mainImage = mainImage == null ? null : mainImage.trim(); } public String getSubImages() { return subImages; } public void setSubImages(String subImages) { this.subImages = subImages == null ? null : subImages.trim(); } public String getDetail() { return detail; } public void setDetail(String detail) { this.detail = detail == null ? null : detail.trim(); } public BigDecimal getPrice() { return price; } public void setPrice(BigDecimal price) { this.price = price; } public Integer getStock() { return stock; } public void setStock(Integer stock) { this.stock = stock; } public Integer getStatus() { return status; } public void setStatus(Integer status) { this.status = status; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } public Date getUpdateTime() { return updateTime; } public void setUpdateTime(Date updateTime) { this.updateTime = updateTime; } } ProductDetailVo.java package com.mmall.vo; import java.math.BigDecimal; /** * Created by geely */ public class ProductDetailVo { private Integer id; private Integer categoryId; private String name; private String subtitle; private String mainImage; private String subImages; private String detail; private BigDecimal price; private Integer stock; private Integer status; private String createTime; private String updateTime; private String imageHost; private Integer parentCategoryId; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Integer getCategoryId() { return categoryId; } public void setCategoryId(Integer categoryId) { this.categoryId = categoryId; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSubtitle() { return subtitle; } public void setSubtitle(String subtitle) { this.subtitle = subtitle; } public String getMainImage() { return mainImage; } public void setMainImage(String mainImage) { this.mainImage = mainImage; } public String getSubImages() { return subImages; } public void setSubImages(String subImages) { this.subImages = subImages; } public String getDetail() { return detail; } public void setDetail(String detail) { this.detail = detail; } public BigDecimal getPrice() { return price; } public void setPrice(BigDecimal price) { this.price = price; } public Integer getStock() { return stock; } public void setStock(Integer stock) { this.stock = stock; } public Integer getStatus() { return status; } public void setStatus(Integer status) { this.status = status; } public String getCreateTime() { return createTime; } public void setCreateTime(String createTime) { this.createTime = createTime; } public String getUpdateTime() { return updateTime; } public void setUpdateTime(String updateTime) { this.updateTime = updateTime; } public String getImageHost() { return imageHost; } public void setImageHost(String imageHost) { this.imageHost = imageHost; } public Integer getParentCategoryId() { return parentCategoryId; } public void setParentCategoryId(Integer parentCategoryId) { this.parentCategoryId = parentCategoryId; } } 静态代码块&gt;普通代码块&gt;构造代码块 Tomcat启动加载静态代码块 时间转换工具类DateTimeUtil.java package com.mmall.util; import org.apache.commons.lang3.StringUtils; import org.joda.time.DateTime; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import java.util.Date; /** * Created by geely */ public class DateTimeUtil { //joda-time //str->Date //Date->str public static final String STANDARD_FORMAT = "yyyy-MM-dd HH:mm:ss"; public static Date strToDate(String dateTimeStr,String formatStr){ DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(formatStr); DateTime dateTime = dateTimeFormatter.parseDateTime(dateTimeStr); return dateTime.toDate(); } public static String dateToStr(Date date,String formatStr){ if(date == null){ return StringUtils.EMPTY; } DateTime dateTime = new DateTime(date); return dateTime.toString(formatStr); } public static Date strToDate(String dateTimeStr){ DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(STANDARD_FORMAT); DateTime dateTime = dateTimeFormatter.parseDateTime(dateTimeStr); return dateTime.toDate(); } public static String dateToStr(Date date){ if(date == null){ return StringUtils.EMPTY; } DateTime dateTime = new DateTime(date); return dateTime.toString(STANDARD_FORMAT); } public static void main(String[] args) { System.out.println(DateTimeUtil.dateToStr(new Date(),"yyyy-MM-dd HH:mm:ss")); System.out.println(DateTimeUtil.strToDate("2010-01-01 11:11:11","yyyy-MM-dd HH:mm:ss")); } } mybatis-pagehelper高效分页 配置pom.xml 实现 mybatis-pagehelper动态排序 mybatis对List遍历的实现方法 mybatis对where语句动态拼装 FTP服务对接 先将文件上传到本地======&gt;上传到远程ftp====&gt;删除本地文件 配置pom.xml &lt;!-- file upload --> &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --> &lt;dependency> &lt;groupId>commons-fileupload&lt;/groupId> &lt;artifactId>commons-fileupload&lt;/artifactId> &lt;version>1.2.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>commons-io&lt;/groupId> &lt;artifactId>commons-io&lt;/artifactId> &lt;version>2.0.1&lt;/version> &lt;/dependency> 配置dispatcher-servlet.xml &lt;!-- 文件上传 --> &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"> &lt;property name="maxUploadSize" value="10485760"/> &lt;!-- 10m --> &lt;property name="maxInMemorySize" value="4096" /> &lt;property name="defaultEncoding" value="UTF-8">&lt;/property> &lt;/bean> FileServiceImpl.java package com.mmall.service.impl; import com.google.common.collect.Lists; import com.mmall.service.IFileService; import com.mmall.util.FTPUtil; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile; import java.io.File; import java.io.IOException; import java.util.UUID; /** * Created by geely */ @Service("iFileService") public class FileServiceImpl implements IFileService { private Logger logger = LoggerFactory.getLogger(FileServiceImpl.class); public String upload(MultipartFile file,String path){ String fileName = file.getOriginalFilename(); //扩展名 //abc.jpg String fileExtensionName = fileName.substring(fileName.lastIndexOf(".")+1); String uploadFileName = UUID.randomUUID().toString()+"."+fileExtensionName; logger.info("开始上传文件,上传文件的文件名:{},上传的路径:{},新文件名:{}",fileName,path,uploadFileName); File fileDir = new File(path); if(!fileDir.exists()){ fileDir.setWritable(true); fileDir.mkdirs(); } File targetFile = new File(path,uploadFileName); try { file.transferTo(targetFile); //文件已经上传成功了 FTPUtil.uploadFile(Lists.newArrayList(targetFile)); //已经上传到ftp服务器上 targetFile.delete(); } catch (IOException e) { logger.error("上传文件异常",e); return null; } //A:abc.jpg //B:abc.jpg return targetFile.getName(); } } 连接远程ftp，上传文件 FTPUtil.java package com.mmall.util; import org.apache.commons.net.ftp.FTPClient; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.util.List; /** * Created by geely */ public class FTPUtil { private static final Logger logger = LoggerFactory.getLogger(FTPUtil.class); private static String ftpIp = PropertiesUtil.getProperty("ftp.server.ip"); private static String ftpUser = PropertiesUtil.getProperty("ftp.user"); private static String ftpPass = PropertiesUtil.getProperty("ftp.pass"); public FTPUtil(String ip,int port,String user,String pwd){ this.ip = ip; this.port = port; this.user = user; this.pwd = pwd; } public static boolean uploadFile(List&lt;File> fileList) throws IOException { FTPUtil ftpUtil = new FTPUtil(ftpIp,21,ftpUser,ftpPass); logger.info("开始连接ftp服务器"); boolean result = ftpUtil.uploadFile("img",fileList); logger.info("开始连接ftp服务器,结束上传,上传结果:{}"); return result; } private boolean uploadFile(String remotePath,List&lt;File> fileList) throws IOException { boolean uploaded = true; FileInputStream fis = null; //连接FTP服务器 if(connectServer(this.ip,this.port,this.user,this.pwd)){ try { ftpClient.changeWorkingDirectory(remotePath); ftpClient.setBufferSize(1024); ftpClient.setControlEncoding("UTF-8"); ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); ftpClient.enterLocalPassiveMode(); for(File fileItem : fileList){ fis = new FileInputStream(fileItem); ftpClient.storeFile(fileItem.getName(),fis); } } catch (IOException e) { logger.error("上传文件异常",e); uploaded = false; e.printStackTrace(); } finally { fis.close(); ftpClient.disconnect(); } } return uploaded; } private boolean connectServer(String ip,int port,String user,String pwd){ boolean isSuccess = false; ftpClient = new FTPClient(); try { ftpClient.connect(ip); isSuccess = ftpClient.login(user,pwd); } catch (IOException e) { logger.error("连接FTP服务器异常",e); } return isSuccess; } private String ip; private int port; private String user; private String pwd; private FTPClient ftpClient; public String getIp() { return ip; } public void setIp(String ip) { this.ip = ip; } public int getPort() { return port; } public void setPort(int port) { this.port = port; } public String getUser() { return user; } public void setUser(String user) { this.user = user; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } public FTPClient getFtpClient() { return ftpClient; } public void setFtpClient(FTPClient ftpClient) { this.ftpClient = ftpClient; } } 富文本上传 和ftp文件上传类似，只是对返回值有特殊要求 购物车模块 商品总价计算复用封装 package com.mmall.util; import java.math.BigDecimal; /** * Created by geely */ public class BigDecimalUtil { private BigDecimalUtil(){ } public static BigDecimal add(double v1,double v2){ BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.add(b2); } public static BigDecimal sub(double v1,double v2){ BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.subtract(b2); } public static BigDecimal mul(double v1,double v2){ BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2); } public static BigDecimal div(double v1,double v2){ BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.divide(b2,2,BigDecimal.ROUND_HALF_UP);//四舍五入,保留2位小数 //除不尽的情况 } } 高复用的逻辑方法封装思想 解决商业运算丢失精度的坑 一定要用BigDecimal的String构造函数 public class BigDecimalTest { @Test public void test1(){ System.out.println(0.05+0.01); System.out.println(1.0-0.42); System.out.println(4.015*100); System.out.println(123.3/100); } @Test public void test2(){ BigDecimal b1 = new BigDecimal(0.05); BigDecimal b2 = new BigDecimal(0.01); System.out.println(b1.add(b2)); } @Test public void test3(){ BigDecimal b1 = new BigDecimal("0.05"); BigDecimal b2 = new BigDecimal("0.01"); System.out.println(b1.add(b2)); } } 订单模块 安全漏洞解决方案 订单号生成规则 强大的常量、枚举设计 Const.java package com.mmall.common; import com.google.common.collect.Sets; import java.util.Set; /** * Created by geely */ public class Const { public static final String CURRENT_USER = "currentUser"; public static final String EMAIL = "email"; public static final String USERNAME = "username"; public interface ProductListOrderBy{ Set&lt;String> PRICE_ASC_DESC = Sets.newHashSet("price_desc","price_asc"); } public interface Cart{ int CHECKED = 1;//即购物车选中状态 int UN_CHECKED = 0;//购物车中未选中状态 String LIMIT_NUM_FAIL = "LIMIT_NUM_FAIL"; String LIMIT_NUM_SUCCESS = "LIMIT_NUM_SUCCESS"; } public interface Role{ int ROLE_CUSTOMER = 0; //普通用户 int ROLE_ADMIN = 1;//管理员 } public enum ProductStatusEnum{ ON_SALE(1,"在线"); private String value; private int code; ProductStatusEnum(int code,String value){ this.code = code; this.value = value; } public String getValue() { return value; } public int getCode() { return code; } } public enum OrderStatusEnum{ CANCELED(0,"已取消"), NO_PAY(10,"未支付"), PAID(20,"已付款"), SHIPPED(40,"已发货"), ORDER_SUCCESS(50,"订单完成"), ORDER_CLOSE(60,"订单关闭"); OrderStatusEnum(int code,String value){ this.code = code; this.value = value; } private String value; private int code; public String getValue() { return value; } public int getCode() { return code; } public static OrderStatusEnum codeOf(int code){ for(OrderStatusEnum orderStatusEnum : values()){ if(orderStatusEnum.getCode() == code){ return orderStatusEnum; } } throw new RuntimeException("么有找到对应的枚举"); } } public interface AlipayCallback{ String TRADE_STATUS_WAIT_BUYER_PAY = "WAIT_BUYER_PAY"; String TRADE_STATUS_TRADE_SUCCESS = "TRADE_SUCCESS"; String RESPONSE_SUCCESS = "success"; String RESPONSE_FAILED = "failed"; } public enum PayPlatformEnum{ ALIPAY(1,"支付宝"); PayPlatformEnum(int code,String value){ this.code = code; this.value = value; } private String value; private int code; public String getValue() { return value; } public int getCode() { return code; } } public enum PaymentTypeEnum{ ONLINE_PAY(1,"在线支付"); PaymentTypeEnum(int code,String value){ this.code = code; this.value = value; } private String value; private int code; public String getValue() { return value; } public int getCode() { return code; } public static PaymentTypeEnum codeOf(int code){ for(PaymentTypeEnum paymentTypeEnum : values()){ if(paymentTypeEnum.getCode() == code){ return paymentTypeEnum; } } throw new RuntimeException("么有找到对应的枚举"); } } } 使用 mybatis批量插入 收货地址 同步获取自增主键 数据绑定的对象绑定 收货地址对象必须要有get和set方法 越权问题升级巩固 支付模块 支付宝SDK源码解析 当面付 当面付Demo 服务端SDK下载和使用教程 沙箱环境使用 生成RSA密钥 支付宝支付流程与集成 导入依赖 配置maven插件,除了pom.xml配置的依赖，lib包中的依赖也会一起打包部署 配置沙箱环境zfbinfo.properties # 支付宝网关名、partnerId和appId open_api_domain = https://openapi.alipaydev.com/gateway.do mcloud_api_domain = http://mcloudmonitor.com/gateway.do pid = 2088102180444972 appid = 2016102100728313 # RSA私钥、公钥和支付宝公钥 private_key = MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCKQ2pEIzXM4IoN1cMzOFXdlk8yVX2cKXWITZ92EGAQQcRytaV07yQOaz3UE9KTeT9Nu628G+HZMsJUxQjEUETagmY5nLtbeL35M2UcibYpM3e2gVTtUW86CA65GCdLzUhdIug8yf2F9zWayzG4sHZ9DcTezG6ZjFu+EtDpFgg+CtqY7n/ihjTIqeE1lX0C2ZIKpIYs7QjR8AztB/qRcpOJKRfMKGDgmT9GALN8LeFEYCbQ+W/GJHN8bQ0Bk1Ll6EKQ4cHXZ1Yko+aXaRfbXfUZYgD9hwAVlxtwZndgeFX8KapOCw0J25pzV4WkutIjMlt7I2Q1jaWNoKLuxtz4M2mzAgMBAAECggEAAhnsL4TpeGehMXyiLtEYXPm/0mACPLFUm/GyDrVJAHY/ag7gqNpJjf6LPgHfHWamU6Qai9VQpWBkG62y6Gjf4wJAU3fSUR2QpYzmaHyfTBkAJMHqbIDkU9lzf9SiJEDGbMPvC512QOb05ZlY9Bmac2QWLdylgafkbQsUKbawAWFa/BAOMIp0tgYLW8/yY2aG6jeLqhOgTo8MWIW5d1qHtX5m/x7g97dYYMdX3kTo2i1dFLUVfEOvZe4US6VBvLg71dMxwadVF5YMaY9jq/ShPD0Gkf29wdThwsjcH6u9Tq/KArQTK+z02DAGkdWOcue3pHql+gvoIA8U5uFDdIeYwQKBgQDri3jPkDKi48efdKQk38rn+CJYeNFNRAhlly3h2AHaFEY92XRlBsho/vGFg43BvHu+cMz0Run4SS8Vo09vcTIY6p2xNMffjR0w2gQqx6PUdGHBFtw7FavxN4uVtVhL6uTAqfBv97mqQO0bq+DhOGwSRNIWqvnzfXywqwmXhKYECwKBgQCWRTl6tNv8scxPq4fpRL/uw71TU6XqSS/nME7KT4uyQPAXPk0mXVVwdmyST9Crlr6O6WJopPe9nMIFUYdjdkLfGKLCR96AH3U7frr4jf60eDYEhfHGIzln/ptrTJLvvbXTaPctAaZd6TIv63QVz3yim4MMl3VSdRlrE+O9R5ZR+QKBgQDjEP8TyUSnNsJX+4/JZFwsp04kz8OlorIdjVHT5/JREz5rnVfRlGpanXqjZSCg5Vy9R+ysiDhA+/wB9f87xXmv/2ypSeJspZLAZ0uhGffbdZ5PEASaiNfKn+tWFQ3bkcOX37tDlSJM+G4bQOR2+XdlXSbSZ1yx2AT+IsQKZvvL5QKBgQCPZEUiEz0sV1kX2R2a+XCQ3RVnUxWqh+X/HPjCUr+B/DdeZqPl7QAfjdGymBkN842o/4lZQ7nnpJL70j14KpxLGM4Ox9fIuLv8ZsTxc0XOXjtle48nO+uGkc0qyWoY/RVpQ+tBdiaTzHeIhIxEV7adz/lwZYKdiYIUzGjv8ES/uQKBgCgeWysXjahCQItxx5fTrS8SQFP7Dx5vDW+UkqQ2pbL0AlHyUS7pWJj3AAe3pn4AJZZp4SZPoQP+Z8JPqDA6MrQWHYMi0XkMuMYwLWbGCkmf1MnjUxgOaLXoItjxS/y3jQfeOmHhmOAVkjnEvAh+BWlZxFMv2kiuHRU72bNa0rDI public_key = MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAikNqRCM1zOCKDdXDMzhV3ZZPMlV9nCl1iE2fdhBgEEHEcrWldO8kDms91BPSk3k/TbutvBvh2TLCVMUIxFBE2oJmOZy7W3i9+TNlHIm2KTN3toFU7VFvOggOuRgnS81IXSLoPMn9hfc1mssxuLB2fQ3E3sxumYxbvhLQ6RYIPgramO5/4oY0yKnhNZV9AtmSCqSGLO0I0fAM7Qf6kXKTiSkXzChg4Jk/RgCzfC3hRGAm0PlvxiRzfG0NAZNS5ehCkOHB12dWJKPml2kX2131GWIA/YcAFZcbcGZ3YHhV/CmqTgsNCduac1eFpLrSIzJbeyNkNY2ljaCi7sbc+DNpswIDAQAB #SHA1withRsa对应支付宝公钥 #alipay_public_key = MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi/fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI/FCEa3/cNMW0QIDAQAB #SHA256withRsa对应支付宝公钥 alipay_public_key = MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqzWgVL/NWrJAeyEImwtaK3IDwj0dKkqUDIfqqWn5SiLaWMYi9RmKhn+jY9VM7JXEIkYYeVlqIL6Xn7OvYFRTi4buTCXGKvFLn95aDcaur77/S/0ibcdN1K2wIoHzaqQhXAb1ezKxTnFP7OLJsAL22b0NzrQDj2OH9SA06gJb8nHBfR+7Sx7DfwcqE0OtTcDHjbbcB24Qgg/dfItxoEnKuSyRVrf6BtpUnJxSzG/Ge7FfF+VBq8re1t4ZTSxaDEjto071I5VFBxr7I4SyqZsc7WpAmZL8AqUgEbQ1XYBWx2LnpJXM5GQW/thUvcDDqzea7LJNWJOQPM5DaZQgu7QuuwIDAQAB # 签名类型: RSA-&gt;SHA1withRsa,RSA2-&gt;SHA256withRsa sign_type = RSA2 # 当面付最大查询次数和查询间隔（毫秒） max_query_retry = 5 query_duration = 5000 # 当面付最大撤销次数和撤销间隔（毫秒） max_cancel_retry = 3 cancel_duration = 2000 # 交易保障线程第一次调度延迟和调度间隔（秒） heartbeat_delay = 5 heartbeat_duration = 900 二维码生成，扫码支付 配置回调url 两次回调，扫码进行一次回调，扫码付款成功进行一次回调 生成二维码，上传到ftp服务器 OrderServiceImpl.java package com.mmall.service.impl; /** * Created by geely */ @Service("iOrderService") public class OrderServiceImpl implements IOrderService { private static AlipayTradeService tradeService; static { /** 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数 * Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是否在classpath目录 */ Configs.init("zfbinfo.properties"); /** 使用Configs提供的默认参数 * AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new */ tradeService = new AlipayTradeServiceImpl.ClientBuilder().build(); } private static final Logger logger = LoggerFactory.getLogger(OrderServiceImpl.class); @Autowired private OrderMapper orderMapper; @Autowired private OrderItemMapper orderItemMapper; @Autowired private PayInfoMapper payInfoMapper; @Autowired private CartMapper cartMapper; @Autowired private ProductMapper productMapper; @Autowired private ShippingMapper shippingMapper; public ServerResponse pay(Long orderNo,Integer userId,String path){ Map&lt;String ,String> resultMap = Maps.newHashMap(); Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order == null){ return ServerResponse.createByErrorMessage("用户没有该订单"); } resultMap.put("orderNo",String.valueOf(order.getOrderNo())); // (必填) 商户网站订单系统中唯一订单号，64个字符以内，只能包含字母、数字、下划线， // 需保证商户系统端不能重复，建议通过数据库sequence生成， String outTradeNo = order.getOrderNo().toString(); // (必填) 订单标题，粗略描述用户的支付目的。如“xxx品牌xxx门店当面付扫码消费” String subject = new StringBuilder().append("happymmall扫码支付,订单号:").append(outTradeNo).toString(); // (必填) 订单总金额，单位为元，不能超过1亿元 // 如果同时传入了【打折金额】,【不可打折金额】,【订单总金额】三者,则必须满足如下条件:【订单总金额】=【打折金额】+【不可打折金额】 String totalAmount = order.getPayment().toString(); // (可选) 订单不可打折金额，可以配合商家平台配置折扣活动，如果酒水不参与打折，则将对应金额填写至此字段 // 如果该值未传入,但传入了【订单总金额】,【打折金额】,则该值默认为【订单总金额】-【打折金额】 String undiscountableAmount = "0"; // 卖家支付宝账号ID，用于支持一个签约账号下支持打款到不同的收款账号，(打款到sellerId对应的支付宝账号) // 如果该字段为空，则默认为与支付宝签约的商户的PID，也就是appid对应的PID String sellerId = ""; // 订单描述，可以对交易或商品进行一个详细地描述，比如填写"购买商品2件共15.00元" String body = new StringBuilder().append("订单").append(outTradeNo).append("购买商品共").append(totalAmount).append("元").toString(); // 商户操作员编号，添加此参数可以为商户操作员做销售统计 String operatorId = "test_operator_id"; // (必填) 商户门店编号，通过门店号和商家后台可以配置精准到门店的折扣信息，详询支付宝技术支持 String storeId = "test_store_id"; // 业务扩展参数，目前可添加由支付宝分配的系统商编号(通过setSysServiceProviderId方法)，详情请咨询支付宝技术支持 ExtendParams extendParams = new ExtendParams(); extendParams.setSysServiceProviderId("2088100200300400500"); // 支付超时，定义为120分钟 String timeoutExpress = "120m"; // 商品明细列表，需填写购买商品详细信息， List&lt;GoodsDetail> goodsDetailList = new ArrayList&lt;GoodsDetail>(); List&lt;OrderItem> orderItemList = orderItemMapper.getByOrderNoUserId(orderNo,userId); for(OrderItem orderItem : orderItemList){ GoodsDetail goods = GoodsDetail.newInstance(orderItem.getProductId().toString(), orderItem.getProductName(), BigDecimalUtil.mul(orderItem.getCurrentUnitPrice().doubleValue(),new Double(100).doubleValue()).longValue(), orderItem.getQuantity()); goodsDetailList.add(goods); } // 创建扫码支付请求builder，设置请求参数 AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder() .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo) .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body) .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams) .setTimeoutExpress(timeoutExpress) .setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url"))//支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置 .setGoodsDetailList(goodsDetailList); AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder); switch (result.getTradeStatus()) { case SUCCESS: logger.info("支付宝预下单成功: )"); AlipayTradePrecreateResponse response = result.getResponse(); dumpResponse(response); File folder = new File(path); if(!folder.exists()){ folder.setWritable(true); folder.mkdirs(); } // 需要修改为运行机器上的路径 //细节细节细节 String qrPath = String.format(path+"/qr-%s.png",response.getOutTradeNo()); String qrFileName = String.format("qr-%s.png",response.getOutTradeNo()); ZxingUtils.getQRCodeImge(response.getQrCode(), 256, qrPath); File targetFile = new File(path,qrFileName); try { FTPUtil.uploadFile(Lists.newArrayList(targetFile)); } catch (IOException e) { logger.error("上传二维码异常",e); } logger.info("qrPath:" + qrPath); String qrUrl = PropertiesUtil.getProperty("ftp.server.http.prefix")+targetFile.getName(); resultMap.put("qrUrl",qrUrl); return ServerResponse.createBySuccess(resultMap); case FAILED: logger.error("支付宝预下单失败!!!"); return ServerResponse.createByErrorMessage("支付宝预下单失败!!!"); case UNKNOWN: logger.error("系统异常，预下单状态未知!!!"); return ServerResponse.createByErrorMessage("系统异常，预下单状态未知!!!"); default: logger.error("不支持的交易状态，交易返回异常!!!"); return ServerResponse.createByErrorMessage("不支持的交易状态，交易返回异常!!!"); } } // 简单打印应答 private void dumpResponse(AlipayResponse response) { if (response != null) { logger.info(String.format("code:%s, msg:%s", response.getCode(), response.getMsg())); if (StringUtils.isNotEmpty(response.getSubCode())) { logger.info(String.format("subCode:%s, subMsg:%s", response.getSubCode(), response.getSubMsg())); } logger.info("body:" + response.getBody()); } } public ServerResponse aliCallback(Map&lt;String,String> params){ Long orderNo = Long.parseLong(params.get("out_trade_no")); String tradeNo = params.get("trade_no"); String tradeStatus = params.get("trade_status"); Order order = orderMapper.selectByOrderNo(orderNo); if(order == null){ return ServerResponse.createByErrorMessage("非快乐慕商城的订单,回调忽略"); } if(order.getStatus() >= Const.OrderStatusEnum.PAID.getCode()){ return ServerResponse.createBySuccess("支付宝重复调用"); } if(Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(tradeStatus)){ order.setPaymentTime(DateTimeUtil.strToDate(params.get("gmt_payment"))); order.setStatus(Const.OrderStatusEnum.PAID.getCode()); orderMapper.updateByPrimaryKeySelective(order); } PayInfo payInfo = new PayInfo(); payInfo.setUserId(order.getUserId()); payInfo.setOrderNo(order.getOrderNo()); payInfo.setPayPlatform(Const.PayPlatformEnum.ALIPAY.getCode()); payInfo.setPlatformNumber(tradeNo); payInfo.setPlatformStatus(tradeStatus); payInfoMapper.insert(payInfo); return ServerResponse.createBySuccess(); } public ServerResponse queryOrderPayStatus(Integer userId,Long orderNo){ Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order == null){ return ServerResponse.createByErrorMessage("用户没有该订单"); } if(order.getStatus() >= Const.OrderStatusEnum.PAID.getCode()){ return ServerResponse.createBySuccess(); } return ServerResponse.createByError(); } } 内网穿透 NATAPP1分钟快速新手图文教程 线上部署 云服务器vsftpd、nginx等配置 云服务器的配置与域名解析 发布上线注意事项]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统下开发环境安装与配置]]></title>
    <url>%2F2019%2F03%2F07%2Flinux-xi-tong-xia-kai-fa-huan-jing-an-zhuang-yu-pei-zhi%2F</url>
    <content type="text"><![CDATA[安装系统环境 CentOS 6.8 64位 jdk版本 7u80 64位 Tomcat版本 Tomcat7 maven版本 Apache Maven 3.6.0 vsftpd版本 vsftpd-2.2.2-24.el6.x86_64 Nginx版本 nginx-1.14.2 mysql版本 mysql-server-5.1.73-8.el6_8.x86_64 git版本 git version 2.18.0 阿里源配置 #备份 [root@192 yum.repos.d]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup #下载新的CentOS-Base.repo 到/etc/yum.repos.d/ [root@192 yum.repos.d]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo #生成缓存 [root@192 yum.repos.d]# yum makecache 设置开机时关闭防火墙 [root@192 vsftpd]# chkconfig iptables off jdk安装 下载 清理系统默认自带jdk [root@192 yum.repos.d]# rpm -qa | grep jdk java-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64 java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64 [root@192 yum.repos.d]# yum remove java-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64 [root@192 yum.repos.d]# yum remove java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64 授权 [root@192 soft]# chmod 777 jdk-7u80-linux-x64.rpm 安装 [root@192 soft]# rpm -ivh jdk-7u80-linux-x64.rpm 默认安装路径/user/java jdk配置环境变量,编辑/etc/profile文件，末尾追加 #jdk export JAVA_HOME=/usr/java/jdk1.7.0_80 export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 使得/etc/profile文件立即生效 [root@192 apache-maven-3.6.0]# source /etc/profile Tomcat安装 下载 解压 [root@192 soft]# tar -zxvf apache-tomcat-7.0.93.tar.gz -C /opt/module/ Tomcat配置环境变量,编辑/etc/profile文件，末尾追加 #tomcat export CATALINA_HOME=/opt/module/apache-tomcat-7.0.93 export PATH=$PATH:$CATALINA_HOME/bin 使得/etc/profile文件立即生效 [root@192 apache-maven-3.6.0]# source /etc/profile 配置UTF-8字符集，进入Tomcat安装的conf文件夹，编辑server.xml文件，找到配置8080默认端口的位置，在xml节点末尾增加URIEncoding=&quot;UTF-8&quot; &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt; 启动Tomcat，进入/opt/module/apache-tomcat-7.0.93/bin目录，执行./startup.sh 访问http://192.168.1.104:8080/ Maven安装 下载 解压 [root@192 soft]# tar -zxvf apache-maven-3.6.0-bin.tar.gz -C /opt/module/ Maven配置环境变量,编辑/etc/profile文件，末尾追加 #maven export MAVEN_HOME=/opt/module/apache-maven-3.6.0 export PATH=$PATH:$MAVEN_HOME/bin 使得/etc/profile文件立即生效 [root@192 apache-maven-3.6.0]# source /etc/profile 验证 [root@192 apache-maven-3.6.0]# mvn -version vsftpd安装 安装 [root@192 apache-maven-3.6.0]# yum -y install vsftpd 查看是否已安装 [root@192 apache-maven-3.6.0]# rpm -qa | grep vsftpd vsftpd-2.2.2-24.el6.x86_64 默认配置文件/etc/vsftpd/vsftpd.conf 创建虚拟用户 根目录下创建ftp文件夹 [root@192 vsftpd]# cd / [root@192 /]# mkdir ftpfile 添加匿名用户 [root@192 /]# useradd ftpuser -d /ftpfile/ -s /sbin/nologin 修改ftpfile权限 [root@192 /]# chown -R ftpuser.ftpuser /ftpfile/ 重设ftpuser密码 [root@192 /]# passwd ftpuser 将刚刚新增的虚拟用户添加到此配置文件中 [root@192 ~]# cd /etc/vsftpd/ [root@192 vsftpd]# vim chroo_list [root@192 bin]# cat /etc/vsftpd/chroo_list ftpuser 编辑配置文件/etc/vsftpd/vsftpd.conf，末尾追加 local_root=/ftpfile anon_root=/ftpfile use_localtime=YES anonymous_enable=no 登录验证的时候出现500提示,编辑/etc/selinux/config文件，设置SELINUX=disabled [root@192 vsftpd]# vim /etc/selinux/config 如果还报500，执行 [root@192 vsftpd]# setsebool -P ftp_home_dir 1 设置开启启动vsftpd服务 [root@192 vsftpd]# chkconfig vsftpd on 访问ftp://192.168.1.104/ 安装Nginx 下载 安装依赖gcc、pcre、zlib、openssl [root@192 vsftpd]# yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 解压 [root@192 soft]# tar -zxvf nginx-1.14.2.tar.gz -C /opt/module/ 编译安装 [root@192 nginx-1.14.2]# pwd /opt/module/nginx-1.14.2 [root@192 nginx-1.14.2]# ./configure [root@192 nginx-1.14.2]# make [root@192 nginx-1.14.2]# make install 查看Nginx安装目录、版本 [root@192 nginx-1.14.2]# whereis nginx nginx: /usr/local/nginx [root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx -v nginx version: nginx/1.14.2 测试配置文件nginx.conf的正确性 [root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx -t 启动Nginx [root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx [root@192 nginx-1.14.2]# ps -ef | grep nginx root 5606 1 0 01:02 ? 00:00:00 nginx: master process /usr/local/nginx/sbin/nginx nobody 5607 5606 0 01:02 ? 00:00:00 nginx: worker process root 5626 2868 0 01:09 pts/0 00:00:00 grep nginx 停止Nginx [root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx -s stop 访问http://192.168.1.104/ Nginx配置虚拟域名 配置虚拟域名映射 [root@192 vhost]# cat /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 #centos #192.168.1.104 www.imooc.com 127.0.0.1 www.imooc.com 测试 [root@192 sbin]# ping www.imooc.com PING www.imooc.com (127.0.0.1) 56(84) bytes of data. 64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.013 ms 64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.032 ms 编辑/usr/local/nginx/conf/nginx.conf文件，追加 ###########################vhost############################################## include vhost/*.conf; 在/usr/local/nginx/conf目录下，新建vhost文件夹 在/usr/local/nginx/conf/vhost目录下，新建域名转发www.mytest.com.conf配置文件 [root@192 vhost]# cat /usr/local/nginx/conf/vhost/www.mytest.com.conf #Start www.mytest.com server { listen 80; server_name www.mytest.com; access_log /usr/local/nginx/logs/access.log combined; index index.html index.htm index.php; if ( $query_string ~* &quot;.*[\;&#39;\&lt;\&gt;].*&quot; ){ return 404; } # send request back to apach location / { proxy_pass http://127.0.0.1:8080/; } } 访问www.mytest.com Nginx配置静态资源转发 编辑/usr/local/nginx/conf/nginx.conf文件，追加 ###########################vhost############################################## include vhost/*.conf; 在/usr/local/nginx/conf目录下，新建vhost文件夹 在/usr/local/nginx/conf/vhost目录下，新建域名转发www.mytest.com.conf配置文件 [root@192 vhost]# cat /usr/local/nginx/conf/vhost/www.mytest.com.conf #Start www.mytest.com server { listen 80; server_name www.mytest.com; access_log /usr/local/nginx/logs/access.log combined; index index.html index.htm index.php; if ( $query_string ~* &quot;.*[\;&#39;\&lt;\&gt;].*&quot; ){ return 404; } # send request back to apach location / { root /ftpfile/; } } mysql安装 安装 [root@192 ~]# yum -y install mysql-server 配置字符集,编辑/etc/my.cnf文件，追加 #utf8 default-character-set=utf8 设置mysql服务随系统自动启动 [root@192 ~]# chkconfig mysqld on [root@192 ~]# chkconfig --list mysqld mysqld 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 启动mysql服务 [root@192 ~]# service mysqld start 正在启动 mysqld： [确定] 登录，使用非密码登录 [root@192 mysql]# mysql -uroot Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 5 Server version: 5.1.73 Source distribution Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement. mysql&gt; 查看mysql的用户 mysql&gt; select user,host,password from mysql.user; +------+---------------+----------+ | user | host | password | +------+---------------+----------+ | root | localhost | | | root | 192.168.1.104 | | | root | 127.0.0.1 | | | | localhost | | | | 192.168.1.104 | | +------+---------------+----------+ 5 rows in set (0.00 sec) 删除匿名用户 mysql&gt; delete from mysql.user where user=&#39;&#39;; Query OK, 2 rows affected (0.00 sec) 刷新，立即生效 mysql&gt; flush privileges; Query OK, 0 rows affected (0.00 sec) 修改root密码 mysql&gt; set password for root@localhost=password(&quot;000000&quot;); Query OK, 0 rows affected (0.00 sec) 插入mysql新用户 mysql&gt; insert into mysql.user(Host,User,Password) values(&quot;localhost&quot;,&quot;admin&quot;,password(&quot;000000&quot;)); Query OK, 1 row affected, 3 warnings (0.01 sec) 查看用户权限 mysql&gt; select * from mysql.user \G *************************** 1. row *************************** Host: localhost User: root Password: *032197AE5731D4664921A6CCAC7CFCE6A0698693 Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: Y Create_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0 *************************** 2. row *************************** Host: 192.168.1.104 User: root Password: Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: Y Create_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0 *************************** 3. row *************************** Host: 127.0.0.1 User: root Password: Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: Y Create_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0 *************************** 4. row *************************** Host: localhost User: admin Password: *032197AE5731D4664921A6CCAC7CFCE6A0698693 Select_priv: N Insert_priv: N Update_priv: N Delete_priv: N Create_priv: N Drop_priv: N Reload_priv: N Shutdown_priv: N Process_priv: N File_priv: N Grant_priv: N References_priv: N Index_priv: N Alter_priv: N Show_db_priv: N Super_priv: N Create_tmp_table_priv: N Lock_tables_priv: N Execute_priv: N Repl_slave_priv: N Repl_client_priv: N Create_view_priv: N Show_view_priv: N Create_routine_priv: N Alter_routine_priv: N Create_user_priv: N Event_priv: N Trigger_priv: N ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0 4 rows in set (0.00 sec) 查库，新建database数据库 mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | test | +--------------------+ 3 rows in set (0.01 sec) mysql&gt; create database mytest default character set utf8 collate utf8_general_ci; Query OK, 1 row affected (0.00 sec) mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | mytest | | test | +--------------------+ 4 rows in set (0.00 sec) 本地用户赋予所有权限、给账号开通外网所有权限 mysql&gt; grant all privileges on mytest.* to admin@&#39;%&#39; identified by &#39;000000&#39; with grant option; Query OK, 0 rows affected (0.00 sec) mysql&gt; grant select,delete,create on mytest.* to admin@&#39;192.168.1.104&#39; identified by &#39;000000&#39; with grant option; Query OK, 0 rows affected (0.00 sec) 导入sql文件 mysql&gt; source /opt/module/mmall.sql git安装 下载 解压 [root@192 ~]# tar -zxvf git-2.18.0.tar.gz -C /opt/module/ 安装依赖 [root@192 ~]# yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker cpio 编译安装 [root@192 git-2.18.0]# make prefix=/usr/local/ install 验证 [root@192 ~]# git --version git version 2.18.0 生成公私密钥对 [root@192 ~]# ssh-keygen -t rsa -C &quot;782125244@qq.com&quot; Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: 85:1e:ef:5a:33:ab:e7:79:a4:46:f6:8e:8f:7f:af:cd 782125244@qq.com The key&#39;s randomart image is: +--[ RSA 2048]----+ | | | . | | o . | | . + | | S . | | .o . | | o=+ | | o+Bo .o | | o=*=+..oE| +-----------------+ 复制公钥粘贴到码云或者GitHub上SSH公钥上 [root@192 .ssh]# cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA1sZvTnjQyVn7r2C7G9Q/WyVTTmJYqWhQdVfh3tBCUX8kJHaAcThwR4sl8ROz6xXl/22wbzlsKtfsiyr5zrV0Ifnq7KuCeNVNUYjOQCTn+ODaRzdj7DYC4Mz9BvxZAr0MDfSbgpLp6ZLAvZlkP3DioOPda7VnfJSAHGEYztOVPITj31pVnP1nXkPZRQlsTwImXEGJpuU+zOaurMShpaukrY/ONxWHR6xlG5M1FgOLdBvEnlbhOFoME1HHziI4/08Xw/NrHIUhvjZZgkAzWUo5NvYZLEwrUjOPtlVxHbYwBEtgBWRgWLFMfTlxQnEJVKzbwUDPLvZWac9WSpGLx5xiww== 782125244@qq.com 配置用户名、邮箱，提交时会引用 [root@192 mytest]# git config --global user.name &quot;shenlibng&quot; [root@192 mytest]# git config --global user.email &quot;782125244@qq.com&quot; [root@192 mytest]# git config --global core.autocrlf false [root@192 mytest]# git config --global core.quotepath off [root@192 mytest]# git config --global gui.encoding utf-8 开启防火墙配置 查看防火墙初始化配置 [root@192 ~]# cat /etc/sysconfig/iptables # Firewall configuration written by system-config-firewall # Manual customization of this file is not recommended. *filter :INPUT ACCEPT [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [0:0] -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -A INPUT -p icmp -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT -A INPUT -j REJECT --reject-with icmp-host-prohibited -A FORWARD -j REJECT --reject-with icmp-host-prohibited COMMIT 开放Tomcat端口 重启生效防火墙 [root@192 ~]# service iptables restart iptables：将链设置为政策 ACCEPT：filter [确定] iptables：清除防火墙规则： [确定] iptables：正在卸载模块： [确定] iptables：应用防火墙规则： [确定] 查看防火墙状态 [root@192 ~]# service iptables status 表格：filter Chain INPUT (policy ACCEPT) num target prot opt source destination 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8080 6 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain FORWARD (policy ACCEPT) num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain OUTPUT (policy ACCEPT) num target prot opt source destination]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>vsftpd</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh无密登录_集群分发脚本xsync]]></title>
    <url>%2F2019%2F02%2F18%2Fssh-wu-mi-deng-lu-ji-qun-fen-fa-jiao-ben-xsync%2F</url>
    <content type="text"><![CDATA[1、ssh免密登录 ssh ip地址 [root@192 ~]# ssh 192.168.1.102 root@192.168.1.102&#39;s password: Last login: Mon Feb 18 20:40:28 2019 from 192.168.1.101 免密登录配置 生成公钥和私钥 [root@192 ~]# ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: d4:95:6c:a8:21:9b:27:62:79:43:76:e8:4b:32:6c:fe root@192.168.1.101 The key&#39;s randomart image is: +--[ RSA 2048]----+ | . o.. | | = o...+ | | . = =.o.. | | O O.o | | + * =S | | . . | | . | | E | | | +-----------------+ [root@192 ~]# ls /root/.ssh/ id_rsa id_rsa.pub 将公钥拷贝到要免密登录的目标机器上 .ssh文件夹下（~/.ssh）的文件功能解释（1）known_hosts ：记录ssh访问过计算机的公钥(public key)（2）id_rsa ：生成的私钥（3）id_rsa.pub ：生成的公钥（4）authorized_keys ：存放授权过得无密登录服务器公钥 [root@192 ~]# hostname 192.168.1.101 [root@192 ~]# ssh-copy-id 192.168.1.102 The authenticity of host &#39;192.168.1.102 (192.168.1.102)&#39; can&#39;t be established. RSA key fingerprint is 56:57:4c:81:94:e0:47:fe:1e:aa:8c:9c:2a:87:a6:dc. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &#39;192.168.1.102&#39; (RSA) to the list of known hosts. root@192.168.1.102&#39;s password: Now try logging into the machine, with &quot;ssh &#39;192.168.1.102&#39;&quot;, and check in: .ssh/authorized_keys to make sure we haven&#39;t added extra keys that you weren&#39;t expecting. [root@192 ~]# ls /root/.ssh/ id_rsa id_rsa.pub known_hosts [root@192 ~]# ssh 192.168.1.102 Last login: Mon Feb 18 22:50:53 2019 from 192.168.1.101 [root@192 ~]# ls /root/.ssh/ authorized_keys 2、集群分发脚本xsync 服务器与服务器数据拷贝 rsync和scp区别：用rsync做文件的复制要比scp的速度快，rsync只对差异文件做更新。scp是把所有文件都复制过去。 scp [root@192 ~]# scp -r /tmp/1.txt root@192.168.1.102:/tmp/ 1.txt rsync 选项 功能-r 递归-v 显示复制过程-l 拷贝符号连接 [root@192 ~]# rsync -rvl /tmp/2.txt root@192.168.1.102:/tmp/ sending incremental file list 2.txt sent 84 bytes received 31 bytes 76.67 bytes/sec total size is 13 speedup is 0.11 集群分发脚本xsync [root@192 ~]# mkdir bin [root@192 ~]# cd bin/ [root@192 bin]# touch xsync [root@192 bin]# vim xsync [root@192 bin]# chmod 777 xsync #!/bin/bash #1 获取输入参数个数，如果没有参数，直接退出 pcount=$# if((pcount==0)); then echo no args; exit; fi #2 获取文件名称 p1=$1 fname=`basename $p1` echo fname=$fname #3 获取上级目录到绝对路径 pdir=`cd -P $(dirname $p1); pwd` echo pdir=$pdir #4 获取当前用户名称 user=`whoami` #5 循环 for((host=102; host]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
        <tag>scp</tag>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机配置静态ip]]></title>
    <url>%2F2019%2F02%2F15%2Fxu-ni-ji-pei-zhi-jing-tai-ip%2F</url>
    <content type="text"><![CDATA[镜像下载链接 https://wiki.centos.org/Download 环境：CentOS-6.8-x86_64-bin-DVD1.iso 1、克隆虚拟机 修改主机名 [root@192 桌面]# vim /etc/sysconfig/network NETWORKING=yes HOSTNAME=192.168.1.104 修改网卡信息 [root@192 桌面]# vim /etc/udev/rules.d/70-persistent-net.rules删除或者注释eth0该行；将eth1修改为eth0，同时复制物理ip地址00:0c:29:ac:81:e4 # This file was automatically generated by the /lib/udev/write_net_rules # program, run by the persistent-net-generator.rules rules file. # # You can modify it, as long as you keep each rule on a single # line, and change only the value of the NAME= key. # PCI device 0x8086:0x100f (e1000) #SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR{address}==&quot;00:0c:29:00:88:b3&quot;, ATTR{type}==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot; # PCI device 0x8086:0x100f (e1000) SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR{address}==&quot;00:0c:29:ac:81:e4&quot;, ATTR{type}==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot; [root@192 桌面]# 更新物理ip地址HWADDR=00:0c:29:ac:81:e4 [root@192 桌面]# vim /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 HWADDR=00:0c:29:ac:81:e4 TYPE=Ethernet UUID=55735d7f-16c6-46fe-9db8-f7d484b3e7c0 ONBOOT=none NM_CONTROLLED=yes BOOTPROTO=dhcp 2、NAT模式配置 编辑–虚拟网络编辑器 配置静态ip网段和子网掩码 NAT设置 网关ip不能和vmnet8的ip地址冲突 宿主机上的vmnet8网卡会自动分配ip 3、配置静态ip ONBOOT=yes系统启动时激活网卡BOOTPROTO=static通过指定方式的办法来获得地址，设置为静态手动配置IPADDR=192.168.1.104主机ip地址GATEWAY=192.168.1.2网关NETMASK=255.255.255.0子网掩码DNS1=8.8.8.8配置DNS域名解析访问互联网DNS2=8.8.4.4 DEVICE=eth0 HWADDR=00:0c:29:ac:81:e4 TYPE=Ethernet UUID=55735d7f-16c6-46fe-9db8-f7d484b3e7c0 ONBOOT=yes NM_CONTROLLED=yes BOOTPROTO=static IPADDR=192.168.1.104 GATEWAY=192.168.1.2 NETMASK=255.255.255.0 DNS1=8.8.8.8 DNS2=8.8.4.4]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring定时任务_文件上传进度条]]></title>
    <url>%2F2019%2F01%2F30%2Fspring-ding-shi-ren-wu-wen-jian-shang-chuan-jin-du-tiao%2F</url>
    <content type="text"><![CDATA[spring定时任务 导依赖 &lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --> &lt;dependency> &lt;groupId>org.quartz-scheduler&lt;/groupId> &lt;artifactId>quartz&lt;/artifactId> &lt;version>2.2.3&lt;/version> &lt;/dependency> 配置定时任务类 package com.atguigu.scw.portal.service; import org.springframework.stereotype.Service; @Service public class ExampleJob { public void hello() { System.out.println("定时任务触发===========>"); } } 配置定时任务 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"> &lt;!-- &lt;bean id="exampleJob" class="com.atguigu.scw.portal.service.ExampleJob">&lt;/bean> --> &lt;!--配置定时任务触发类和方法 --> &lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"> &lt;property name="targetObject" ref="exampleJob" /> &lt;property name="targetMethod" value="hello" /> &lt;/bean> &lt;!--配置触发器，指定何时触发 --> &lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"> &lt;property name="jobDetail" ref="jobDetail" /> &lt;!-- run every morning at 6 AM --> &lt;property name="cronExpression" value="*/5 * * * * ?" /> &lt;/bean> &lt;!--配置定时任务调用哪一个触发器 --> &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"> &lt;property name="triggers"> &lt;list> &lt;ref bean="cronTrigger" /> &lt;/list> &lt;/property> &lt;/bean> &lt;/beans> cron表达式使用 每隔5秒执行一次：*/5 * * * * ? 每隔1分钟执行一次：0 */1 * * * ? 每天23点执行一次：0 0 23 * * ? 每天凌晨1点执行一次：0 0 1 * * ? 每月1号凌晨1点执行一次：0 0 1 1 * ? 每月最后一天23点执行一次：0 0 23 L * ? 每周星期天凌晨1点实行一次：0 0 1 ? * L 在26分、29分、33分执行一次：0 26,29,33 * * * ? 每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ? 参考 https://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#scheduling-quartz 文件上传进度条 ajax异步提交表单$(&quot;#subBtn&quot;).on(&#39;click&#39;, function() { return false}是js对象的机制 &lt;button type=&quot;submit&quot; id=&#39;subBtn&#39; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;点击按钮直接提交是浏览器的机制 文件上传 表单直接提交action=&#39;${ctp}/member/upload&#39; method=&#39;post&#39; enctype=&quot;multipart/form-data&quot; &lt;form action='${ctp}/member/upload' method='post' enctype="multipart/form-data"> &lt;div class="form-group"> &lt;input type="file" class="form-control" id="file" name='file'> &lt;/div> &lt;div class="progress"> &lt;div class="progress-bar" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 60%;"> 60%&lt;/div> &lt;/div> &lt;button type="submit" id='subBtn' class="btn btn-default">Submit&lt;/button> &lt;/form> ajax提交type : &quot;post&quot;,contentType : false,processData : false 进度条:获取myXhr = $.ajaxSettings.xhr()对象并返回 &lt;form id='submitForm'> &lt;div class="form-group"> &lt;input type="file" class="form-control" id="file" name='file'> &lt;/div> &lt;div class="progress" style='display: none;'> &lt;div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%;">0%&lt;/div> &lt;/div> &lt;button type="submit" id='subBtn' class="btn btn-default">Submit&lt;/button> &lt;/form> &lt;script type="text/javascript"> $("#subBtn").on('click', function() { var fd = new FormData($("#submitForm")[0]); $.ajax({ url : "${ctp}/member/upload", data : fd, type : "post", contentType : false, processData : false, //获取ajaxSettings中的xhr对象，为它的upload属性绑定progress事件的处理函数 xhr : function() { myXhr = $.ajaxSettings.xhr() //检查upload属性是否存在 if (myXhr.upload) { //绑定progress事件的回调函数 myXhr.upload.addEventListener('progress', progressHandlingFunction, false) } //xhr对象返回给jQuery使用 return myXhr; }, success : function(result) { console.log("result==========>", result) }, error : function(e) { console.log('e=========>', e) } }) return false }) var progressHandlingFunction = function(e) { var curr = e.loaded var total = e.total process = curr / total * 100 console.log('上传进度============>', process) $('.progress').attr('style', 'display:show;') $('.progress-bar').html(process + '%') $('.progress-bar').attr('style', 'width:' + process + '%;') } &lt;/script> 图片预览 $("#ad_file_input").on('change', function(event) { $(this).empty() $(this).parent('.form-group').next('.form-group').find('.imgdiv').empty() fileList = event.currentTarget.files log('fileList==============>', fileList) var URL = window.URL || window.webkitURL var imgURL //遍历上传的文件进行显示 $.each(fileList, function (index, item) { //创建一个临时的url地址 imgURL = URL.createObjectURL(item) log('this=========>',this) log('item==========>',item) $('#ad_file_input').parent(".form-group").next(".form-group").find(".imgdiv").append("&lt;img src='"+imgURL+"' style='width:200px;height:220px;'/>").append('&lt;p>'+item.name+'&lt;p>') }) })]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多表连接查询]]></title>
    <url>%2F2019%2F01%2F29%2Fduo-biao-lian-he-cha-xun%2F</url>
    <content type="text"><![CDATA[1、查询用户拥有的权限 尚筹网第16天_讨论权限与安全 子查询和连接查询2种，比较推荐连接查询，子查询比较影响性能，子查询看起来比较容易理解，而连接查询需要比较熟悉各个表之间的关系 SELECT DISTINCT p.* FROM t_permission p LEFT JOIN t_role_permission trp ON trp.`permissionid`=p.`id` LEFT JOIN t_role tr ON tr.`id`=trp.`roleid` WHERE tr.id IN( SELECT t_r.id FROM t_role t_r LEFT JOIN t_user_role t_u_r ON t_u_r.`roleid`=t_r.`id` WHERE t_u_r.`userid`=31 ); 子查询不太推荐，比较影响性能 推荐连接查询 SELECT DISTINCT p.* FROM t_permission p LEFT JOIN t_role_permission trp ON trp.`permissionid`=p.`id` LEFT JOIN t_role tr ON tr.`id`=trp.`roleid` LEFT JOIN t_user_role tur ON tur.`roleid`=tr.`id` LEFT JOIN t_user tu ON tu.`id`=tur.`userid` WHERE tu.`id`=31;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpClient远程接口调用_实名认证]]></title>
    <url>%2F2019%2F01%2F28%2Fhttpclient-yuan-cheng-jie-kou-diao-yong-shi-ming-ren-zheng%2F</url>
    <content type="text"><![CDATA[1、HttpClient远程接口调用 1)用户注册 注册按钮button提交表单时，要return false form表单 &lt;!-- action="http://localhost:8082/scw-restapi/member/regist" --> &lt;form class="form-signin" role="form" action="${ctp}/member/regist" method="post" id="regForm"> ... &lt;/form> js提交表单 $("#submitBtn").click(function() { var loginType = $("select.form-control").val(); log("注册类型==============>", loginType) /* if (loginType == "管理") { $("#regForm").submit(); } else { alert("此功能尚未开通"); } */ $("#regForm").submit(); return false }) 2)加载外部资源文件 app.properties restapi.server.ip=127.0.0.1 restapi.server.port=8082 restapi.server.apppath=scw-restapi 编辑springmvc.xml &lt;!-- 引入外部配置文件 --> &lt;context:property-placeholder location="classpath:other/app.properties" /> RestApiServerInfo.java @Controller public class RestApiServerInfo { // MemberService memberService; @Value("${restapi.server.ip}") private String restapiserver; @Value("${restapi.server.port}") private String restapiport; @Value("${restapi.server.apppath}") private String appPath; public String getRestApiURL() { System.out.println("http://" + restapiserver + ":" + restapiport); return "http://" + restapiserver + ":" + restapiport + "/" + appPath; } } 3)HTTPClient工具远程调用接口 导入依赖 &lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --> &lt;dependency> &lt;groupId>org.apache.httpcomponents&lt;/groupId> &lt;artifactId>httpclient&lt;/artifactId> &lt;version>4.5.3&lt;/version> &lt;/dependency> 发送post请求 public static String httpPostRequest(String url, Map&lt;String, Object&gt; params) 工具类HttpClientUtil.java package com.atguigu.project; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.net.URISyntaxException; import java.util.ArrayList; import java.util.Map; import org.apache.http.HttpEntity; import org.apache.http.NameValuePair; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.client.methods.HttpRequestBase; import org.apache.http.client.utils.URIBuilder; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.impl.conn.PoolingHttpClientConnectionManager; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; /** * @author Nan 2015-11 */ public class HttpClientUtil { private static PoolingHttpClientConnectionManager cm; private static String EMPTY_STR = ""; private static String UTF_8 = "UTF-8"; private static void init() { if (cm == null) { cm = new PoolingHttpClientConnectionManager(); cm.setMaxTotal(50);// 整个连接池最大连接数 cm.setDefaultMaxPerRoute(5);// 每路由最大连接数，默认值是2 } } /** * 通过连接池获取HttpClient * * @return */ private static CloseableHttpClient getHttpClient() { init(); return HttpClients.custom().setConnectionManager(cm).build(); } /** * @param url * @return */ public static String httpGetRequest(String url) { HttpGet httpGet = new HttpGet(url); return getResult(httpGet); } public static String httpGetRequest(String url, Map&lt;String, Object> params) throws URISyntaxException { URIBuilder ub = new URIBuilder(); ub.setPath(url); ArrayList&lt;NameValuePair> pairs = covertParams2NVPS(params); ub.setParameters(pairs); HttpGet httpGet = new HttpGet(ub.build()); return getResult(httpGet); } public static String httpGetRequest(String url, Map&lt;String, Object> headers, Map&lt;String, Object> params) throws URISyntaxException { URIBuilder ub = new URIBuilder(); ub.setPath(url); ArrayList&lt;NameValuePair> pairs = covertParams2NVPS(params); ub.setParameters(pairs); HttpGet httpGet = new HttpGet(ub.build()); for (Map.Entry&lt;String, Object> param : headers.entrySet()) { httpGet.addHeader(param.getKey(), String.valueOf(param.getValue())); } return getResult(httpGet); } public static String httpPostRequest(String url) { HttpPost httpPost = new HttpPost(url); return getResult(httpPost); } public static String httpPostRequest(String url, Map&lt;String, Object> params) throws UnsupportedEncodingException { HttpPost httpPost = new HttpPost(url); ArrayList&lt;NameValuePair> pairs = covertParams2NVPS(params); httpPost.setEntity(new UrlEncodedFormEntity(pairs, UTF_8)); return getResult(httpPost); } public static String httpPostRequest(String url, Map&lt;String, Object> headers, Map&lt;String, Object> params) throws UnsupportedEncodingException { HttpPost httpPost = new HttpPost(url); for (Map.Entry&lt;String, Object> param : headers.entrySet()) { httpPost.addHeader(param.getKey(), String.valueOf(param.getValue())); } ArrayList&lt;NameValuePair> pairs = covertParams2NVPS(params); httpPost.setEntity(new UrlEncodedFormEntity(pairs, UTF_8)); return getResult(httpPost); } private static ArrayList&lt;NameValuePair> covertParams2NVPS(Map&lt;String, Object> params) { ArrayList&lt;NameValuePair> pairs = new ArrayList&lt;NameValuePair>(); for (Map.Entry&lt;String, Object> param : params.entrySet()) { pairs.add(new BasicNameValuePair(param.getKey(), String.valueOf(param.getValue()))); } return pairs; } /** * 处理Http请求 * * @param request * @return */ private static String getResult(HttpRequestBase request) { // CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpClient httpClient = getHttpClient(); try { CloseableHttpResponse response = httpClient.execute(request); // response.getStatusLine().getStatusCode(); HttpEntity entity = response.getEntity(); if (entity != null) { // long len = entity.getContentLength();// -1 表示长度未知 String result = EntityUtils.toString(entity); response.close(); // httpClient.close(); return result; } } catch (ClientProtocolException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { } return EMPTY_STR; } } 远程接口返回ScwReturn&lt;T&gt;封装对象 package com.atguigu.scw.restapi.bean; import java.util.Map; public class ScwReturn&lt;T> { private int code;// 状态码 1：表示成功 0:表示失败 private String msg;// 要给的提示信息 private T content;// 响应的内容； private Map&lt;String, Object> ext;// 额外的数据 public int getCode() { return code; } public void setCode(int code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public T getContent() { return content; } public void setContent(T content) { this.content = content; } public Map&lt;String, Object> getExt() { return ext; } public void setExt(Map&lt;String, Object> ext) { this.ext = ext; } // 两个快速的成功失败方法 public static &lt;T> ScwReturn&lt;T> success(String msg, T content, Map&lt;String, Object> ext) { ScwReturn&lt;T> t = new ScwReturn&lt;T>(); t.setCode(1); t.setMsg(msg); t.setContent(content); t.setExt(ext); return t; } public static &lt;T> ScwReturn&lt;T> fail(String msg, T content, Map&lt;String, Object> ext) { ScwReturn&lt;T> t = new ScwReturn&lt;T>(); t.setCode(0); t.setMsg(msg); t.setContent(content); t.setExt(ext); return t; } } 注册调用远程接口 发送请求 String response = HttpClientUtil.httpPostRequest(url, params); 远程接口返回的响应字符串转java对象 readValue = new ObjectMapper().readValue(response.getBytes(), new TypeReference&lt;ScwReturn&lt;TMemeber&gt;&gt;() { }); @RequestMapping("/regist") public String regist(TMemeber memeber, Model model) throws Exception { // 需要利用http工具去模拟发调用接口的请求 // http://localhost:8082/scw-restapi/member/regist // &lt;httpclient.version>4.5.3&lt;/httpclient.version> // httpclient使用java代码来模拟发送请求 // 能收到api调用后产生的json数据； // 1、可以将产生的json逆向成对象ScwReturn&lt;TMemeber> // 2、可以直接将json写给页面 System.out.println("memeber===========>" + memeber); // 注册成功以后可以来到一个页面； // 1、应该去发送请求来进行注册；java代码发请求 String url = serverInfo.getRestApiURL() + "/member/regist"; System.out.println("url===========>" + url); // 2、构建请求参数 Map&lt;String, Object> params = new HashMap&lt;String, Object>(); params.put("loginacct", memeber.getLoginacct()); // 密码是业务逻辑加密的，我们不用管 params.put("userpswd", memeber.getUserpswd()); params.put("email", memeber.getEmail()); // 响应内容； String response = HttpClientUtil.httpPostRequest(url, params); // 封装响应为对象 ScwReturn&lt;TMemeber> readValue = null; readValue = new ObjectMapper().readValue(response.getBytes(), new TypeReference&lt;ScwReturn&lt;TMemeber>>() { }); // 判断，注册成功！来到登陆页面 if (readValue.getCode() == 1) { return "redirect:/login.jsp"; } else { // 注册失败！来到注册页面进行回显 model.addAttribute("msg", "用户名和邮箱已经被注册了！"); return "forward:/reg.jsp"; } } 远程接口注册方法 控制层 /** * ScwReturn&lt;List&lt;TMemeber>>:泛型是content内容的对象的类型 * * @Description (TODO这里用一句话描述这个方法的作用) * @param memeber * @return */ @RequestMapping("/regist") public ScwReturn&lt;TMemeber> regist(TMemeber memeber) { // 创建一个空的对象 TMemeber regist = new TMemeber(); Map&lt;String, Object> hashMap = new HashMap&lt;>(); try { regist = memberService.regist(memeber); } catch (Exception e) { // 判断异常类型来放错误 // e.printStackTrace(); hashMap.put("error", "触犯唯一约束，请保证用户名和邮箱唯一"); } regist.setUserpswd(""); if (regist.getId() != null) { return ScwReturn.success("用户注册成功！", regist, null); } else { return ScwReturn.fail("用户注册失败!", null, hashMap); } } 业务层 带条件插入 int i = memeberMapper.insertSelective(tMemeber); @Override public TMemeber regist(TMemeber tMemeber) { // TODO Auto-generated method stub String digest = MD5Util.digest(tMemeber.getUserpswd()); // 加密密码保存 tMemeber.setUserpswd(digest); // 初始化用户名和账号 tMemeber.setUsername(tMemeber.getLoginacct()); // 实名认证状态 0:未实名认证 1::实名认证 tMemeber.setAuthstatus("0"); // 真实姓名；实名认证是保存的 tMemeber.setRealname("未实名"); // 0：普通会员 1：月费会员 2：年费会员 3： tMemeber.setUsertype("0"); // 身份证号，账户类型；（实名认证是做的） // 账户类型：直接保存账户的全名 int i = memeberMapper.insertSelective(tMemeber); // 刚才就是按照这个对象给数据库插入值，希望获取到数据库分配的自增主键 return tMemeber; } 2、实名认证文件上传 1)上传用户资质证件 导入依赖 &lt;dependency> &lt;groupId>commons-fileupload&lt;/groupId> &lt;artifactId>commons-fileupload&lt;/artifactId> &lt;version>1.3.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>commons-io&lt;/groupId> &lt;artifactId>commons-io&lt;/artifactId> &lt;version>2.5&lt;/version> &lt;/dependency> 编辑springmvc.xml文件 &lt;!-- 1、文件上传需要一个文件上传解析器 --> &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"> &lt;property name="defaultEncoding" value="utf-8">&lt;/property> &lt;/bean> 前台ajax提交 带有文件表单，一次提交所有项 var fd = new FormData($(&quot;#certForm&quot;)[0]) 带有文件表单,提交部分内容 //使用formData（js对象来包装form表单） var fd = new FormData(); log($(&quot;#ad_name_input&quot;).val()) log($(&quot;#ad_file_input&quot;)[0].files[0]) fd.append(&quot;name&quot;, $(&quot;#ad_name_input&quot;).val()); fd.append(&quot;ad&quot;, $(&quot;#ad_file_input&quot;)[0].files[0]) processData(默认: true) 默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。 contentType 不使用默认的内容类型；(默认: “application/x-www-form-urlencoded”) 发送信息至服务器时内容编码类型。 //这是一个资质文件上传的页面 //发送文件上传资质文件请求； var fd = new FormData($("#certForm")[0]); $.ajax({ url:"http://localhost:8082/scw-restapi/auth/upload", data:fd, type:"post", contentType:false, dataType:"json", processData:false, success:function(result){ //来到邮箱填写页面 location.href="${ctp}/auth/apply-2.html" }, error:function(e){ layer.msg("上传失败:"+e); } }); 控制层 //文件上传 private String uploadfile(String webPath,MultipartFile file,HttpSession session){ ServletContext context = session.getServletContext(); String realPath = context.getRealPath(webPath); String name = UUID.randomUUID().toString().replace("-", "").substring(0, 10) +"_file_"+ file.getOriginalFilename(); try { //webPath不存在的情况下必须创建 File file2 = new File(realPath); if(!file2.exists()){ //创建目录 file2.mkdirs(); } file.transferTo(new File(realPath+"/"+name)); //返回这个图片在服务器下的路径 return webPath+"/"+name; }catch (Exception e) { return null; } } @RequestMapping("/upload") public ScwReturn&lt;Object> upload(HttpSession session, @RequestParam("file")MultipartFile[] file, @RequestParam("certid")Integer[] certid,@RequestParam("memberid")Integer memberid){ try { System.out.println("资质的id"+certid); List&lt;TMemberCert> certsList= new ArrayList&lt;TMemberCert>(); for (int i=0;i&lt;certid.length;i++) { TMemberCert cert = new TMemberCert(); MultipartFile multipartFile = file[i]; String uploadfile = uploadfile("/certsimg", multipartFile, session); cert.setCertid(certid[i]); cert.setMemberid(memberid); cert.setIconpath(uploadfile); certsList.add(cert); } //调用业务逻辑进行保存;/删除原有资质，保存新的资质 certService.insertCerts(certsList); } catch (Exception e) { // TODO Auto-generated catch block System.out.println(e); return ScwReturn.fail("资质保存失败！", null, null); } return ScwReturn.success("保存成功！", null, null); } 2)批量插入用户资质证件描述信息 业务层 CertService.java public void insertCerts(List&lt;TMemberCert> certsList); CertServiceImpl.java @Override public void insertCerts(List&lt;TMemberCert> certsList) { // TODO Auto-generated method stub TMemberCertExample example = new TMemberCertExample(); Criteria criteria = example.createCriteria(); criteria.andMemberidEqualTo(certsList.get(0).getMemberid()); //先删除 memberCertMapper.deleteByExample(example); //后保存 certMapper.insertBatch(certsList); } dao层 TCertMapper.java void insertBatch(@Param("certs")List&lt;TMemberCert> certsList); TCertMapper.xml &lt;!-- void insertBatch(@Param("certs")List&lt;TMemberCert> certsList); --> &lt;insert id="insertBatch"> INSERT INTO t_member_cert(memberid,certid,iconpath) VALUES &lt;foreach collection="certs" item="c" separator=","> (#{c.memberid},#{c.certid},#{c.iconpath}) &lt;/foreach> &lt;/insert>]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>HTTPClient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术分享]]></title>
    <url>%2F2019%2F01%2F26%2Fji-zhu-fen-xiang%2F</url>
    <content type="text"><![CDATA[1、快速深入地学习一个新技术、知识点步骤 1）我们有一个需求 项目开发时，我们需要解决某个问题—页面局部刷新问题 跳槽，学习新技术 2）先看看使用现有的技术能否解决这个问题 可以解决，使用传统的方法iframe 发现使用传统的方法可以解决，但是不够好，使用新技术ajax 3）学习新技术或者知识点 原理 基本语法 4）快速入门案例 特点是简单 了解新技术或者知识点的基本使用，这里不需要涉及技术细节 5）讨论这个新技术或者知识点的细节 怎么使用更规范 使用该技术有没有什么陷阱 需要使用时，注意些什么 2、学习方法的介绍 1）高效而愉快地学习 2）先建立一个整体框架，然后细节 3）在实际工作中，要培养用到什么，能够快速学习什么的能力 4）先know how，再know why 5）软件编程是一门’做中学‘的学科，不是会了再做，而是做了才会 6）适当的囫囵吞枣 7）学习软件编程是在在琢磨别人怎么做，而不是我认为应该怎么做的过程 for i:=0;i&lt;10;i++ { fmt.Println(&quot;hello,world&quot;) }]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6异步]]></title>
    <url>%2F2019%2F01%2F25%2Fes6-yi-bu%2F</url>
    <content type="text"><![CDATA[1、promise-解决异步操作 同步——串行 简单、方便 异步——并发 性能高、体验好 jQuery异步问题：回到地狱 $.ajax({ url: '/banner_data', success(banners){ $.ajax({ url: '/user_data', success(user){ $.ajax({ url: '/item_data', success(items){ $.ajax({ url: '/news_data', success(news){ }, error(){ alert('数据获取失败'); } }) }, error(){ alert('数据获取失败'); } }) }, error(){ alert('数据获取失败'); } }) }, error(){ alert('数据获取失败'); } }) 使用Promise Promise.all() 与：所有的都成功 Promise.race() 或：只要有一个完成 //Promise Promise.all([ $.ajax('/banner_data'), $.ajax('/item_data'), $.ajax('/user_data'), $.ajax('/news_data'), ]).then(arr=>{ let [banners, items, user, news]=arr; }, ()=>{}) 1.txt {&quot;a&quot;: 3, &quot;b&quot;: 5} 2.txt [12,5,8,3] 3.txt {&quot;name&quot;: &quot;blue&quot;, &quot;age&quot;: 18} promise怎么用.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script src="jquery.js" charset="utf-8">&lt;/script> &lt;script> let p = new Promise((resolve, reject) => { //resolve 解决->成功 //reject 拒绝->失败 $.ajax({ url: '1.txt', dataType: 'json', success(json) { resolve(json) }, error(err) { reject(err) } }) }) debugger p.then(json => { alert('成功') console.log(json) }, err => { alert('失败') }) &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> promise怎么用2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script src="jquery.js" charset="utf-8">&lt;/script> &lt;script> let p = new Promise((resolve, reject) => { //resolve 解决->成功 //reject 拒绝->失败 $.ajax({ url: '1.txt', dataType: 'json', success(json) { resolve(json) }, error(err) { reject(err) } }) }) let p2 = new Promise((resolve, reject) => { //resolve 解决->成功 //reject 拒绝->失败 $.ajax({ url: '2.txt', dataType: 'json', success(json) { resolve(json) }, error(err) { reject(err) } }); }); let p3 = new Promise((resolve, reject) => { //resolve 解决->成功 //reject 拒绝->失败 $.ajax({ url: '3.txt', dataType: 'json', success(json) { resolve(json) }, error(err) { reject(err) } }) }) Promise.all([p, p2, p3]).then(arr => { let [j1, a, j2] = arr; alert('成功') console.log(j1, a, j2) }, err => { alert('失败') }) &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> promise怎么用3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script src="jquery.js" charset="utf-8">&lt;/script> &lt;script> $.ajax({ url: '1.txt', dataType: 'json' }).then(json=>{ alert('成了'); }, err=>{ alert('错了'); }); debugger /* Promise.all([p, p2, p3]).then(arr=>{ let [j1, a, j2]=arr; alert('成功'); console.log(j1, a, j2); }, err=>{ alert('失败'); }); */ &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> promise怎么用4.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script src="jquery.js" charset="utf-8">&lt;/script> &lt;script> Promise.all([ $.ajax({url: '1.txt', dataType: 'json'}), $.ajax({url: '2.txt', dataType: 'json'}), $.ajax({url: '3.txt', dataType: 'json'}), ]).then(arr=>{ let [j1, a, j2]=arr; console.log(j1, a, j2); }, err=>{ alert('失败'); }); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 结论 Proimse有用——解除异步操作 Promise有局限——带逻辑的异步操作麻烦 2、generator-生成器（过渡） 可以暂停 generator函数.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> function* show() { alert('aaa') yield alert('bbb') } let gen = show() gen.next() //aaa setTimeout(function() { gen.next() //bbb }, 5000) &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> generator函数3.html 传参 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> function *show(){ alert('aaa'); let a=yield; alert('bbb'+a); } let gen=show(); gen.next(); gen.next(12); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> generator函数4.html 返回值 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> function* show() { alert('aaa') yield 55 alert('bbb') return 89 } let gen = show() let res1 = gen.next() // debugger console.log(res1) //{value: 55, done: false} let res2 = gen.next() console.log(res2) //{value: 89, done: true} &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 3、async/await（推荐，es7） 可以暂停且可以处理带业务逻辑、异常 async和await.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> function sleep(sec) { return new Promise((resolve, reject) => { setTimeout(function() { resolve() }, sec * 1000) }) } async function show() { alert('a') await sleep(1) alert('b') await sleep(2) alert('c') } show() &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 处理带业务逻辑 async和await2.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script src="jquery.js" charset="utf-8">&lt;/script> &lt;script> (async () => { let data1 = await $.ajax({ url: '1.txt', dataType: 'json' }) console.log('data1=========>', data1) if (data1.a + data1.b &lt; 10) { let data2 = await $.ajax({ url: '2.txt', dataType: 'json' }) alert(data2[0]) } else { let data3 = await $.ajax({ url: '3.txt', dataType: 'json' }) alert(data3.name) } })() &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 处理异常 async和await3.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script src="jquery.js" charset="utf-8">&lt;/script> &lt;script> async function show() { try { let data1 = await $.ajax({ url: '1.txt', dataType: 'json' }) let data2 = await $.ajax({ url: '33.txt', dataType: 'json' }) let data3 = await $.ajax({ url: '3.txt', dataType: 'json' }) console.log(data1, data2, data3) } catch (e) { alert('有问题') throw new Error('我错了....') } } show() &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2F2019%2F01%2F23%2Fhexo%2F</url>
    <content type="text"><![CDATA[安装Node.jshttps://nodejs.org/en/ 安装Githttps://git-scm.com/ 安装Hexo //全局安装 $ npm install -g hexo-cli 存放位置 C:\Users\libingshen\AppData\Roaming\npm\node_modules 验证安装是否成功 C:\Users\libingshen&gt;node --version v10.15.0 C:\Users\libingshen&gt;npm --version 6.4.1 C:\Users\libingshen&gt;git --version git version 2.16.2.windows.1 C:\Users\libingshen&gt;hexo --version hexo-cli: 1.1.0 os: Windows_NT 10.0.17134 win32 x64 http_parser: 2.8.0 node: 10.15.0 v8: 6.8.275.32-node.45 uv: 1.23.2 zlib: 1.2.11 ares: 1.15.0 modules: 64 nghttp2: 1.34.0 napi: 3 openssl: 1.1.0j icu: 62.1 unicode: 11.0 cldr: 33.1 tz: 2018e Hexo博客初始化 $ cd D:\mytest\myhexo $ hexo init //安装依赖 $ npm install //或者hexo generate生成静态页 $ hexo g //或者hexo server，启动服务器，可以在http://localhost:4000/ 查看 $ hexo s Hexo博客部署到GitHub本地客户端与GitHub建立授权连接生成公私钥 ssh-keygen -t rsa -C &quot;782125244@qq.com&quot; 公私钥存放位置 C:\Users\libingshen\.ssh 将公钥内容上传到GitHub GitHub创建仓库作为hexo博客的站点hexo配置GitHub连接安装 hexo-deployer-git $ npm install hexo-deployer-git --save 修改配置D:\mytest\myhexo_config.yml #配置GitHub博客站址访问路径 # URL这里要是没有配置，GitHub样式显示不出来 ## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39; url: https://shenlibing.github.io/myhexo/ root: /myhexo permalink: :year/:month/:day/:title/ permalink_defaults: #博客推送到GitHub地址配置 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/shenlibing/myhexo.git branch: [master] 配置GitHub Pages![](https://raw.githubusercontent.com/shenlibing/blogphoto/master/source/配置GitHub page.png) 备份博客源文件hexo部署到GitHub只上传.deploy_git文件夹的内容，并不会上传_posts文件夹下的博客源文件 D:\mytest\myhexo\.deploy_git D:\mytest\myhexo\source\_posts 解决： 将_posts文件夹作为git仓库，上传到GitHub，使得其作为另一个分支 创建并切换到新分支 libingshen@DESKTOP-7V287SK MINGW64 /d/mytest/myhexo/source/_posts (master) $ git checkout -b src Switched to a new branch &#39;src&#39; 将新分支推送到GitHub git add . git commit -m &#39;add_v1:-新增hello-world笔记初始化&#39; git push origin src 将博客源文件分支设为推送的默认分支，git push推送直接推送到src分支 补充： 删除本地分支 $ git branch -d src删除远程分支 $ git push origin -d src切换分支 $ git checkout master查看提交日志 $ git log --oneline 拓展更换hexo主题下载 https://github.com/theme-next/hexo-theme-next 解压放到D:\mytest\myhexo\themes 修改D:\mytest\myhexo\_config.yml配置文件 # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: hexo-theme-next-master 修改站点语言编辑D:\mytest\myhexo\_config.yml文件 # Site title: 小兵兵 subtitle: description: keywords: author: shenlibing language: zh-CN timezone: 开启搜索、字数统计和阅读时长统计安装依赖hexo-symbols-count-time、hexo-generator-searchdb，安装依赖不成功时先删除D:\mytest\myhexo\node_modules文件夹，重新安装依赖 npm install hexo-symbols-count-time --save npm install hexo-generator-searchdb --save 配置主题样式文件 进入D:\mytest\myhexo\themes\hexo-theme-next-master\文件夹，编辑_config.yml文件 # Local search # Dependencies: https://github.com/theme-next/hexo-generator-searchdb local_search: enable: true # Dependencies: https://github.com/theme-next/hexo-symbols-count-time symbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 配置站点文件 编辑D:\mytest\myhexo\_config.yml文件 #阅读时长和本文字数 symbols_count_time: symbols: true time: true total_symbols: true total_time: true #搜索功能 search: path: search.xml field: post format: html limit: 10000 添加分类和标签 $ hexo new page categories $ hexo new page tags 编辑D:\mytest\myhexo\source\categories\index.md --- title: categories date: 2019-01-22 16:37:58 type: &quot;categories&quot; #这部分是新添加的 --- 编辑D:\mytest\myhexo\source\tags\index.md --- title: tags date: 2019-01-22 16:38:40 type: &quot;tags&quot; #新添加的内容 --- 修改菜单，添加categories和tags到menu中 menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 新增文章，添加categories、tags --- title: hexo博客搭建 date: 2019-01-23 09:07:30 categories: 日常记录 tags: - hexo - git - github - node - markdown --- 更换页面菜单布局位置 # Schemes #scheme: Muse #scheme: Mist scheme: Pisces #scheme: Gemini 配置文章浏览量注册 https://leancloud.cn/ 创建应用 创建Class 配置web安全域名 获取app_id、app_key 编辑D:\mytest\myhexo\themes\hexo-theme-next-master\_config.yml配置文件，填app_id、 app_key;security设置为false # Show number of visitors to each article. # You can visit https://leancloud.cn get AppID and AppKey. leancloud_visitors: enable: true app_id: BedsOkBLOBR4nM4W52xTcBhb-gzGzoHsz #&lt;app_id&gt; app_key: EEaRfb6dCMaS38laDCkSYhM9 #&lt;app_key&gt; # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don&#39;t care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: false betterPerformance: false 插入本地图片安装依赖 npm install hexo-asset-image --save 编辑D:\mytest\myhexo\_config.yml配置文件 post_asset_folder: true 命令hexo new post test来生成博文时，/source/_post文件夹中除了test.md外，还有一个同名test文件夹 typora插入本地图片typora设置文件–偏好设置–图片插入 编辑–图片工具–设置图片根目录 typora-root-url: hexo/设置动态背景进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\文件夹，编辑_layout.swig文件，在&lt;/body&gt;之前添加 &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 添加Fork me on GitHub进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\文件夹，编辑_layout.swig文件，在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面添加选择的图标样式代码 &lt;a href=&quot;https://github.com/shenlibing/&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}&lt;/style&gt; 添加友情链接方式一进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\_partials文件夹，在footer.swig文件末尾追加 &lt;div&gt;友情链接： &lt;a class=&quot;theme-link&quot; href=&quot;http://collect.w3ctrain.com/&quot;&gt; 前端收藏夹 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;http://www.alloyteam.com/nav/&quot;&gt; Web前端导航 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;http://www.runoob.com/&quot;&gt; 菜鸟教程 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;https://mccxj.github.io/&quot;&gt; 小毛的胡思乱想 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/div&gt; 方式二进入D:\mytest\myhexo\themes\hexo-theme-next-master文件夹，编辑_config.yml文件 # Blog rolls links_icon: link links_title: Links links_layout: block #links_layout: inline #links: #Title: http://example.com links: 美团技术团队: https://tech.meituan.com/ 百度FEX: http://fex.baidu.com/ 淘宝FED: http://taobaofed.org/ 设置阅读全文进入D:\mytest\myhexo\themes\hexo-theme-next-master文件夹，编辑_config.yml文件 # Automatically Excerpt. Not recommend. # Use &lt;!-- more --&gt; in the post to control excerpt accurately. auto_excerpt: enable: true length: 150 常见错误错误一： 故障现象：xml转移错误，导致搜索不出结果 故障原因： 解决： 参考：【持续更新】Github Pages + Hexo 博客搭建，Next主题个性化修改 Hexo+NexT 打造一个炫酷博客 hexo史上最全搭建教程 用 Typora 写 Hexo 博客 | zhangnew 使用Typora+Hexo+Google Drive打造自己的云笔记 | 情起·而深 我的云端硬盘 - Google 云端硬盘]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化点击事件绑定]]></title>
    <url>%2F2019%2F01%2F15%2Fyou-hua-dian-ji-shi-jian-bang-ding%2F</url>
    <content type="text"><![CDATA[1、优化点击事件绑定 &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Title&lt;/title> &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js">&lt;/script> &lt;/head> &lt;body> &lt;button data-action="id1">新增按钮1&lt;/button> &lt;button data-action="id2">删除按钮2&lt;/button> &lt;button data-action="id3">按钮3&lt;/button> &lt;button data-action="id4">按钮4&lt;/button> &lt;script> var log = function () { console.log.apply(console, arguments) } var actionList = { 'id1': function () { alert('id1=============>') }, 'id2': function () { alert('id2===============>') }, 'id3': function () { alert('id3===============>') }, 'id4': function () { alert('id4===============>') } } let $body = $('body') $body.on('click', '[data-action]', function () { //jQuery获取html标签自定义属性值或data值 let action_name = $(this).data('action') let action = actionList[action_name] // log(action) // log($.isFunction(action)) if ($.isFunction(action)) { action() } }) //页面需要新增一个按钮，做扩展 $body.append('&lt;button data-action="id5">按钮5&lt;/button>') $.extend(actionList, { 'id5': function () { alert('id5============>') } }) &lt;/script> &lt;/body> &lt;/html> 参考 https://github.com/cssmagic/blog/issues/48]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户分配角色_角色维护权限树]]></title>
    <url>%2F2019%2F01%2F14%2Fyong-hu-fen-pei-jiao-se-jiao-se-wei-hu-quan-xian-shu%2F</url>
    <content type="text"><![CDATA[1、用户分配角色 效果图： 实现思路： 1）先静态实现页面 2）从数据库查询用户未分配角色和已分配角色，前端初始化该列表 3）添加、移除用户拥有的角色 前端： 1)左移、右移：append和appendTo的使用 $(&quot;.unroles :selected&quot;).appendTo(&quot;.roles_select&quot;) 2）遍历选中的角色 //遍历选中的元素,拼接用户角色id $(&#39;.unroles :selected&#39;).each(function() { log(this) rids += $(this).val() + &#39;,&#39; }) 3)ajax发送异步请求（参数拼接：用户id,角色rids） uid = &#39;${param.uid}&#39; url = &#39;${ctp}/permission/user/assignrole?opt=remove&amp;uid=&#39; + uid + &#39;&amp;rids=&#39; + rids + &#39;&#39; //发送请求移除 $.get(url, fnf) &lt;div class="panel panel-default"> &lt;div class="panel-body"> &lt;form role="form" class="form-inline"> &lt;div class="form-group"> &lt;label for="exampleInputPassword1">未分配角色列表&lt;/label>&lt;br> &lt;select class="form-control unroles" multiple size="10" style="width: 100px; overflow-y: auto;"> &lt;c:forEach items="${list_user_unrole}" var="user_unrole"> &lt;option value="${user_unrole.id}">${user_unrole.name}&lt;/option> &lt;/c:forEach> &lt;/select> &lt;/div> &lt;div class="form-group"> &lt;ul> &lt;li class="btn btn-default glyphicon glyphicon-chevron-right">&lt;/li> &lt;br> &lt;li class="btn btn-default glyphicon glyphicon-chevron-left" style="margin-top: 20px;">&lt;/li> &lt;/ul> &lt;/div> &lt;div class="form-group" style="margin-left: 40px;"> &lt;label for="exampleInputPassword1">已分配角色列表&lt;/label>&lt;br> &lt;select class="form-control roles_select" multiple size="10" style="width: 100px; overflow-y: auto;"> &lt;c:forEach items="${list_user_role}" var="user_role"> &lt;option value="${user_role.id}">${user_role.name}&lt;/option> &lt;/c:forEach> &lt;/select> &lt;/div> &lt;/form> &lt;/div> &lt;/div> &lt;script type="text/javascript"> $(function() { $(".list-group-item").click(function() { if ($(this).find("ul")) { $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) { $("ul", this).hide("fast"); } else { $("ul", this).show("fast"); } } }); }); //页面加载完成执行 $(function() { addUserRoleEvent() removeUserRoleEvent() }) //用户添加角色事件 var addUserRoleEvent = function() { $('.glyphicon-chevron-right').click( function() { log('向右移动=============>') var uid = '' var rids = '' //遍历选中的元素,拼接用户角色id $('.unroles :selected').each(function() { log(this) rids += $(this).val() + ',' }) rids = rids.substring(0, rids.length - 1) log('用户角色ids==========>', rids) uid = '${param.uid}' url = '${ctp}/permission/user/assignrole?opt=add&amp;uid=' + uid + '&amp;rids=' + rids + '' //选中的得进行处理添加到用户角色表中 //发送请求给当前用户添加这几个角色，必须带上权限id的拼串和userid $.get(url, fns) }) } //用户删除角色事件 var removeUserRoleEvent = function() { $('.glyphicon-chevron-left') .click( function() { log('向左移动=============>') var rids = '' $('.roles_select :selected').each(function() { rids += $(this).val() + ',' }) rids = rids.substring(0, rids.length - 1) log('用户角色ids==========>', rids) uid = '${param.uid}' url = '${ctp}/permission/user/assignrole?opt=remove&amp;uid=' + uid + '&amp;rids=' + rids + '' //发送请求移除 $.get(url, fnf) }) } //异步请求成功的回调函数 var fns = function(data) { log('异步请求成功的回调函数===============>') log('data===========>', data) //$('.roles_select').append($('.unroles :selected')) $(".unroles :selected").appendTo(".roles_select") } //异步请求失败的回调函数 var fnf = function(data) { log('异步请求失败的回调函数===============>') log('data===========>', data) $('.roles_select :selected').appendTo('.unroles') } &lt;/script> 控制层: 1) // 添加移除用户角色 @RequestMapping("/assignrole") @ResponseBody public String userRole(@RequestParam("uid") Integer uid, @RequestParam("rids") String rids, @RequestParam("opt") String opt) { System.out.println("添加移除用户角色==================>"); System.out.println("用户id-----角色ids------类型：添加、移除"); System.out.println(uid); System.out.println(rids); System.out.println(opt); if ("add".equals(opt)) { // 为某个用户添加角色 int i = userRoleService.add(uid, rids); } else if ("remove".equals(opt)) { // 为某个用户删除角色 int i = userRoleService.remove(uid, rids); } return "success"; } @RequestMapping("/toAssignRolePage") public String toAssignRolePage(@RequestParam(value = "uid") Integer uid, Model model) { System.out.println("UserController.toAssignRolePage去分配角色页面=============>"); // 1、查出所有角色 List&lt;TRole> list_role = roleService.getAllRole(); System.out.println("所有角色===========>"); System.out.println(list_role); // 2、查出当前用户拥有的角色 List&lt;TRole> list_user_role = roleService.getUserRole(uid); System.out.println("当前用户的角色==========>"); System.out.println(list_user_role); HashMap&lt;Integer, TRole> map_user_role = new HashMap&lt;>(); for (TRole tRole : list_user_role) { map_user_role.put(tRole.getId(), tRole); } // 3、用户未分配的角色 ArrayList&lt;TRole> list_user_unrole = new ArrayList&lt;>(); for (TRole tRole : list_role) { if (!map_user_role.containsKey(tRole.getId())) { list_user_unrole.add(tRole); } } System.out.println("用户未分配的角色=============>"); System.out.println(list_user_unrole); model.addAttribute("list_user_role", list_user_role); model.addAttribute("list_user_unrole", list_user_unrole); // model.addAttribute("uid", uid); return "manager/permission/assignRole"; } sql: 1)用户表、用户_角色表、角色表3个表多表查询 &lt;resultMap id="BaseResultMap" type="com.atguigu.scw.manager.bean.TRole"> &lt;id column="id" jdbcType="INTEGER" property="id" /> &lt;result column="name" jdbcType="VARCHAR" property="name" /> &lt;/resultMap> &lt;!-- List&lt;TRole> getUserRole(Integer uid); --> &lt;select id="getUserRole" resultMap="BaseResultMap"> SELECT a.* FROM t_role a LEFT JOIN t_user_role b ON a.`id` = b.`roleid` LEFT JOIN t_user c ON b.`userid` = c.`id` WHERE c.`id` = #{uid} &lt;/select> 2、角色维护权限树 效果图： 实现思路： 1）zTree展示权限树，初始化含有复选框的权限树，异步请求控制层（参数：角色rid）查询出角色拥有的权限 2）点击分配权限携带角色rid和权限permission_ids到控制层，先删除角色所拥有的权限，再更加permission_ids更新角色拥有的权限，同步到前端 3）bootstrap模态框–分配权限按钮绑定参数 前端： 1）zTree权限树复选框初始化的时候刚开始使用2次异步请求（一次请求所有权限，一次请求角色拥有的权限），展示数据有点混乱，后来改为一次异步请求同时查询出（所有权限、角色拥有的权限）。 2）bootstrap自定义图标显示不出来 &lt;!-- Modal模态框 --> &lt;div class="modal fade" id="permissModel" tabindex="-1" role="dialog" aria-labelledby="myModalLabel"> &lt;div class="modal-dialog" role="document"> &lt;div class="modal-content"> &lt;div class="modal-header"> &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"> &lt;span aria-hidden="true">&amp;times;&lt;/span> &lt;/button> &lt;h4 class="modal-title" id="myModalLabel">Modal title&lt;/h4> &lt;/div> &lt;div class="modal-body"> &lt;!--展示权限树 --> &lt;ul id="permissionTree" class="ztree">&lt;/ul> &lt;/div> &lt;div class="modal-footer"> &lt;button type="button" class="btn btn-default" data-dismiss="modal">关闭&lt;/button> &lt;button type="button" class="btn btn-primary" id='addPermissionBtn'>分配权限&lt;/button> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;script type="text/javascript"> $(function() { $(".list-group-item").click(function() { if ($(this).find("ul")) { $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) { $("ul", this).hide("fast"); } else { $("ul", this).show("fast"); } } }); }); /* $("tbody .btn-success").click(function() { window.location.href = "assignPermission.html"; }); */ var zTree //设置ajax同步 //$.ajaxSettings.async = false var assignPermissionEvent = function() { $(".assignPermissionModelBtn").click(function() { log('assignPermissionEvent==============>') //获取当前角色id log('当前角色id==========>', $(this).attr('rid')) var rid = $(this).attr('rid') loadModalAndTree(rid) }) } var loadModalAndTree = function(rid) { //模态框设置 var options = { backdrop : 'static', show : true } //手动打开模态框 $('#permissModel').modal(options) //从数据库查出的所有权限节点数据 //发送ajax请求获取到所有权限的json数据 var url = '${ctp}/permission/role/json/' + rid $.getJSON(url, fns) //将角色id保存到模态框的哪个属性中； //打开模态框将角色id传递给model里面的权限分配按钮 log('角色id===========>', rid) $('#addPermissionBtn').attr("rid", rid) } //成功回调函数，刷新权限树 var fns = function(data) { log('成功返回数据', data) log('event==========>', event) var ids = [] $.each(data.listCurrentPermission, function() { ids.push(this.id) }) log('ids===========>', ids) //遍历每一条权限 $.each(data.listPermission, function() { //给每一个节点修改或者添加一些属性 if (this.pid == 0) { this.open = true } if (ids.includes(this.id)) { this.checked = true } }) var setting = { data : { simpleData : { enable : true, idKey : "id", pIdKey : "pid", }, key : { url : "haha" } }, /* view : { addDiyDom : showIcon }, */ check : { enable : true } } zTree = $.fn.zTree.init($("#permissionTree"), setting, data.listPermission) log('zTree赋值完成==========>', zTree) } //用于在节点上固定显示用户自定义控件 //?图标无法正常显示可能是字体样式没有引入进来 var showIcon = function(treeId, treeNode) { log('自定义显示图标==============>') log('treeId===============>', treeId) log('treeNode===============>', treeNode) //#permissionTree_10_ico $("#" + treeNode.tId + "_ico").removeClass() .addClass(treeNode.icon) } //默认勾选当前角色的权限 var checkcurPermisson = function(rid) { var url = '${ctp}/permission/role/curPermission/' + rid $.getJSON(url, fns2) } //获取当前角色权限成功回调函数 var fns2 = function(data) { log('fns2===============>') log('fns2_data================', data) //遍历当前角色拥有的权限 $.each(data, function() { //$(this).attr('id') var node = zTree.getNodesByParam('id', this.id, null) log('使用zTree===========>', zTree) log('当前角色拥有的权限=============>', node) zTree.checkNode(node, true, false) log('是否选中=========>', node.checked) node.nocheck = true //表示显示checkbox }) } //更新权限树 var updateTree = function() { log('更新权限树===========>') var rid = $('#addPermissionBtn').attr("rid") log('角色rid==========>', rid) var permission_ids = '' //1、获取当前我们已经选中的权限 var nodes = zTree.getCheckedNodes(true) log('nodes=============>', nodes) $.each(nodes, function() { permission_ids += this.id + ',' }) var url = '${ctp}/permission/role/update?rid=' + rid + '&amp;permission_ids=' + permission_ids $.get(url, updateTreeFn) } //更新权限树回调函数 var updateTreeFn = function(data) { alert(data) log("权限分配成功===========>"); $('#permissModel').modal("hide"); } var addPermissionBtnEvent = function() { $('#addPermissionBtn').click(function() { log('点击分配权限按钮=============>') updateTree() }) } var __main = function() { assignPermissionEvent() addPermissionBtnEvent() } $(function() { __main() }) &lt;/script> 控制层： //分配权限 @RequestMapping("/update") @ResponseBody public String updateRolePermission(@RequestParam("rid") Integer rid, @RequestParam("permission_ids") String permission_ids) { System.out.println("更新权限==========>"); System.out.println(rid); System.out.println(permission_ids); // 先删除该角色所有权限，在为该用户分配权限 boolean flag = rolePermissionService.updatePermission(rid, permission_ids); return flag ? "success" : "fail"; } @RequestMapping("/curPermission/{id}") @ResponseBody public List&lt;TPermission> getCurrentPermission(@PathVariable("id") Integer rid) { System.out.println("当前角色拥有的权限==============>"); List&lt;TPermission> listPermission = permissionService.getPermissionsById(rid); System.out.println(listPermission); return listPermission; } //查出角色拥有的权限、所有权限 @RequestMapping("/json/{id}") @ResponseBody public HashMap&lt;String, List&lt;TPermission>> getAllPermission(@PathVariable("id") Integer rid) { List&lt;TPermission> listPermission = permissionService.getPermissions(); List&lt;TPermission> listCurrentPermission = permissionService.getPermissionsById(rid); HashMap&lt;String, List&lt;TPermission>> map = new HashMap&lt;>(); map.put("listPermission", listPermission); map.put("listCurrentPermission", listCurrentPermission); return map; } 业务层： // 更新权限树 @Override public boolean updatePermission(Integer rid, String permission_ids) { // 删除角色权限 TRolePermissionExample tRolePermissionExample = new TRolePermissionExample(); Criteria criteria = tRolePermissionExample.createCriteria(); criteria.andRoleidEqualTo(rid); int count = mapper.deleteByExample(tRolePermissionExample); // 更新权限 if (permission_ids.contains(",")) { String[] split = permission_ids.split(","); for (String permission_id : split) { int i = Integer.parseInt(permission_id); TRolePermission rolePermission = new TRolePermission(); // 设置权限id rolePermission.setPermissionid(i); // 设置角色id rolePermission.setRoleid(rid); // 保存角色权限关系 mapper.insertSelective(rolePermission); } } else { int i = Integer.parseInt(permission_ids); TRolePermission rolePermission = new TRolePermission(); // 设置权限id rolePermission.setPermissionid(i); // 设置角色id rolePermission.setRoleid(rid); // 保存角色权限关系 mapper.insertSelective(rolePermission); } return true; } // 为角色分配权限，查询所有权限 @Override public List&lt;TPermission> getPermissions() { List&lt;TPermission> list_permission = mapper.selectByExample(null); return list_permission; } @Override public List&lt;TPermission> getPermissionsById(Integer rid) { List&lt;TPermission> list_permission = mapper.getRolePermission(rid); return list_permission; }]]></content>
      <categories>
        <category>权限</category>
      </categories>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易邮箱服务器发送电子邮件_搭建James邮件服务器发送电子邮件]]></title>
    <url>%2F2019%2F01%2F13%2Fwang-yi-you-xiang-fu-wu-qi-fa-song-dian-zi-you-jian-da-jian-james-you-jian-fu-wu-qi-fa-song-dian-zi-you-jian%2F</url>
    <content type="text"><![CDATA[1、网易邮箱发送电子邮件 为了安全，网易邮箱开启pop3授权码验证，该授权码可以让客户端进行登录 qq开启授权码 https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;no=1001256&amp;&amp;id=28 实现：JavaMailAPI使用比较麻烦，这里采用的是Apache Commons Email 导入依赖 &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --> &lt;dependency> &lt;groupId>org.apache.commons&lt;/groupId> &lt;artifactId>commons-email&lt;/artifactId> &lt;version>1.4&lt;/version> &lt;/dependency> 测试：A simple text email @Test public void test01() throws Exception { SimpleEmail email = new SimpleEmail(); // 设置主机名，远程服务器的主机名 email.setHostName(&quot;smtp.163.com&quot;); email.setSmtpPort(25); // 设置登陆远程服务器的账号和pop3授权码 email.setAuthentication(&quot;15501892660@163.com&quot;, &quot;xxxxxxx&quot;); // 编写一个邮件 // 设置发送给谁 email.addTo(&quot;782125244@qq.com&quot;); // 设置这个邮件来源于哪里 email.setFrom(&quot;15501892660@163.com&quot;); // 设置邮件主题 email.setSubject(&quot;163发给qq的测试邮件 &quot;); // 设置邮件内容 email.setMsg(&quot;测试邮件&quot;); // 邮件发送 email.send(); } 参考： http://commons.apache.org/proper/commons-email/userguide.html 2、搭建James邮件服务器 下载 https://archive.apache.org/dist/james/server/ quick-start http://james.apache.org/server/quick-start.html 解压 D:\devsoft\apache-james-3.0-beta4 建库 配置数据源 启动 D:\devsoft\apache-james-3.0-beta4\bin&gt;run.bat INFO 09:28:46,331 | org.apache.james.container.spring.context.JamesServerApplicationContext | Refreshing org.apache.james.container.spring.context.JamesServerApplicationContext@153f5a29: startup date [Thu Jan 03 09:28:46 CST 2019]; root of context hierarchy Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanDefinitionStoreException: Failed to create the JAXB binder; nested exception is javax.xml.bind.JAXBException: Provider com.sun.xml.internal.bind.v2.ContextFactory could not be instantiated: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions 类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition - with linked exception: [com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions 类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition ] at org.apache.camel.spring.handler.CamelNamespaceHandler$CamelContextBeanDefinitionParser.doParse(CamelNamespaceHandler.java:258) at org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser.parseInternal(AbstractSingleBeanDefinitionParser.java:85) at org.springframework.beans.factory.xml.AbstractBeanDefinitionParser.parse(AbstractBeanDefinitionParser.java:59) at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:73) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1419) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1409) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:184) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:140) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:111) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:334) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:174) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:209) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:243) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:127) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:93) at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:131) at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:522) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:436) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:93) at org.apache.james.container.spring.context.JamesServerApplicationContext.&lt;init&gt;(JamesServerApplicationContext.java:39) at org.apache.james.app.spring.JamesAppSpringMain.init(JamesAppSpringMain.java:61) at org.apache.james.app.spring.JamesAppSpringMain.main(JamesAppSpringMain.java:42) Caused by: javax.xml.bind.JAXBException: Provider com.sun.xml.internal.bind.v2.ContextFactory could not be instantiated: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions 类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition - with linked exception: [com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions 类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition ] at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:146) at javax.xml.bind.ContextFinder.find(ContextFinder.java:356) at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:431) at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:394) at org.apache.camel.spring.handler.CamelNamespaceHandler.createJaxbContext(CamelNamespaceHandler.java:187) at org.apache.camel.spring.handler.CamelNamespaceHandler.getJaxbContext(CamelNamespaceHandler.java:174) at org.apache.camel.spring.handler.CamelNamespaceHandler$CamelContextBeanDefinitionParser.doParse(CamelNamespaceHandler.java:256) ... 26 more Caused by: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions 类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition at com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException$Builder.check(IllegalAnnotationsException.java:91) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.getTypeInfoSet(JAXBContextImpl.java:445) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.&lt;init&gt;(JAXBContextImpl.java:277) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.&lt;init&gt;(JAXBContextImpl.java:124) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl$JAXBContextBuilder.build(JAXBContextImpl.java:1123) at com.sun.xml.internal.bind.v2.ContextFactory.createContext(ContextFactory.java:147) at com.sun.xml.internal.bind.v2.ContextFactory.createContext(ContextFactory.java:271) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:171) at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:131) ... 32 more D:\devsoft\apache-james-3.0-beta4\bin&gt; D:\devsoft\apache-james-3.0-beta4\bin&gt;run.bat INFO 09:37:44,247 | org.apache.james.container.spring.context.JamesServerApplicationContext | Refreshing org.apache.james.container.spring.context.JamesServerApplicationContext@7ca48474: startup date [Thu Jan 03 09:37:44 CST 2019]; root of context hierarchy log4j:WARN No appenders could be found for logger (org.apache.commons.configuration.ConfigurationUtils). log4j:WARN Please initialize the log4j system properly. log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. INFO 09:37:45,153 | org.apache.james.container.spring.context.JamesServerApplicationContext | Bean &#39;logprovider&#39; of type [class org.apache.james.container.spring.lifecycle.LogProviderImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) INFO 09:37:45,544 | james.mailrepositorystore | JamesMailStore init... INFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.file.FileMailRepository to handle file protocol requests for repositories with key file INFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.jdbc.JDBCMailRepository to handle db protocol requests for repositories with key db INFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.jdbc.JDBCMailRepository to handle dbfile protocol requests for repositories with key dbfile INFO 09:37:45,551 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.file.MBoxMailRepository to handle mbox protocol requests for repositories with key mbox INFO 09:37:45,936 | james.dnsservice | Autodiscovery is enabled - trying to discover your system&#39;s DNS Servers INFO 09:37:45,942 | james.dnsservice | Adding autodiscovered server 202.100.192.68 INFO 09:37:45,942 | james.dnsservice | Adding autodiscovered server 202.100.199.8 INFO 09:37:45,943 | james.dnsservice | DNS Server is: 202.100.192.68 INFO 09:37:45,943 | james.dnsservice | DNS Server is: 202.100.199.8 INFO 09:37:45,949 | james.dnsservice | Registered cache, resolver and search paths as DNSJava defaults 12 James WARN [main] openjpa.Runtime - An error occurred while registering a ClassTransformer with PersistenceUnitInfo: name &#39;James&#39;, root URL [file:/D:/devsoft/apache-james-3.0-beta4/conf/]. The error has been consumed. To see it, set your openjpa.Runtime log level to TRACE. Load-time class transformation will not be available. INFO 09:37:55,187 | james.domainlist | Set autodetect to: true INFO 09:37:55,187 | james.domainlist | Set autodetectIP to: true 28 James INFO [main] openjpa.Runtime - Starting OpenJPA 2.1.0 52 James INFO [main] openjpa.jdbc.JDBC - Using dictionary class &quot;org.apache.openjpa.jdbc.sql.MySQLDictionary&quot;. Cannot load JDBC driver class &#39;com.mysql.jdbc.Driver&#39; java.lang.ClassNotFoundException: com.mysql.jdbc.Driver at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at org.apache.commons.dbcp.BasicDataSource.createConnectionFactory(BasicDataSource.java:1420) at org.apache.commons.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1371) at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044) 解决办法 D:\devsoft\apache-james-3.0-beta4\conf\lib：存放自己导入的jar D:\devsoft\apache-james-3.0-beta4\lib：存放James默认jar 复制jaxb-impl-2.1.3.jar，mysql驱动jar包到conf/lib下 设置服务器域名、建立账户 D:\devsoft\apache-james-3.0-beta4\bin&gt; james-cli.bat -h localhost -p 9999 adddomain atguigu.com adddomain command executed sucessfully in 106 ms. D:\devsoft\apache-james-3.0-beta4\bin&gt; james-cli.bat -h localhost -p 9999 adduser test@atguigu.com test adduser command executed sucessfully in 94 ms. 配置Foxmail客户端连接James邮件服务器 测试： /** * 测试james发送邮件 * @Description (TODO这里用一句话描述这个方法的作用) * @throws Exception */ @Test public void test02() throws Exception{ SimpleEmail email = new SimpleEmail(); //设置主机名，远程服务器的主机名 email.setHostName("127.0.0.1"); //自定义的ip，一定要手动设置好端口号 email.setSmtpPort(25); //设置登陆远程服务器的密码 email.setAuthentication("test@atguigu.com", "000000"); //编写一个邮件 //设置发送给谁 email.addTo("17512080612@163.com"); //设置这个邮件来源于哪里 email.setFrom("admin@atguigu.com"); //设置邮件主题 email.setSubject("哈哈，给你测试 "); //设置邮件内容 email.setMsg("我能给您发邮件&lt;a href='http://www.atguigu.com'>尚硅谷&lt;/a>"); //邮件发送 email.send(); }]]></content>
      <categories>
        <category>邮件服务器</category>
      </categories>
      <tags>
        <tag>email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维矩阵显示账户类型和资质_ajax异步传参_插入mysql中文乱码]]></title>
    <url>%2F2019%2F01%2F11%2Fer-wei-ju-zhen-xian-shi-zhang-hu-lei-xing-he-zi-zhi-ajax-yi-bu-chuan-can-cha-ru-mysql-zhong-wen-luan-ma%2F</url>
    <content type="text"><![CDATA[1、二维矩阵显示账号类型和资质 效果： 表结构： 账号类型和资质中间表 资质表 思路： 业务层查出账户和资质中间表、资质表、账户表数据，前端展示图横轴根据账户数据填充，纵轴根据资质数据填充，选择框的确定–根据账户资质中间表数据和选择框上自定义属性绑定的账户名、资质id进行相等比较确定。 前端： 1）单选框勾选关系初始化 2）异步传参(封装成实体) 实体对象必须有get和set方法 &lt;body> &lt;% //设置导航条上的显示 pageContext.setAttribute("navinfo", "分类管理"); //设置点击高亮效果 pageContext.setAttribute("curUrl", "servicectrl/type/ctrl"); %> &lt;!--引入导航条 --> &lt;%@include file="/WEB-INF/includes/nav-bar.jsp"%> &lt;div class="container-fluid"> &lt;div class="row"> &lt;!--引入树形菜单 --> &lt;%@include file="/WEB-INF/includes/user_menu.jsp"%> &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"> &lt;div class="panel panel-default"> &lt;div class="panel-heading"> &lt;h3 class="panel-title"> &lt;i class="glyphicon glyphicon-th">&lt;/i> 数据矩阵 &lt;/h3> &lt;/div> &lt;div class="panel-body"> &lt;div class="table-responsive"> &lt;table class="table table-bordered"> &lt;thead> &lt;tr> &lt;th>名称&lt;/th> &lt;c:forEach items="${types}" var="type"> &lt;th>${type}&lt;/th> &lt;/c:forEach> &lt;/tr> &lt;/thead> &lt;tbody> &lt;c:forEach items="${certs}" var="cert"> &lt;tr> &lt;td>${cert.name}&lt;/td> &lt;c:forEach items="${types}" var="type"> &lt;td>&lt;input class='checkSimple' type="checkbox" type_name='${type}' cid='${cert.id}'>&lt;/td> &lt;/c:forEach> &lt;/c:forEach> &lt;/tr> &lt;/tbody> &lt;/table> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;%@include file="/WEB-INF/includes/js-file.jsp"%> &lt;!-- 引入树形菜单结构点击时动态显示页面高亮效果的js --> &lt;%@include file="/WEB-INF/includes/common-js.jsp"%> &lt;script type="text/javascript"> $(function() { $(".list-group-item").click(function() { if ($(this).find("ul")) { $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) { $("ul", this).hide("fast"); } else { $("ul", this).show("fast"); } } }) }) $(function() { //页面加载完成获取账户类型和资质的关系 var list_type_cert = '${list_type_cert_json}' log('list_type_cert', list_type_cert) //string log('list_type_cert type=======>', typeof (list_type_cert)) //JSON.parse(list_type_cert) 字符串转成json对象 $.each(JSON.parse(list_type_cert),function(index, content) { log(index, content, content.accttype,content.certid) $('.checkSimple').each(function() { //attr获取自定义属性值 if ($(this).attr('type_name') == (content.accttype)&amp;&amp; $(this).attr('cid') == (content.certid)) { //设置原生属性值 $(this).prop('checked',true) } }) }) //执行事件 __main() }) //更新 var update_type_cert_event = function() { var tAccountTypeCert = {} log('update_type_cert_event=============>') $('body').on('click', 'input', function() { log('update==========>', this) var flag = $(this).prop('checked') log('flag==========>', flag) accttype = $(this).attr('type_name') certid = $(this).attr('cid') log(accttype, certid) tAccountTypeCert.accttype = accttype tAccountTypeCert.certid = certid tAccountTypeCert.flag = flag var url = '${ctp}/servicectrl/type/update_type_cert' var data = tAccountTypeCert $.getJSON(url, data, function(result) { log(result) }) }) } var __main = function() { update_type_cert_event() } &lt;/script> &lt;/body> 控制层： 1)接收异步传参实体返回json package com.atguigu.scw.manager.controller.manager; import java.util.Arrays; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import com.atguigu.scw.manager.bean.TAccountTypeCert; import com.atguigu.scw.manager.bean.TCert; import com.atguigu.scw.manager.service.CertService; import com.atguigu.scw.manager.service.CertTypeService; import com.fasterxml.jackson.databind.ObjectMapper; @Controller @RequestMapping("/servicectrl/type") public class TypeController { @Autowired CertService certService; @Autowired CertTypeService cTypeService; private static ObjectMapper MAPPER = new ObjectMapper(); @RequestMapping("/ctrl") public String list(Model model) throws Exception { System.out.println("分类管理界面============>"); // 1、先去数据库查出表格横向的显示数据 List&lt;String> types = Arrays.asList("商业公司", "个体工商户", "个人经营", "政府及非营利组织"); // 2、在查出纵向要显示的标题 List&lt;TCert> certs = certService.getAllCert(); System.out.println("资质===========>"); System.out.println(certs); // 3、查询经营类型与资质关系中间表 // List&lt;TAccountTypeCert> cTypeService.getAllCertType(); List&lt;TAccountTypeCert> list_type_cert = cTypeService.getAllCertType(); System.out.println("经营类型===============>"); System.out.println(list_type_cert); // 4、将数据放到模型域当中 model.addAttribute("types", types); model.addAttribute("certs", certs); // list转json字符串 String list_type_cert_json = MAPPER.writeValueAsString(list_type_cert); System.out.println("经营类型--资质----"); System.out.println(list_type_cert_json); model.addAttribute("list_type_cert_json", list_type_cert_json); return "manager/servicemanager/type"; } @RequestMapping("/update_type_cert") @ResponseBody public String update_type_cert(TAccountTypeCert tAccountTypeCert) { System.out.println("更新经营类型---资质==========>"); System.out.println(tAccountTypeCert); boolean flag = tAccountTypeCert.isFlag(); System.out.println("flag============>"); System.out.println(flag); if (flag) { System.out.println("增加一条记录========>"); int count = cTypeService.updateTypeCert(tAccountTypeCert); } else { System.out.println("移除一条记录========>"); cTypeService.removeTypeCert(tAccountTypeCert); } return "success"; } } 业务层： 1）单表的写读操作 package com.atguigu.scw.manager.service.impl; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.atguigu.scw.manager.bean.TAccountTypeCert; import com.atguigu.scw.manager.bean.TAccountTypeCertExample; import com.atguigu.scw.manager.bean.TAccountTypeCertExample.Criteria; import com.atguigu.scw.manager.dao.TAccountTypeCertMapper; import com.atguigu.scw.manager.service.CertTypeService; @Service public class CertTypeServiceImpl implements CertTypeService { @Autowired TAccountTypeCertMapper mapper; //查询资质和账户中间表 @Override public List&lt;TAccountTypeCert> getAllCertType() { List&lt;TAccountTypeCert> list_type_cert = mapper.selectByExample(null); return list_type_cert; } // 增加经营类型--资质 @Override public int updateTypeCert(TAccountTypeCert tAccountTypeCert) { int count = mapper.insertSelective(tAccountTypeCert); return count; } // 删除经营类型--资质 @Override public int removeTypeCert(TAccountTypeCert tAccountTypeCert) { TAccountTypeCertExample example = new TAccountTypeCertExample(); Criteria criteria = example.createCriteria(); criteria.andAccttypeEqualTo(tAccountTypeCert.getAccttype()); criteria.andCertidEqualTo(tAccountTypeCert.getCertid()); int count = mapper.deleteByExample(example); return count; } } 2、mysql插入中文乱码 1）数据库编码和web.xml配置均为utf-8，Controller读取到的是正确的中文，但是保存到数据库后变成”??” 解决 &lt;property name="url" value="jdbc:mysql://localhost:3306/scw_0325?useUnicode=true&amp;amp;characterEncoding=UTF-8" >&lt;/property>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>ajax -	ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ztree树形结构菜单_mybatis分页查询]]></title>
    <url>%2F2019%2F01%2F10%2Fztree-shu-xing-jie-gou-cai-dan-mybatis-fen-ye-cha-xun%2F</url>
    <content type="text"><![CDATA[1、二级树形菜单 效果图 表结构 业务层： 二级菜单实现思路： 1）查出父菜单（pid=0），通过遍历父菜单获得父菜单(id)，根据父菜单id值作为条件查出子菜单（子菜单pid=父菜单id），接着整理父子菜单关系；这种不推荐，假如所有菜单为18个，查出父菜单3个封装到集合时需要遍历18次，根据父菜单id作为查询子菜单的条件需要遍历3*18次。 2）一次性查出所有菜单18个，使用程序进行组合，这种推荐，以空间换时间。 封装菜单实体 业务层： public List&lt;TPermission> getAllMenus() { // 保存父菜单 List&lt;TPermission> menus = new ArrayList&lt;TPermission>(); Map&lt;Integer, TPermission> map = new HashMap&lt;Integer, TPermission>(); // 查询所有菜单 // 参数为null，表示不带条件查询菜单 List&lt;TPermission> list = mapper.selectByExample(null); System.out.println("所有菜单=========>"); System.out.println(list); // 1、将所有菜单都放在map中 // 都是引用，如果从map中拿到这个数据改变以后，map中页面变化 for (TPermission tPermission : list) { map.put(tPermission.getId(), tPermission); } // 2、先封装父菜单，再将子菜单放入到父菜单中 for (TPermission tPermission : list) { if (tPermission.getPid() == 0) { menus.add(tPermission); } else { // tPermission（子菜单），拿到父菜单 Integer pid = tPermission.getPid(); // 拿到父菜单；以pid的值作为map中的菜单id，就是父菜单 TPermission p_menu = map.get(pid); // 拿到当前父菜单的子菜单；子菜单会有一些额外的问题 // 这个list第一次获取是没有的，如果添加上一次以后。这个list是有的 List&lt;TPermission> childs = p_menu.getChilds(); if (childs != null) { // 当前有子菜单 childs.add(tPermission); } else { // 当前没有子菜单 childs = new ArrayList&lt;>(); // 添加当前子菜单 childs.add(tPermission); // 将当前整理好的childs设置进去 p_menu.setChilds(childs); } } } System.out.println("父菜单===========>"); System.out.println(menus); return menus; } 控制层 1）将整理好的父子菜单数据放入到session域中，当前用户的这次会话一直使用，只需要去数据库查询一次 @RequestMapping(value = "/main.html") public String toMainPage(HttpSession session) { // 校验 // 判断session中是否有这个用户，如果没有去登陆页面 Object object = session.getAttribute(Constants.LOGIN_USER); if (object == null) { // 用户没登陆 return "redirect:/login.jsp"; } else { // 用户登陆才来到主页，session中没有菜单，或者菜单被我们从session中清除了 if (session.getAttribute(Constants.USER_MENUS) == null) { // 1、查出所有菜单，在页面进行显示 List&lt;TPermission> menus = ps.getAllMenus(); // 2、将查到的菜单放在session域中 // 菜单这些数据没必要每次来到主页，都调用service方法进行查询；放在session用户， // 当前用户的这次会话一直使用，只需要去数据库查一次 session.setAttribute(Constants.USER_MENUS, menus); } return "manager/main"; } } 前台： 1）引入：&lt;%@ taglib prefix=”fn” uri=”http://java.sun.com/jsp/jstl/functions&quot;%&gt;计算后台传过来的list集合的长度：${fn:length(p_menu.childs)} &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%> &lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%> &lt;%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions"%> &lt;div class="col-sm-3 col-md-2 sidebar"> &lt;div class="tree"> &lt;ul style="padding-left: 0px;" class="list-group"> &lt;li class="list-group-item tree-closed">&lt;a href="main.html">&lt;i class="glyphicon glyphicon-dashboard">&lt;/i> 控制面板&lt;/a>&lt;/li> &lt;!-- 遍历父菜单 --> &lt;c:forEach items="${sessionScope.userMenus}" var="p_menu"> &lt;li class="list-group-item tree-closed">&lt;span>&lt;i class="${p_menu.icon}">&lt;/i>${p_menu.name} &lt;span class="badge" style="float: right">${fn:length(p_menu.childs)}&lt;/span>&lt;/span> &lt;ul style="margin-top: 10px; display: none;"> &lt;!-- 遍历子菜单 --> &lt;c:forEach items="${p_menu.childs}" var="c_menu"> &lt;li style="height: 30px;">&lt;a href="${ctp}/${c_menu.url}" data-action="${c_menu.id}">&lt;i class="${c_menu.icon}">&lt;/i>${c_menu.name}&lt;/a>&lt;/li> &lt;/c:forEach> &lt;/ul>&lt;/li> &lt;/c:forEach> &lt;/ul> &lt;/div> &lt;/div> 2、mybatis分页查询 根据用户名或者账号进行查询 效果图： 引入依赖： &lt;!-- 分页 插件 --> &lt;dependency> &lt;groupId>com.github.pagehelper&lt;/groupId> &lt;artifactId>pagehelper&lt;/artifactId> &lt;/dependency> 业务层： 1）带条件查询 @Override public List&lt;TUser> getAllUsersByCondition(String str) { System.out.println("UserServiceImpl.getAllUsersByCondition 带条件查询员工============>"); // 查询条件拼接 // 第一次创建的条件，默认使用and连接的 TUserExample tUserExample = new TUserExample(); Criteria criteria = tUserExample.createCriteria(); Criteria criteria2 = tUserExample.createCriteria(); if (!str.trim().equals("")) { criteria.andLoginacctLike("%" + str + "%"); criteria.andUsernameLike("%" + str + "%"); } tUserExample.or(criteria2); List&lt;TUser> list_users_example = userMapper.selectByExample(tUserExample); return list_users_example; } 控制层： 1）mybatis分页插件会对结果集进行包装，必须在查询前设置： PageHelper.startPage(pn, ps); 2）查询后输入框数据回显：model.addAttribute(“sp”, search);（转发） @RequestMapping("/list") public String users(@RequestParam(value = "pn", defaultValue = "1") Integer pn, @RequestParam(value = "ps", defaultValue = "5") Integer ps, @RequestParam(value = "sp", defaultValue = "") String search, Model model) { System.out.println("UserController.users 用户列表显示页===========>"); System.out.println("前台请求参数[第xxx页，每页显示xxx条数]==========>"); System.out.println(pn); System.out.println(ps); // 分页显示数据,这里设置必须放到查询数据之前，否则前台会有问题 PageHelper.startPage(pn, ps); List&lt;TUser> list_users = userService.getAllUsersByCondition(search); System.out.println("查询到的所有用户列表========>"); System.out.println(list_users); PageInfo&lt;TUser> users = new PageInfo&lt;>(list_users, 5); System.out.println("分页后的数据处理"); System.out.println(users); // 将查询用户列表数据放在请求域中，表单查询参数回显到页面 model.addAttribute("users", users); model.addAttribute("sp", search); return "manager/permission/user"; } 前台： 1）为所有分页连接绑定单击事件，让其动态的带上分页的查询参数 var href = $(this).attr("href") + "&amp;sp="+ $("input[name='sp']").val()&lt;br/> $(this).attr("href", href) 2)全选和全不选函数 //全选/全不选函数 function checkall_reverse(check_all_btn, check_btn) { check_all_btn.click(function() { //如果是原生的属性，使用prop获取比较好 check_btn.prop("checked", $(this).prop("checked")) }) check_btn.click(function() { //当check_btn点满以后check_all_btn勾上，否则不选中 //获取被选中的checkbtn个数 var flag = check_btn.filter(":checked").length == check_btn.length check_all_btn.prop("checked", flag); }) } &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%> &lt;!DOCTYPE html> &lt;html lang="UTF-8"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"> &lt;meta name="viewport" content="width=device-width, initial-scale=1"> &lt;meta name="description" content=""> &lt;meta name="author" content=""> &lt;%@include file="/WEB-INF/includes/css-file.jsp"%> &lt;link rel="stylesheet" href="${ctp}/css/main.css"> &lt;style> .tree li { list-style-type: none; cursor: pointer; } table tbody tr:nth-child(odd) { background: #F4F4F4; } table tbody td:nth-child(even) { color: #C00; } &lt;/style> &lt;/head> &lt;body> &lt;% //设置导航条上的显示 pageContext.setAttribute("navinfo", "用户维护"); //设置点击高亮效果 pageContext.setAttribute("curUrl", "permission/user/list"); %> &lt;!-- 引入navbar--> &lt;%@include file="/WEB-INF/includes/nav-bar.jsp"%>&lt;/nav> &lt;div class="container-fluid"> &lt;div class="row"> &lt;!-- 引入树形菜单 --> &lt;%@include file="/WEB-INF/includes/user_menu.jsp"%> &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"> &lt;div class="panel panel-default"> &lt;div class="panel-heading"> &lt;h3 class="panel-title"> &lt;i class="glyphicon glyphicon-th">&lt;/i> 数据列表 &lt;/h3> &lt;/div> &lt;div class="panel-body"> &lt;form class="form-inline" role="form" style="float: left;" action="${ctp }/permission/user/list" method="post"> &lt;div class="form-group has-feedback"> &lt;div class="input-group"> &lt;div class="input-group-addon">查询条件&lt;/div> &lt;input class="form-control has-success" type="text" name="sp" placeholder="用户名/账号查询" value="${sp}"> &lt;/div> &lt;/div> &lt;button type="submit" class="btn btn-warning"> &lt;i class="glyphicon glyphicon-search">&lt;/i> 查询 &lt;/button> &lt;/form> &lt;button type="button" class="btn btn-danger" style="float: right; margin-left: 10px;"> &lt;i class=" glyphicon glyphicon-remove">&lt;/i> 删除 &lt;/button> &lt;button type="button" class="btn btn-primary" style="float: right;" onclick="window.location.href='add.html'"> &lt;i class="glyphicon glyphicon-plus">&lt;/i> 新增 &lt;/button> &lt;br> &lt;hr style="clear: both;"> &lt;div class="table-responsive"> &lt;table class="table table-bordered"> &lt;thead> &lt;tr> &lt;th width="30">#&lt;/th> &lt;th width="30">&lt;input type="checkbox" id="checkall_btn">&lt;/th> &lt;th>账号&lt;/th> &lt;th>名称&lt;/th> &lt;th>邮箱地址&lt;/th> &lt;th width="100">操作&lt;/th> &lt;/tr> &lt;/thead> &lt;tbody> &lt;c:forEach items="${users.list}" var="user"> &lt;tr> &lt;td>${user.id}&lt;/td> &lt;td>&lt;input type="checkbox" class="single_check">&lt;/td> &lt;td>${user.loginacct }&lt;/td> &lt;td>${user.username }&lt;/td> &lt;td>${user.email }&lt;/td> &lt;td> &lt;button type="button" class="btn btn-success btn-xs"> &lt;i class=" glyphicon glyphicon-check">&lt;/i> &lt;/button> &lt;button type="button" class="btn btn-primary btn-xs"> &lt;i class=" glyphicon glyphicon-pencil">&lt;/i> &lt;/button> &lt;button type="button" class="btn btn-danger btn-xs"> &lt;i class=" glyphicon glyphicon-remove">&lt;/i> &lt;/button> &lt;/td> &lt;/tr> &lt;/c:forEach> &lt;/tbody> &lt;tfoot> &lt;tr> &lt;td colspan="6" align="center"> &lt;ul class="pagination"> &lt;!-- 即使点击分页连接也应该带上查询条件的值 --> &lt;!-- 给分页超链接绑定单击事件； --> &lt;li>&lt;a href="${ctp}/permission/user/list?pn=1">首页&lt;/a>&lt;/li> &lt;!-- 是否还有前一页 --> &lt;c:if test="${users.hasPreviousPage}"> &lt;li>&lt;a href="${ctp}/permission/user/list?pn=${users.prePage}">上一页&lt;/a>&lt;/li> &lt;/c:if> &lt;!-- 遍历页数 --> &lt;c:forEach items="${users.navigatepageNums}" var="pn"> &lt;!-- 当前页 --> &lt;c:if test="${pn==users.pageNum }"> &lt;li class="active">&lt;a href="${ctp}/permission/user/list?pn=${pn}">${pn}&lt;span class="sr-only">(current)&lt;/span>&lt;/a>&lt;/li> &lt;/c:if> &lt;c:if test="${pn != users.pageNum }"> &lt;li>&lt;a href="${ctp}/permission/user/list?pn=${pn}">${pn }&lt;/a>&lt;/li> &lt;/c:if> &lt;/c:forEach> &lt;!--是否还有下一页 --> &lt;c:if test="${users.hasNextPage}"> &lt;li>&lt;a href="${ctp}/permission/user/list?pn=${users.nextPage}">下一页&lt;/a>&lt;/li> &lt;/c:if> &lt;li>&lt;a href="${ctp}/permission/user/list?pn=${users.pages}">末页&lt;/a>&lt;/li> &lt;/ul> &lt;/td> &lt;/tr> &lt;/tfoot> &lt;/table> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;%@include file="/WEB-INF/includes/js-file.jsp"%> &lt;!-- 引入树形菜单结构点击时动态显示页面高亮效果的js --> &lt;%@include file="/WEB-INF/includes/common-js.jsp"%> &lt;script type="text/javascript"> $(function() { $(".list-group-item").click(function() { if ($(this).find("ul")) { $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) { $("ul", this).hide("fast"); } else { $("ul", this).show("fast"); } } }); }); $("tbody .btn-success").click(function() { window.location.href = "assignRole.html"; }); $("tbody .btn-primary").click(function() { window.location.href = "edit.html"; }); //当前页面所在的哪个超链接是color:red //他的父list-group-item. tree-closed是没有的 //找到当前页面的a连接 //使用css为某个元素加样式 list-group-item //为所有分页连接绑定单击事件，让其动态的带上分页的查询参数 $(".pagination").find("a").click( function() { //1、获取到查询表单的查询参数 //不禁用默认行为，而是为超链接多拼装上查询条件 //为超链接动态拼装查询条件 var href = $(this).attr("href") + "&amp;sp=" + $("input[name='sp']").val() $(this).attr("href", href) }) //这是调用了抽取过来的方法； checkall_reverse($("#checkall_btn"), $(".single_check")) &lt;/script> &lt;/body> &lt;/html>]]></content>
      <categories>
        <category>权限</category>
      </categories>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn版本控制]]></title>
    <url>%2F2019%2F01%2F09%2Fsvn-ban-ben-kong-zhi%2F</url>
    <content type="text"><![CDATA[1、svn下载 https://sourceforge.net/projects/win32svn/ 2、验证是否安装成功 C:\Users\libingshen&gt;svn --version 3、创建版本库 D:\mytest\mysvn\OA&gt;svnadmin create D:\mytest\mysvn\OA 4、启动svn服务 5、验证svn服务是否启动 svn服务监听3690端口 6、svn注册为Windows服务 tip:等号左边没有空格，等号右边有一个空格。 C:\WINDOWS\system32&gt;sc create MySVNService binpath= &quot;C:\Pmyprogram\svn\bin\svnserve.exe --service -r D:\mytest\mysvn&quot; start= auto depend= Tcpip 原因：每次启动svn服务时必须启动一个cmd窗口，cmd窗口一关闭，svn服务就关闭。 非管理员运行时会失败。 管理员运行 启动、停止、删除svn服务（管理员身份运行cmd） //启动svn服务 C:\WINDOWS\system32&gt;sc start MySVNService //停止服务 C:\WINDOWS\system32&gt;sc stop MySVNService //删除服务 C:\WINDOWS\system32&gt;sc delete MySVNService 7、检出项目 D:\mytest\mycheckout&gt;svn checkout svn://localhost/OA MyOA 8、提交文件 –开启匿名权限访问 –先将文件加入版本库，然后提交（需添加提交日志信息，不然报错） svn commit 命令最后可以不指定具体文件，此时表示提交当前工作副本中的所有修改 9、更新 另一个客户端检出项目、更新并提交文件 //远程版本库具体位置 svn://localhost/OA //将OA检出到本地的目录 MyOA2 D:\mytest\mycheckout&gt;svn checkout svn://localhost/OA MyOA2 10、授权访问版本库 –单版本库开启授权访问 –多版本库开启授权访问 在版本库根目录 D:\mytest\mysvn 下创建 commConf 目录 将未修改的 authz 和 passwd 文件拷贝到 commConf 目录下 修改需要设置权限的版本库的 svnserve.conf 文件 ①password-db = ../../commConf/passwd ②authz-db = ../../commConf/authz passwd：设置访问版本库的用户信息 authz：设置用户访问版本库的权限]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc配置]]></title>
    <url>%2F2019%2F01%2F07%2Fspringmvc-pei-zhi%2F</url>
    <content type="text"><![CDATA[1、springmvc路径跳转配置 目录结构 控制层 &lt;!-- 使用注解开发，不用配置controller，需要配置一个组件扫描器 --> &lt;context:component-scan base-package="com.*" /> &lt;!-- 视图解析器 --> &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"> &lt;!-- 配置从项目根目录到指定目录一端路径 ,建议指定浅一点的目录 --> &lt;property name="prefix" value="/WEB-INF/jsp/">&lt;/property> &lt;!-- 文件的后缀名 --> &lt;property name="suffix" value=".jsp">&lt;/property> &lt;/bean> &lt;!--将index2.jsp放在/WEB-INF/jsp/目录下，请求index2时不经过controller处理; 配置了mvc:view-controller后需要配置mvc:annotation-driven,不然走controller的请求会失效 --> &lt;mvc:view-controller path="/index2" view-name="index2" /> &lt;mvc:annotation-driven>&lt;/mvc:annotation-driven> &lt;!--处理静态资源 --> &lt;mvc:default-servlet-handler/> index.jsp &lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1" pageEncoding="ISO-8859-1"%> &lt;%@ taglib uri="http://java.sun.com/jstl/core_rt" prefix="c"%> &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="ISO-8859-1"> &lt;title>Insert title here&lt;/title> &lt;% request.setAttribute("path", request.getContextPath()); %> &lt;/head> &lt;body> //走controller跳转 &lt;a href="hello">go controller&lt;/a> &lt;br> //不走controller跳转，在springmvc配置文件中配置了mvc-view;index2.jsp页面需放在/WEB-INF/jsp/目录下 &lt;a href="index2">not go controller&lt;/a> &lt;br/> //加载静态资源 &lt;a href="${path}/static/index3.jsp">load static resource index3.jsp&lt;/a> //加载静态资源，需在springmvc配置文件中配置mvc:default-servlet-handler &lt;script type="text/javascript" src="${path}/ui/jquery/jquery-1.8.3.min.js">&lt;/script> &lt;script type="text/javascript"> $(function() { console.log("${path}") }) &lt;/script> &lt;/body> &lt;/html> 2、springmvc获取请求参数，封装数据到请求域 前台 &lt;form action='testParam' method='get'> 用户名：&lt;input type='text' name='username'> &lt;button>提交&lt;/button> &lt;/form> 控制层 处理方式一：方法参数为Map或者ModelMap类型，数据封装到Map或者Modelmap类型中，其实就是将数据放入到请求域当中 @RequestMapping("/testParam") public String testParam(ModelMap modelMap,HttpServletRequest request) { String username = request.getParameter("username"); System.out.println("接收前台发送过来的请求参数=========>用户名："+username); //modelmap会将数据放到请求域当中 modelMap.put("address", "haikou"); //返回视图 return "hello"; } 处理方式二：用ModelAndView作为返回值，可以将数据放到请求域中且指定返回的视图 @RequestMapping("/testParam") public ModelAndView testParam(HttpServletRequest request) { String username = request.getParameter("username"); System.out.println("接收前台发送过来的请求参数=========>用户名："+username); //参数为返回的视图 ModelAndView hello =new ModelAndView("hello"); hello.addObject("address", "haikou"); return hello; } 前台获取 &lt;!-- 获取后台封装在请求域中的数据 --&gt; 地址：${requestScope.address}&lt;br/&gt; &lt;%=request.getAttribute(&quot;address&quot;)%&gt; 3、springmvc处理文件上传 springmvc.xml增加如下配置 &lt;!--文件上传 --> &lt;bean name="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"> &lt;property name="defaultEncoding" value="UTF-8">&lt;/property> &lt;property name="maxUploadSize" value="10240000">&lt;/property> &lt;/bean> 前台表单提交 //必须是post请求，且enctype='multipart/form-data' &lt;form action='testFileUpload' method='post' enctype='multipart/form-data'> 文件：&lt;input type='file' name='file' >&lt;br/> &lt;button>提交&lt;/button> &lt;/form> 控制层 @RequestMapping("/testFileUpload") public String testFileUpload(@RequestParam("file")MultipartFile file) throws IOException { //获取文件名 String fileName=file.getOriginalFilename(); //获取流，即可取得内容 InputStream in=file.getInputStream(); System.out.println("文件名===========>"+fileName); return "hello"; } 4、springmvc返回json数据 pom.xml加入依赖 &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --> &lt;dependency> &lt;groupId>com.fasterxml.jackson.core&lt;/groupId> &lt;artifactId>jackson-databind&lt;/artifactId> &lt;version>2.9.6&lt;/version> &lt;/dependency> &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --> &lt;dependency> &lt;groupId>com.fasterxml.jackson.core&lt;/groupId> &lt;artifactId>jackson-core&lt;/artifactId> &lt;version>2.9.6&lt;/version> &lt;/dependency> &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --> &lt;dependency> &lt;groupId>com.fasterxml.jackson.core&lt;/groupId> &lt;artifactId>jackson-annotations&lt;/artifactId> &lt;version>2.9.6&lt;/version> &lt;/dependency> 控制层 //需要加@ResponseBody注解 @RequestMapping("/testJson") @ResponseBody public Map testFileUpload() { Map&lt;String, Object> map=new HashMap&lt;>(); map.put("username", "沈利兵"); map.put("sex", "男"); return map; }]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my_en]]></title>
    <url>%2F2019%2F01%2F06%2Fmy-en%2F</url>
    <content type="text"><![CDATA[english20181214 eviction --赶出 thorough --彻底 fixed --固定 notifications --通知 traverse graphs --遍历图 covers --覆盖 block --阻塞 Redis Releases --Redis 发布 Benchmarks --基准 Latency monitoring --延迟监控 tune --调整 High Availability --高可用性 Signals Handling --信号处理 Administration --管理 troubleshoot --解决 Troubleshooting --故障排除 command line interface --命令行界面 durability --持久力 Credits --积分 Sponsors --赞助商 Trademark --商标 Lexicographical order --字典顺序 populated --填充 reply --答复、回复 indicating --指示、说明 penultimate --倒数第二 treat --对待、视其为 abstractions --抽象 separately --单独、分别地 retrieve --检索、取出 bitmaps --位图 probabilistic --概率 estimate --估计 cardinality --基数 scared --害怕 trivial --不重要的、微不足道的 crash course --速成班 specification --规范 Prerequisites --先决条件 clause --条款、子句 omit --忽略 semantics --语义 20181215 参考https://tylermcginnis.com/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/ opinion --观点 properly --正确地 strategy --策略 interpret --解释 authoring --创作 form --形式 consist of --包括 responsibilities --责任 spot --点、发现 key --关键 phases --阶段 deserve --值得 cement --巩固 Hoisting --提升 exactly identical --完全相同 fairly comfortable --相当熟悉 adapt --调整、适应 Set up memory space --设置内存空间 Execution Stack --执行堆栈 Call Stack --调用堆栈 intuition --直觉 scenario --脚本 misunderstood --误解 Implicit Binding --隐式绑定 Explicit Binding --显示绑定 Lexical Binding --词法绑定 20181217参考 https://dev.to/siwalik/async-programming-basics-every-js-developer-should-know-in-2018-a9c hence --于是 imensely --非常 20190117参考： https://docs.python.org/3/library/stdtypes.html#comparisons Comparisons --比较 Comparisons can be chained arbitrarily --比较可以任意连接 negated --否定 notion --概念、主张 raise --养、引发 https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range ascending --升序 restrictions --限制 imposed --加强 lexicographically --字典顺序 multidimensional list --多维列表 Immutable Sequence Types --不可变序列类型 slice --切片 20190523来源： Jekyll • Simple, blog-aware, static sites | Transform your plain text into static websites and blogs Sick 厌倦 custom domain name 自定义域名 pesky 讨厌 omment moderation 评论审核 Permalinks 永久链接 Migrate your blog 迁移你的博客 site scaffold 站点脚手架 metadata file 元数据文件 Front Matter 前方问题 Assets 资产 SITE STRUCTURE 现场结构 Liquid 液体 Pagination 分页 extendable 扩展 static site generator 静态站点生成器 churns 搅动 tweak 拧 tweaks 调整 unearthed 发现 regarding 关于 nstallation wizard 安装向导 Command Prompt instance 命令提示符实例 code snippets 代码片段 20190603 the related materials used in this book 本书中使用的相关资料 Protocol Analysis Institute 方案分析研究所 warranty 担保 Dedication 奉献]]></content>
      <categories>
        <category>词汇</category>
      </categories>
      <tags>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven配置]]></title>
    <url>%2F2019%2F01%2F05%2Fmaven-pei-zhi%2F</url>
    <content type="text"><![CDATA[1、下载： https://maven.apache.org/download.cgi 2、配置path环境变量 3、验证安装是否成功 4、配置本地仓库、阿里镜像、jdk编译版本 配置本地仓库位置 &lt;localRepository&gt;C:\greensoft\apache-maven-3.5.2\repository&lt;/localRepository&gt; 配置jar包下载阿里远程镜像 &lt;mirror> &lt;id>aliyun-maven&lt;/id> &lt;name>aliyun-maven&lt;/name> &lt;url>http://maven.aliyun.com/nexus/content/groups/public&lt;/url> &lt;mirrorOf>central&lt;/mirrorOf> &lt;/mirror> 配置jdk编译版本 &lt;profile> &lt;id>jdk-1.7&lt;/id> &lt;activation> &lt;activeByDefault>true&lt;/activeByDefault> &lt;jdk>1.7&lt;/jdk> &lt;/activation> &lt;properties> &lt;maven.compiler.source>1.7&lt;/maven.compiler.source> &lt;maven.compiler.target>1.7&lt;/maven.compiler.target> &lt;maven.compiler.compilerVersion>1.7&lt;/maven.compiler.compilerVersion> &lt;/properties> &lt;/profile> 5、eclipse整合maven 使用自己的maven安装包 6、IDEA整合maven]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象_箭头函数this_数组常用方法]]></title>
    <url>%2F2019%2F01%2F04%2Fjs-mian-xiang-dui-xiang-jian-tou-han-shu-this-shu-zu-chang-yong-fang-fa%2F</url>
    <content type="text"><![CDATA[1、js面向对象 1)传统的面向对象 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> function Person(name, age){ this.name=name; this.age=age; } Person.prototype.showName=function (){ alert('我叫'+this.name); }; Person.prototype.showAge=function (){ alert('我'+this.age+'岁'); }; let p=new Person('blue', 18); p.showName(); p.showAge(); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 继承 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> function Person(name, age){ this.name=name; this.age=age; } Person.prototype.showName=function (){ alert('我叫'+this.name); }; Person.prototype.showAge=function (){ alert('我'+this.age+'岁'); }; //------------------------------------------------ function Worker(name, age, job){ //通过call调用父类构造函数 Person.call(this, name, age); this.job=job; } //使得子类实例对象共享父类原型对象上的方法 Worker.prototype=new Person(); //重写子类原型对象的构造，特别恶心 Worker.prototype.constructor=Worker; Worker.prototype.showJob=function (){ alert('我是做：'+this.job); }; let w=new Worker('blue', 18, '打杂的'); w.showName(); w.showAge(); w.showJob(); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 2）js标准的面向对象 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> /*function Person(name, age){ this.name=name; this.age=age; } Person.prototype.showName=function (){ alert('我叫'+this.name); }; Person.prototype.showAge=function (){ alert('我'+this.age+'岁'); };*/ //标准面向对象书写方式 class Person{ constructor(name, age){ this.name=name; this.age=age; } showName(){ alert('我叫'+this.name); } showAge(){ alert('我'+this.age+'岁'); } } let p=new Person('blue', 18); p.showName(); p.showAge(); //------------------------------------------------ function Worker(name, age, job){ Person.call(this, name, age); this.job=job; } Worker.prototype=new Person(); Worker.prototype.constructor=Worker; Worker.prototype.showJob=function (){ alert('我是做：'+this.job); }; &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 标准的继承方式 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> /*function Person(name, age){ this.name=name; this.age=age; } Person.prototype.showName=function (){ alert('我叫'+this.name); }; Person.prototype.showAge=function (){ alert('我'+this.age+'岁'); };*/ //标准面向对象书写方式 class Person{ constructor(name, age){ this.name=name; this.age=age; } showName(){ alert('我叫'+this.name); } showAge(){ alert('我'+this.age+'岁'); } } /*let p=new Person('blue', 18); p.showName(); p.showAge();*/ //------------------------------------------------ /*function Worker(name, age, job){ Person.call(this, name, age); this.job=job; } Worker.prototype=new Person(); Worker.prototype.constructor=Worker; Worker.prototype.showJob=function (){ alert('我是做：'+this.job); };*/ //标准继承方式，子类通过extends实例化的子类可以访问到父类原型对象的方法 class Worker extends Person{ constructor(name, age, job){ //super-超类(父类)，可以访问到构造方法，不需要通过call的方式调用 super(name, age); this.job=job; } showJob(){ alert('我是做：'+this.job); } } let w=new Worker('blue', 18, '打杂的'); w.showName(); w.showAge(); w.showJob(); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 2、箭头函数this 普通函数：根据调用我的人 this老变 箭头函数：根据所在的环境 this恒定 bind——给函数定死一个this 例1： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let arr = [1, 2, 3]; //箭头函数所处的环境是window arr.a = () => { console.log(this); }; arr.a(); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 输出 例2： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> document.onclick=function (){ let arr=[1,2,3]; //箭头函数所处的环境是document arr.a=()=>{ console.log(this); }; arr.a(); }; &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 输出 ![](https://raw.githubusercontent.com/shenlibing/blogphoto/master/source/箭头函数this (2).png) 例3： 箭头函数所处的环境是document，尽管通过bind绑定死了12，但还是输出document，说明箭头函数的this优先级高于bind方式绑定的this &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> document.onclick=function (){ let a=()=>{ console.log(this); }; let oBtn=document.getElementById('btn1'); oBtn.onclick=a.bind(12); }; &lt;/script> &lt;/head> &lt;body> &lt;input type="button" value="aaa" id="btn1"> &lt;/body> &lt;/html> 输出 ![](https://raw.githubusercontent.com/shenlibing/blogphoto/master/source/箭头函数this (3).png) 3、数组常用方法 1）map 映射 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(function (item){ if(item>=60){ return true; }else{ return false; } }); //true,false,true,false,false alert(arr2); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 改进1 map参数：回调函数使用箭头函数书写方式 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let arr=[62, 55, 82, 37, 26]; let arr2=arr.map((item)=>{ if(item>=60){ return true; }else{ return false; } }); alert(arr2); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 改进2 如果有且仅有1个参数，()可以省 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(item=>{ if(item>=60){ return true; }else{ return false; } }); alert(arr2); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 改进3 如果函数体只有一句话，而且是return，{}可以省 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(item=>item>=60); alert(arr2); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 2）filter过滤 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let arr=[12,5,88,37,21,91,17,24]; let arr2=arr.filter(item=>item%2); //5,37,21,91,17 alert(arr2); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 3）forEach 遍历 求和 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let arr=[12,5,88,37,21,91,17,24]; let sum=0; arr.forEach(item=>{ sum+=item; }); //结果295 alert(sum); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 4）reduce 汇总 参数 tmp:中间结果 item：元素项 index：元素索引 求和 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let arr=[12,5,88,37,21,91,17,24]; let sum=arr.reduce((tmp,item,index)=>{ console.log(tmp, item, index); return tmp+item; }); console.log(sum); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 输出 求平均 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;script> let arr=[12,5,88,37,21,91,17,24]; let sum=arr.reduce((tmp,item,index)=>{ return tmp+item; }); //结果36.875 console.log(sum/arr.length); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 5）from 将类数组转换成数组 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>&lt;/title> &lt;style media="screen"> div {width:200px; height:200px; background:#CCC; float:left; margin:10px;} &lt;/style> &lt;script> window.onload=function (){ //DOM对象 let aDiv=document.getElementsByTagName('div'); console.log(aDiv); //数组 let aDiv2=Array.from(aDiv); console.log(aDiv2); Array.from(aDiv).forEach(div=>{ div.style.background='yellow'; }); Array.prototype.slice.call(aDiv).forEach(div=>{ div.style.background='blue'; }); }; &lt;/script> &lt;/head> &lt;body> &lt;div class="">&lt;/div> &lt;div class="">&lt;/div> &lt;div class="">&lt;/div> &lt;div class="">&lt;/div> &lt;div class="">&lt;/div> &lt;/body> &lt;/html> 输出]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js开发者经常忽略的基础知识点]]></title>
    <url>%2F2019%2F01%2F03%2Fjs-kai-fa-zhe-jing-chang-hu-lue-de-ji-chu-zhi-shi-dian%2F</url>
    <content type="text"><![CDATA[1、字符串匹配 匹配所有 // Mistake // 踩到坑了 var str = "David is an Arsenal fan, which means David is great"; str.replace("David", "Darren"); // "Darren is an Arsenal fan, which means David is great" // Desired // 符合预期 str.replace(/David/g, "Darren"); // "Darren is an Arsenal fan, which means Darren is great" 忽略大小写 str.replace(/david/gi, "Darren"); // "Darren will always be an Arsenal fan, which means Darren will always be great" 2、将“类数组”元素（比如 arguments 参数列表、节点列表和属性列表）转换成真正的数组 var nodesArr = Array.prototype.slice.call(document.querySelectorAll("div")); // "true" array of DIVs // 得到一个由 div 元素组成的“真正的”数组 var argsArr = Array.prototype.slice.call(arguments); // changes arguments to "true" array // 把 arguments 转换成一个“真正的”数组 克隆数组 var clone = myArray.slice(0); // naive clone // 浅克隆 3、数组的sort方法 简单排序 [1, 3, 9, 2].sort(); // Returns: [1, 2, 3, 9] // 返回 [1, 2, 3, 9] 复杂排序 [ { name: "Robin Van PurseStrings", age: 30 }, { name: "Theo Walcott", age: 24 }, { name: "Bacary Sagna", age: 28 } ].sort(function(obj1, obj2) { // Ascending: first age less than the previous // 实现增序排列：前者的 age 小于后者 return obj1.age - obj2.age; }); // Returns: // [ // { name: "Theo Walcott", age: 24 }, // { name: "Bacary Sagna", age: 28 }, // { name: "Robin Van PurseStrings", age: 30 } // ] 4、push合并数组 var mergeTo = [4,5,6]; var mergeFrom = [7,8,9]; Array.prototype.push.apply(mergeTo, mergeFrom); mergeTo; // is: [4, 5, 6, 7, 8, 9] 5、join拼接字符串 var str = [ '&lt;div>', '&lt;button id="lucky-draw">Lucky Draw&lt;/button>', '&lt;/div>' ].join('') log(str) 参考 https://github.com/cssmagic/blog/issues/21]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Inheritance and the Prototype Chain]]></title>
    <url>%2F2019%2F01%2F02%2Fjavascript-inheritance-and-the-prototype-chain%2F</url>
    <content type="text"><![CDATA[参考： https://tylermcginnis.com/javascript-inheritance-and-the-prototype-chain/ ##JavaScript Inheritance and the Prototype Chain Post This post is designed to be read after you read JavaScript Private and Public Class Fields. Previously we learned how to create an Animal class both in ES5 as well as in ES6. We also learned how to share methods across those classes using JavaScript’s prototype. To review, here’s the code we saw in an earlier post. function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } const leo = new Animal(&#39;Leo&#39;, 7) class Animal { constructor(name, energy) { this.name = name this.energy = energy } eat(amount) { console.log(`${this.name} is eating.`) this.energy += amount } sleep() { console.log(`${this.name} is sleeping.`) this.energy += length } play() { console.log(`${this.name} is playing.`) this.energy -= length } } const leo = new Animal(&#39;Leo&#39;, 7) Now let’s say we wanted to start making individual classes for specific animals. For example, what if we wanted to start making a bunch of dog instances. What properties and methods will these dogs have? Well, similar to our Animal class, we could give each dog a name, an energy level, and the ability to eat, sleep, and play. Unique to our Dog class, we could also give them a breed property as well as the ability to bark. In ES5, our Dog class could look something like this function Dog (name, energy, breed) { this.name = name this.energy = energy this.breed = breed } Dog.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Dog.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Dog.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } Dog.prototype.bark = function () { console.log(&#39;Woof-Woof!&#39;) this.energy -= .1 } const charlie = new Dog(&#39;Charlie&#39;, 10, &#39;Goldendoodle&#39;) Alright, well… we just recreated the Animal class and added a few new properties to it. If we wanted to create another animal, say a Cat, at this point we’d again have to create a Cat class, duplicate all the common logic located in the Animal class to it, then add on Cat specific properties just like we did with the Dog class. In fact, we’d have to do this for each different type of animal we created. function Dog (name, energy, breed) {} function Cat (name, energy, declawed) {} function Giraffe (name, energy, height) {} function Monkey (name, energy, domesticated) {}This work, but it seems wasteful. The Animal class is the perfect base class. What that means is that it has all the properties that each one of our animals has in common. Whether we’re creating a dog, cat, giraffe, or monkey, all of them will have a name, energy level, and the ability to eat, sleep, and play. With that said, is there a way we can utilize the Animal class whenever we create the individual classes for each different animal? Let’s try it out. I’ll paste the Animal class again below for easy reference. function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } function Dog (name, energy, breed) { } What are some things we know about the Dog constructor function above? First, we know it takes 3 arguments, name, energy, and breed. Second, we know it’s going to be called with the new keyword so we’ll have a this object. And third, we know we need to utilize the Animal function so that any instance of dog will have a name, energy level, and be able to eat, sleep, and play. It’s the third one that’s the tricky one. The way you “utilize” a function is by calling it. So we know that inside of Dog, we want to call Animal. What we need to figure out though is how we can invoke Animal in the context of Dog. What that means it that we want to call Animal with the this keyword from Dog. If we do that correctly, then this inside of the Dog function will have all the properties of Animal (name, energy). If you remember from a previous section, every function in JavaScript has a .call method on it. .call() is a method on every function that allows you to invoke the function specifying in what context the function will be invoked. This sounds like exactly what we need. We want to invoke Animal in the context of Dog. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } const charlie = new Dog(&#39;Charlie&#39;, 10, &#39;Goldendoodle&#39;) charlie.name // Charlie charlie.energy // 10 charlie.breed // GoldendoodleSolid, we’re half-way there. You’ll notice in the code above that because of this line Animal.call(this, name, energy), every instance of Dog will now have a name and energy property. Again, the reason for that is because it’s as if we ran the Animal function with the this keyword generated from Dog. Then after we added a name and energy property to this, we also added a breed property just as we normally would. Remember the goal here is to have each instance of Dog have not only all the properties of Animal, but also all the methods as well. If you run the code above, you’ll notice that if you try to run charlie.eat(10) you’ll get an error. Currently every instance of Dog will have the properties of Animal (name and energy), but we haven’t done anything to make sure that they also have the methods (play, eat, sleep). Let’s think about how we can solve this. We know that all the Animal’s methods are located on Animal.prototype. What that means is we somehow want to make sure that all instances of Dog will have access to the methods on Animal.prototype. What if we used our good friend Object.create here? If you’ll remember, Object.create allows you to create an object which will delegate to another object on failed lookups. So in our case, the object we want to create is going to be Dog’s prototype and the object we want to delegate to on failed lookups is Animal.prototype. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype)Now, whenever there’s a failed lookup on an instance of Dog, JavaScript will delegate that lookup to Animal.prototype. If this is still a little fuzzy, re-read A Beginner’s Guide to JavaScript’s Prototype where we talk all about Object.create and JavaScript’s prototype. Let’s look at the full code together then we’ll walk through what happens. function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype)Now we’ve created our base class (Animal) as well as our subclass (Dog), let’s see what it looks like under the hood when we create an instance of Dog. const charlie = new Dog(&#39;Charlie&#39;, 10, &#39;Goldendoodle&#39;) charlie.name // Charlie charlie.energy // 10 charlie.breed // GoldendoodleNothing fancy so far, but let’s look at what happens when we invoke a method located on Animal. charlie.eat(10) /* 1) JavaScript checks if charlie has an eat property - it doesn&#39;t. 2) JavaScript then checks if Dog.prototype has an eat property - it doesn&#39;t. 3) JavaScript then checks if Animal.prototype has an eat property - it does so it calls it. */ The reason Dog.prototype gets checked is because when we created a new instance of Dog, we used the new keyword. Under the hood, the this object that was created for us delegates to Dog.prototype (seen in comments below). function Dog (name, energy, breed) { // this = Object.create(Dog.prototype) Animal.call(this, name, energy) this.breed = breed // return this }The reason Animal.prototype gets checked is because we overwrote Dog.prototype to delegate to Animal.prototype on failed lookups with this line Dog.prototype = Object.create(Animal.prototype)Now one thing we haven’t talked about is what if Dog has its own methods? Well, that’s a simple solution. Just like with Animal, if we want to share a method across all instances of that class, we add it to the function’s prototype. ... function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&#39;Woof Woof!&#39;) this.energy -= .1 } very nice. There’s just one small addition we need to make. If you remember back to the Beginner’s Guide to JavaScript’s Prototype post, we were able to get access to the instances’ constructor function by using instance.constructor. function Animal (name, energy) { this.name = name this.energy = energy } const leo = new Animal(&#39;Leo&#39;, 7) console.log(leo.constructor) // Logs the constructor functionAs explained in the previous post, “the reason this works is because any instances of Animal are going to delegate to Animal.prototype on failed lookups. So when you try to access leo.prototype, leo doesn’t have a prototype property so it will delegate that lookup to Animal.prototype which indeed does have a constructor property.” The reason I bring this up is because in our implementation, we overwrote Dog.prototype with an object that delegates to Animal.prototype. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&#39;Woof Woof!&#39;) this.energy -= .1 }What that means is that now, any instances of Dog which log instance.constructor are going to get the Animal constructor rather than the Dog constructor. You can see for yourself by running this code - function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&#39;Woof Woof!&#39;) this.energy -= .1 } const charlie = new Dog(&#39;Charlie&#39;, 10, &#39;Goldendoodle&#39;) console.log(charlie.constructor)Notice it gives you the Animal constructor even though charlie is a direct instance of Dog. Again, we can walk through what’s happening here just like we did above. const charlie = new Dog(&#39;Charlie&#39;, 10, &#39;Goldendoodle&#39;) console.log(charlie.constructor) /* 1) JavaScript checks if charlie has a constructor property - it doesn&#39;t. 2) JavaScript then checks if Dog.prototype has a constructor property - it doesn&#39;t because it was deleted when we overwrote Dog.prototype. 3) JavaScript then checks if Animal.prototype has a constructor property - it does so it logs that. */How can we fix this? Well, it’s pretty simple. We can just add the correct constructor property to Dog.prototype once we overwrite it. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&#39;Woof Woof!&#39;) this.energy -= .1 } Dog.prototype.constructor = DogAt this point if we wanted to make another subclass, say Cat, we’d follow the same pattern. function Cat (name, energy, declawed) { Animal.call(this, name, energy) this.declawed = declawed } Cat.prototype = Object.create(Animal.prototype) Cat.prototype.constructor = Cat Cat.prototype.meow = function () { console.log(&#39;Meow!&#39;) this.energy -= .1 }This concept of having a base class with subclasses that delegate to it is called inheritance and it’s a staple of Object Oriented Programming (OOP). If you’re coming from a different programming language, odds are you’re already familiar with OOP and inheritance. Before ES6 classes, in JavaScript, inheritance was quite the task as you can see above. You need to understand now only when to use inheritance, but also a nice mix of .call, Object.create, this, and FN.prototype - all pretty advanced JS topics. Let’s see how we’d accomplish the same thing using ES6 classes though. First, let’s review what it looks like to go from an ES5 “class” to an ES6 class using our Animal class. function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } const leo = new Animal(&#39;Leo&#39;, 7) class Animal { constructor(name, energy) { this.name = name this.energy = energy } eat(amount) { console.log(`${this.name} is eating.`) this.energy += amount } sleep() { console.log(`${this.name} is sleeping.`) this.energy += length } play() { console.log(`${this.name} is playing.`) this.energy -= length } } const leo = new Animal(&#39;Leo&#39;, 7) Now that we’ve refactored our Animal constructor function into an ES6 class, the next thing we need to do is figure out how to refactor our base class (Dog). The good news is it’s much more intuitive. For reference, in ES5, here’s what we had. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&#39;Woof Woof!&#39;) this.energy -= .1 } Dog.prototype.constructor = DogBefore we get into inheritance, let’s refactor Dog to use an ES6 class as we learned in a previous post. class Dog { constructor(name, energy, breed) { this.breed = breed } bark() { console.log(&#39;Woof Woof!&#39;) this.energy -= .1 } } Looks great. Now, let’s figure out how to make sure that Dog inherits from Animal. The first step we need to make is a pretty straight forward one. With ES6 classes, you can extend a base class with this syntax class Subclass extends Baseclass {}Translated into our example, that would make our Dog class look like this class Animal { constructor(name, energy) { this.name = name this.energy = energy } eat(amount) { console.log(`${this.name} is eating.`) this.energy += amount } sleep() { console.log(`${this.name} is sleeping.`) this.energy += length } play() { console.log(`${this.name} is playing.`) this.energy -= length } } class Dog extends Animal { constructor(name, energy, breed) { this.breed = breed } bark() { console.log(&#39;Woof Woof!&#39;) this.energy -= .1 } } In ES5 in order to make sure that every instance of Dog had a name and an energy property, we used .call in order to invoke the Animal constructor function in the context of the Dog instance. Luckily for us, in ES6 it’s much more straight forward. Whenever you are extending a baseclass and you need to invoke that baseclass’ constructor function, you invoke super passing it any arguments it needs. So in our example, our Dog constructor gets refactored to look like this class Animal { constructor(name, energy) { this.name = name this.energy = energy } eat(amount) { console.log(`${this.name} is eating.`) this.energy += amount } sleep() { console.log(`${this.name} is sleeping.`) this.energy += length } play() { console.log(`${this.name} is playing.`) this.energy -= length } } class Dog extends Animal { constructor(name, energy, breed) { super(name, energy) // calls Animal&#39;s constructor this.breed = breed } bark() { console.log(&#39;Woof Woof!&#39;) this.energy -= .1 } } And that’s it. No using .call, no using Object.create, no worrying about resetting constructor on the prototype - just extends the baseclass and make sure to call super. What’s interesting about JavaScript is the same patterns you’ve learned these last few posts are directly caked into the language itself. Previously you learned that the reason all instances of Array have access to the array methods like pop, slice, filter, etc are because all of those methods live on Array.prototype. console.log(Array.prototype) /* concat: ƒn concat() constructor: ƒn Array() copyWithin: ƒn copyWithin() entries: ƒn entries() every: ƒn every() fill: ƒn fill() filter: ƒn filter() find: ƒn find() findIndex: ƒn findIndex() forEach: ƒn forEach() includes: ƒn includes() indexOf: ƒn indexOf() join: ƒn join() keys: ƒn keys() lastIndexOf: ƒn lastIndexOf() length: 0n map: ƒn map() pop: ƒn pop() push: ƒn push() reduce: ƒn reduce() reduceRight: ƒn reduceRight() reverse: ƒn reverse() shift: ƒn shift() slice: ƒn slice() some: ƒn some() sort: ƒn sort() splice: ƒn splice() toLocaleString: ƒn toLocaleString() toString: ƒn toString() unshift: ƒn unshift() values: ƒn values() */ You also learned that the reason all instances of Object have access to methods like hasOwnProperty and toString is because those methods live on Object.prototype. console.log(Object.prototype) /* constructor: ƒn Object() hasOwnProperty: ƒn hasOwnProperty() isPrototypeOf: ƒn isPrototypeOf() propertyIsEnumerable: ƒn propertyIsEnumerable() toLocaleString: ƒn toLocaleString() toString: ƒn toString() valueOf: ƒn valueOf() */ Here’s a challenge for you. With the list of Array methods and Object methods above, why does this code below work? const friends = [&#39;Mikenzi&#39;, &#39;Jake&#39;, &#39;Ean&#39;] friends.hasOwnProperty(&#39;push&#39;) // false If you look at Array.prototype, there isn’t a hasOwnProperty method. Well if there isn’t a hasOwnProperty method located on Array.prototype, how does the friends array in the example above have access to hasOwnProperty? The reason for that is because the Array class extends the Object class. So in our example above, when JavaScript sees that friends doesn’t have a hasOwnProperty property, it checks if Array.prototype does. When Array.prototype doesn’t, it checks if Object.prototype does, then it invokes it. It’s the same process we’ve seen throughout this blog post. JavaScript has two types - Primitive types and Reference types. Primitive types are boolean, number, string, null, and undefined and are immutable. Everything else is a reference type and they all extend Object.prototype. That’s why you can add properties to functions and arrays and that’s why both functions and arrays have access to the methods located on Object.prototype. function speak(){} speak.woahFunctionsAreLikeObjects = true console.log(speak.woahFunctionsAreLikeObjects) // true const friends = [&#39;Mikenzi&#39;, &#39;Jake&#39;, &#39;Ean&#39;] friends.woahArraysAreLikeObjectsToo = true console.log(friends.woahArraysAreLikeObjectsToo) // true –未完待续]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel入门]]></title>
    <url>%2F2019%2F01%2F01%2Fbabel-ru-men%2F</url>
    <content type="text"><![CDATA[1、babel Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments. 参考 https://babeljs.io/setup#installation 1)生成package.json文件(描述项目所需要的各种模块，以及项目的配置信息—比如名称、版本、许可证等元数据) npm init D:\mytest\babel&gt;npm init2)安装项目依赖 install Babel CLI locally D:\mytest\babel&gt;npm install --save-dev @babel/core @babel/cli3）添加编译运行脚本命令 &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;babel src -d src_build&quot; },结果 4）运行脚本命令 D:\mytest\babel&gt;npm run build此时并没有成功的将es6的语法转成es5 5）添加.babelrc文件 Great! You’ve configured Babel but you haven’t made it actually do anything. Create a .babelrc config in your project root and enable some plugins. To start, you can use the env preset, which enables transforms for ES2015+ D:\mytest\babel&gt;npm install @babel/preset-env --save-dev结果 ![](https://raw.githubusercontent.com/shenlibing/blogphoto/master/source/安装项目依赖 (2).png) ![](https://raw.githubusercontent.com/shenlibing/blogphoto/master/source/新建.babelrc文件 .png) 6）重新运行脚本命令 D:\mytest\babel&gt;npm run build![](https://raw.githubusercontent.com/shenlibing/blogphoto/master/source/编译前后比对 (2).png) 7)使用编译后的js &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&#39;../src_build/1.js&#39;&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;babel官网参考手册 https://babeljs.io/docs/en/usage]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>babel</tag>
        <tag>npm</tag>
      </tags>
  </entry>
</search>
